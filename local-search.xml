<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>G1GC算法篇</title>
    <link href="/2022/12/15/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    <url>/2022/12/15/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将通过对G1的整个回收周期的算法原理进行解读，如有偏差，请指正。</p><p>G1GC(Garbage First Garbage Collection)(简称G1) 自 JDK9 起，替代 Parallel Scavenge 和 Parallel Old 的组合，作为 Hotspot 在 Server 端的默认垃圾回收器，具有停顿时间可控、不产生内存碎片、返还未使用内存给堆等的特性，在 JDK9 之前可以通过 -XX:+UseG1G C的参数调用 G1 。</p><h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><p>在深入 G1GC 算法之前，先建立以下基本概念，如果读者已经掌握相关知识可以跳过这一部分，如果完全不了解这些概念，可以尝试简单了解一部分。</p><h2 id="自动内存管理系统"><a href="#自动内存管理系统" class="headerlink" title="自动内存管理系统"></a>自动内存管理系统</h2><p>在《 Java 虚拟机规范》中将 Java 堆描述为：“ The heap is the runtime data area form which memory for all class instances and arrays is allocated ” （随着 Java 语言的发展，“所有对象实例及数组都在堆上分配”这一点也不绝对）。Java 堆作为自动内存管理的内存区域，需要满足能在上面为新对象分配内存，并自动释放死亡对象所占据内存的功能，细分下就是需要回答下面三个问题：</p><ul><li>如何在堆上为新对象分配内存？</li><li>如何识别存活对象？</li><li>如何回收死亡对象占据的内存？</li></ul><p>对应到 G1GC 的算法，将从下面几点回答这三个问题：</p><ul><li>G1GC 堆结构（分配对象）</li><li>G1GC 并发标记（识别存活对象）</li><li>G1GC 转移对象过程（回收死亡对象）</li></ul><h2 id="软实时性"><a href="#软实时性" class="headerlink" title="软实时性"></a>软实时性</h2><p>G1GC 具有软实时性（ soft real-time ）。由于多数 GC 需要暂停应用程序，为了保证应用程序的软实时性（能保证大多数任务在最后期限之前完成，例如网络银行系统），我们要求 G1 ，在任意 1 秒的时间内，停顿不得超过 200ms 。G1 会尽量达成这个目标，它能够推算出本次要收集的大体区域，以增量的方式完成收集。</p><ul><li>设置<code>期望暂停时间</code>（ -XX:MaxGCPauseMillis ，默认 200）</li></ul><h2 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h2><p>GC 时判断哪些对象需要被回收有两种方法，引用计数法和可达性分析法。其中，G1 使用可达性分析算法通过一系列 <code>GC Roots</code> 作为起始点搜索所有通过引用可达的对象，搜索的路径称为引用链（ Reference Chain ），所有能被搜索到的对象被认为（标记为）存活对象。可作为 GC Roots 的对象包括但不限于下面几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>在方法区中类静态属性引用的对象</li><li>在方法区中常量引用的对象</li><li>本地方法栈中 JNI（ Native 方法）引用的对象</li></ul><p>下面是一段Java示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Obj</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<span class="hljs-comment">// a 为 root ，对象的引用</span><br>a.ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>(); <span class="hljs-comment">// a 的成员ref赋值变量的引用，当前可达</span><br><span class="hljs-comment">//System.gc();//如果此时发生 GC ，标记过程会从 a（ GC Root ）出发标记 a 指向的对象，再标记 a.ref 指向的对象</span><br>a = <span class="hljs-literal">null</span>;  <span class="hljs-comment">//a 指向的对象被回收，a.ref 指向的对象也需要被回收</span><br></code></pre></td></tr></table></figure><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>顾名思义，通过三种颜色完成标记，</p><ul><li>白色：表示对象尚未被垃圾收集器标记过。</li><li>黑色：表示对象已经被垃圾收集器标记过，且这个对象的所有引用都已经扫描标记过。</li><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过，可以理解为正在搜索的对象。</li></ul><p>简述三色标记法的遍历过程：</p><ol><li>初始时，全部对象都是白色的</li><li>GC Roots 直接引用的对象变成灰色</li><li>从灰色集合中获取元素：<ul><li>将本对象直接引用的对象标记为灰色</li><li>将本对象标记为黑色</li></ul></li><li>重复步骤3，直到灰色的对象集合变为空</li><li>结束后，仍然被标记为白色的对象就是不可达对象，视为垃圾对象</li></ol><p>对象在并发标记阶段会被漏标的充分必要条件是（同时满足以下两点）：</p><ul><li>Mutator 应用程序插入了一个从黑色对象到该白色对象的新引用</li><li>Mutator 应用程序删除了所有从灰色对象到该白色对象的直接或间接引用</li></ul><h1 id="G1GC-的堆结构"><a href="#G1GC-的堆结构" class="headerlink" title="G1GC 的堆结构"></a>G1GC 的堆结构</h1><p>G1GC 堆的内部被划分为大小相等的 <code>Region</code> ，G1GC 以 Region 为单位进行 GC ，Region 的大小 <code>RegionSize</code> 在 JVM 初始化时初始完毕且在当前 java 进程结束前不会改变。在 HotSpot 的源码中 <code>TARGET_REGION_NUMBER</code> 定义了 Region 的数量限制为 2048 个（实际上允许超过这个值）。一般 RegionSize 等于堆空间的总大小除以 2048 ，也可以用参数 -XX:G1HeapRegionSize 强制指定每个 Region 区的大小用户可以设置 Region 大小，但需要满足 RegionSize 是向上调整为 2 的指数幂，同时需要保证最小不小于 1MB ，最大不超过 32MB 。</p><p>比如目前的堆空间总大小为 8.5GB ，RegionSize 就是 8704MB&#x2F;2048 &#x3D; 4.25MB ，那么最终每个 Region 的大小为 8MB 。</p><p>在 G1 收集器中逻辑依旧是分代的，依旧存在年轻代 <code>Eden</code> 区、幸存区 <code>Survivor</code> 、老年代 <code>Old</code> 区，但在物理内存上是不分代的。G1 的每个代区由物理内存不连续的 Region 集合构成，这样做的好处在于：G1 可以优先回收垃圾对象特别多的 Region 区，这样可以花费较少的时间来回收垃圾，这也就是 G1 名字的由来，即垃圾优先收集器。<br>在运行时，G1 会将堆空间变为如下结构：</p><center><img src="/img/G1GC算法篇/G1堆.png" style="zoom:35%" title="分代 G1GC 堆空间划分" ><br>    <div style="color:orange;     color: #999;    padding: 2px;">分代 G1GC 堆空间划分    </div></center><p>新创建的对象都会被分配到 Eden 区，对象经过第一次 YGC 后，仍然存活的会被移到 Survivor 区，多次GC后依然存活的对象会被移动到 Old 区。图中除了提到的三个分区还多了大对象区 <code>Humongous</code> 与 <code>未分配区</code> 。在 G1 中当对象大小超过单个普通 Region 区的 50% 时，认定对象为大对象，大对象会直接将其放入 Humongous 区存储，当一个 Humongous 区存不下时，可能会横跨多个 Region 区存储它。在大多数时 Humongous 区会被当做老年代看待。</p><h1 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h1><p>通常 GC 算法在标记存活对象时，为了避免在标记过程中发生引用关系改变的情况，都需要让应用程序在安全点处停下，也就是常说的<code>Stop The World</code>简称 STW 。G1 在对老年代的标记过程中引入了并发标记，并发指的是与应用程序<code>mutator</code>并发执行。并发标记并不是直接在对象上添加标记，而是在<code>标记位图</code>上添加标记。</p><h2 id="标记位图"><a href="#标记位图" class="headerlink" title="标记位图"></a>标记位图</h2><p>下图表示堆中的一个 region ，位图中黑色表示已标记存活，白色表示未标记为存活。</p><center><img src="/img/G1GC算法篇/标记位图.png" style="zoom:45%" title="标记位图" ><br>    <div style="color:orange;     color: #999;    padding: 2px;">标记位图    </div></center><p>需要强调下，图中为了展示对应关系，将标记位图画得同 region 相对应，实际上标记位图每一格只有 1bit ，而 region 上一块为单个对象，标记位图中的每个 bit 都对应关联 region 内的对象的开头部分。假设单个对象的大小都是 8 个字节（本文后续都如此假定），那么每 8 个字节就会对应标记位图中的 1个bit 。图中标记位图里黑色的地方表示比特值是 1 ，白色的地方表示比特值是 0 。相应地，region 内黑色的是存活对象，带有叉号的是死亡对象。</p><p>每个region有两个标记位图：</p><ul><li><code>next</code>：本次标记的标记位图。</li><li><code>prev</code>：上次标记的标记位图，保存了上次并发标记的结果。</li></ul><p>图中region部分：</p><ul><li><code>bottom</code>：region 内众多对象的末尾</li><li><code>top</code>：region 内众多对象的开头（包括在并发标记过程中新分配的对象）</li><li><code>nextTAMS</code>：本次标记开始时的 top（TAMS-Top At Marking Start）（本次标记从 bottom 到此处）</li><li><code>prevTAMS</code>：上次标记开始时的 top</li></ul><p>并发标记结束主要针对的是 G1 老年代中 region 部分的标记，根据 G1 的清理策略，并不会对所有 region 做垃圾收集（会选择垃圾最多的几个 region 作清理）。所以保存上次标记结果 prev ，用于确定上次标记的存活对象在本次标记后是否能存活，而不扫描上次已经确定死亡的对象。</p><p>下列图展示对同一块 region 两次并发标记始末状态，用来说明 prev 标记位图和 next 标记位图的作用</p><center class = half><img src="/img/G1GC算法篇/第一次并发标记开始.png" height="143" title="第一次并发标记开始状态" ><img src="/img/G1GC算法篇/第一次并发标记结束.png" height="143" title="第一次并发标记结束状态" ><br>    <div style="color:orange; color: #999;padding: 2px;">    第一次并发标记开始状态&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第一次并发标记结束状态    </div></center><p>如上图所见，到第一次并发标记结束，标记了所有 bottom 到 nextTAMS 内所有存活对象</p><center class = half><img src="/img/G1GC算法篇/第二次并发标记开始.png" height="153" title="第二次并发标记开始状态" ><img src="/img/G1GC算法篇/第二次并发标记结束.png" height="153" title="第二次并发标记结束状态" ><br>    <div style="color:orange; color: #999;padding: 2px;">    第二次并发标记开始状态&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第二次并发标记结束状态    </div></center><p>等到新一轮并发标记开始时时，</p><ol><li>将 next 置为 prev ，并重置 next</li><li>对 Bottom 和 prevTAMS 之间的内存对象，根据 prev 标记的存活结果重新标记存活对象（ prev 中标记死亡的对象不扫描）</li><li>对 prevTAMS 和 NextTAMS 之间的内存对象进行存活标记</li><li>对 NextTAMS 和 top 之间的对象，都认为是存活对象，不在标记位图上作标记</li></ol><p>注：在下文展开并发标记算法逻辑时，为了简化理解，假定region上发生的是第一次并发标记，prev为空白（如上图）。</p><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><p>简单介绍单次并发标记的过程，具体标记细节，会在下文展开，一共分下列五个步骤</p><ol><li><strong>初始标记阶段</strong>：暂停应用程序 STW ，标记可由根直接引用的对象。</li><li><strong>并发标记阶段</strong>：与 mutator 并发进行，扫描 1 中标记的对象所引用的对象。</li><li><strong>最终标记阶段</strong>：暂停应用程序 STW ，扫描 2 中没有标记的对象。本步骤结束后，堆内所有存活对象都会被标记。</li><li><strong>存活对象计数</strong>：对每个 region 中被标记的对象进行计数，并发执行。</li><li><strong>收尾工作</strong>：暂停应用程序 STW ，收尾工作，并为下次标记做准备。</li></ol><h2 id="步骤-1——初始标记阶段"><a href="#步骤-1——初始标记阶段" class="headerlink" title="步骤 1——初始标记阶段"></a>步骤 1——初始标记阶段</h2><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0.png" alt="初始标记"></p><p>在初始标记阶段，GC 线程首先创建空白的标记位图 next。其中 nextTAMS 是本次标记开始时 top 所在的位置。单个对象假定8字节，位图的大小是 (top-botton)&#x2F;(8字节)。创建过程与 mutator 应用程序并发进行。</p><p>等所有待回收 region 的标记位图都完成创建后，暂停 mutator（ STW ）标记由根直接引用的对象（根扫描），目的是防止扫描过程中根被修改。按照三色标记算法，此时根直接引用的对象的引用还没被扫描，应该将根直接引用的对象标记为灰色，需要注意的是标记位图只能通过 0&#x2F;1 的 bit 位来标记对象是否存活，并不能标记灰色，真实的位图在初始标记结束时会将存活对象在位图上标为1，而如果表现标灰的操作会在下文 SATB 部分展开。</p><p>上图状态可以用如下java代码粗略演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Obj</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<br>C.ref1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aobj</span>();<br>C.ref2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Eobj</span>();<br><br><span class="hljs-type">Obj</span> <span class="hljs-variable">H</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<br>H.ref1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iobj</span>();<br></code></pre></td></tr></table></figure><p>根对象 C 、 H 分别持有子对象，根对象被标记为灰色，因为持有的子对象都没被标记（白色）</p><h2 id="步骤-2——并发标记阶段"><a href="#步骤-2——并发标记阶段" class="headerlink" title="步骤 2——并发标记阶段"></a>步骤 2——并发标记阶段</h2><p>在并发标记阶段，GC 线程与 mutator 并发进行，扫描在 1 阶段标记过的对象，完成对大部分存活对象的标记。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5.png" alt="并发标记阶段"></p><p>上图展示了并发标记的始末状态，对象 C 的子对象 A 和 E ，对象 H 的子对象 I 都被标记了。虽然 E 对应了标记位图中多个位，但是只有起始的标记位（mark bit）会被标记为 1 。</p><p>因为并发标记是和 mutator 应用程序并发执行，所以可能会向 region 区域内分配新的对象，上图中 J 和 K 即在并发标记阶段新分配的对象，记录在初始标记阶段记录的 nextTAMS 与当前 top 之间（ top 会随着分配对象而移动，指针碰撞），并不需要专门为新生成的对象创建标记位图（ J 、K 没有标记位图），这些新分配的对象（nextTAMS到top间的对象）会被当做存活对象，不在此次标记收集中处理。</p><p>同时因为是并发执行， mutator 可能会改变对象之间的引用关系，造成并发标记漏标。</p><h3 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h3><p>在三色标记算法的基本概念中给出了并发标记漏标的充分必要条件，此处通过例子展示漏标的情况：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E6%BC%8F%E6%A0%87.gif"></p><p>开始时，A 、C 、E 完成标记，H 由于是根直接引用的对象，在初始标记阶段标记为灰色，I 暂未被标记，然后 Mutator 执行下列代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//已知:H.ref1 = new Iobj();C.ref2 = new Eobj();</span><br>C.ref2.ref1 = H.ref1;<span class="hljs-comment">//添加引用E-&gt;I</span><br>H.ref1 = <span class="hljs-literal">null</span>;<span class="hljs-comment">//断开H-&gt;I </span><br></code></pre></td></tr></table></figure><p>如果不做任何处理，黑色对象 E 不会再次扫描 E 的引用，又由于断开了所有由灰色对象到对象 A 的引用，对象 A 无法被标记为存活，将在回收过程中被当作垃圾收集，造成漏标。</p><p>G1GC 使用<code>SATB（Snapshot At The Beginning）专用写屏障</code>算法，用于打破充要条件的第二点。即在断开由灰色对象到白色对象引用时，将白色对象变为灰色对象。具体的操作是在一个对象的 field 发生写操作时，这个对象 field 之前的值会被放入 SATB 本地队列。</p><p>SATB 专用写屏障的伪代码如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def satb_write_barrier(field, newobj):<br>    <span class="hljs-keyword">if</span> <span class="hljs-variable">$gc_phase</span> == GC_CONCURRENT_MARK:<br>        oldobj = <span class="hljs-number">*f</span>ield<br>        <span class="hljs-keyword">if</span> oldobj != <span class="hljs-literal">Null</span>:<br>            enqueue(<span class="hljs-variable">$current_thread</span>.stab_local_queue, oldobj)<br><br>        <span class="hljs-number">*f</span>ield = newobj<br></code></pre></td></tr></table></figure><p>参数 field 表示被写入对象的域，参数 newobj 表示被写入域的值。第 2 行的 GC_CONCURRENT_MARK 表示并发标记阶段的标志位（flag）用于检查当前是否处于并发标记阶段。第 4 行检查被写入之前field 域的值是不是 Null。如果检查通过，则在第 5 行将 oldobj 添加到 $current_thread.stab_local_queue 中。然后，在第 7 行进行实际的写入操作。</p><p>“初始标记阶段”一节中提到并不存在位图上将对象标记为灰色的操作，所谓的标记为灰色其实是，将对象对应的标记位图bit位设置为 1 的同时，将对象加入 SATB 队列。此处的队列是 mutator 各自持有的线程本地队列，SATB 本地队列在装满（默认大小为 1 KB）之后，会被添加到全局的 SATB 队列集合中，在并发标记阶段交给 GC 线程对队列中的全部对象进行扫描和标记。</p><p>回到刚刚的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//已知:H.ref1 = new Iobj();C.ref2 = new Eobj();</span><br>C.ref2.ref1 = H.ref1;<br><span class="hljs-comment">//C.ref2.ref1 在 region 图中为对象 E ，此处发生写操作会被写屏障函数感知</span><br><span class="hljs-comment">//首先判断 E.ref1 = null 所以可以直接将 H.ref1 即 对象 I 写入 E 的域</span><br>H.ref1 = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//H.ref1 在region图中为对象 I ，此处发生写操作会被写屏障函数感知</span><br><span class="hljs-comment">//由于 I 非空 需要先将对象 I 在位图上标记为存活，再将对象 I 加入待扫描的 SATB 队列</span><br></code></pre></td></tr></table></figure><p>不难发现，通过上述过程对象 I 并不会被漏标。</p><p>细心的读者会发现，如果不存在第一步将对象 I 写入 E 的域，单纯需要将对象 I 置为垃圾，那 SATB 写屏障的存在依旧会将对象 I 标记为存活造成错标，造成浮动垃圾，但是不影响程序的正确性。G1 使用的写屏障 + SATB 产生的浮动垃圾通常比 CMS 使用的写屏障 + 增量更新（ IU ）更多。</p><h2 id="步骤-3——最终标记阶段"><a href="#步骤-3——最终标记阶段" class="headerlink" title="步骤 3——最终标记阶段"></a>步骤 3——最终标记阶段</h2><p>在步骤 2 中介绍了被写屏障感知的对象会先加入 SATB 本地队列，只有当 SATB 本地队列装满之后才会被交给 GC 线程进行扫描和标记，而最终标记阶段则是暂停应用程序 mutator 扫描 SATB 本地队列存放的待扫描对象。本步骤结束后，所有的存活对象都已被标记，所有不带标记的对象都可以判定为死亡对象。</p><h2 id="步骤-4——存活对象计数"><a href="#步骤-4——存活对象计数" class="headerlink" title="步骤 4——存活对象计数"></a>步骤 4——存活对象计数</h2><p>扫描各个区域的标记位图 next，统计区域内存活对象的字节数，存到区域内的 next_marked_bytes 中。下图中存活对象 A、C、E、H 和 I，一共 5 个对象，其中 E 真实大小是 16 个字节，其余 5 个对象分别是 8 个字节，所以 next_marked_bytes 是 48 个字节。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E8%AE%A1%E6%95%B0.png" alt="存活对象计数结束后区域的状态"></p><p>在计数的过程中，又新创建了对象 L ，在 nextTAMS 和 top 之间的对象都被当做存活对象处理，但不会参与存活对象计数。</p><h2 id="步骤-5——收尾工作"><a href="#步骤-5——收尾工作" class="headerlink" title="步骤 5——收尾工作"></a>步骤 5——收尾工作</h2><p>收尾工作所操作的数据中有些是和应用程序共享的，所以需要暂停应用程序。</p><p>收尾阶段主要做了两件事情：</p><ul><li>GC 线程逐个扫描每个区域，将标记位图 next 的并发标记结果移动到标记位图 prev 中，再重置标记，为下次并发做准备。</li><li>在扫描过程中，<code>计算每个区域的转移效率</code>，并按照该效率对区域进行降序排序。</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309085124.png" alt="收尾工作完成后区域的状态"></p><p>上图中 prevTAMS 被移动到了 nextTAMS 原来的位置，表示“上次并发标记开始时 top 的位置”。next.next_marked_bytes 也会被重置，同时  nextTAMS 移动到 bottom 的位置，其会在下次并发标记开始时，移动到 top 的最新位置。</p><h2 id="转移效率"><a href="#转移效率" class="headerlink" title="转移效率"></a>转移效率</h2><p>指转移 1 个字节所需的时间。通俗理解就是，区域内死亡对象越多，存活对象就越少；而存活对象越少，那么转移所需的时间就越少。</p><p>计算公式为：死亡对象的字节数 &#x2F; 转移所需时间</p><h2 id="并发标记总结"><a href="#并发标记总结" class="headerlink" title="并发标记总结"></a>并发标记总结</h2><p>并发标记结束后，可以得到：</p><ul><li>并发标记完成时，<code>存活对象和死亡对象的区分</code>（此时在标记位图 prev）</li><li><code>存活对象的字节数</code>（prev_marked_bytes）</li></ul><p>如果新的对象是在并发标记结束后被创建的，因为新对象是分配在 prevTAMS 和 top 之间的，所以后被当成存活对象处理。</p><h1 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h1><h2 id="转移是什么？"><a href="#转移是什么？" class="headerlink" title="转移是什么？"></a>转移是什么？</h2><p>将所选区域内的所有存活对象都转移到空闲区域，因此被转移区域就只剩下死亡对象。重置之后，该区域就会成为空闲区域。</p><h2 id="转移专用记忆集合"><a href="#转移专用记忆集合" class="headerlink" title="转移专用记忆集合"></a>转移专用记忆集合</h2><p>上节介绍的<code>SATB 队列集合</code>是记录<code>标记过程中对象之间引用关系的变化</code>，这里的转移专用记忆集合记录<code>区域间的引用关系</code>，这样不用扫描所有区域的对象，也能查到待转移对象所占区域内的对象被其他区域引用的情况。</p><p>G1GC 是通过卡表（card table）来实现转移专用记忆集合的。</p><h3 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h3><p>是元素大小为 1B 的数组，堆中大小适当的一段存储空间（通常是 512B）对应卡表中的 1 个元素。在堆大小是 1GB 时，卡表大小为 2MB。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309091556.png" alt="卡表的构造"></p><p>堆中对象所对应的卡片在卡表的索引值 &#x3D; （对象的地址 - 堆的头部地址） &#x2F; 512</p><p>因为卡片的大小是 1B，所有可以表示很多状态，状态有很多，在后面只介绍两种：</p><ul><li>净卡片</li><li>脏卡片</li></ul><h3 id="转移专用记忆集合的构造"><a href="#转移专用记忆集合的构造" class="headerlink" title="转移专用记忆集合的构造"></a>转移专用记忆集合的构造</h3><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309092433.png" alt="转移专用记忆集合的构造"></p><p>每个区域都有一个转移专用记忆集合，是通过散列表实现的：</p><ul><li>键：引用本区域的其他区域的地址</li><li>值：数组，数组元素是<code>引用方的对象所对应的卡片索引</code></li></ul><p>在上图中，区域 B 中的对象 b 引用了区域 A 中的对象 a。因为对象 b 不是区域 A 中的对象，所以必须记录这个引用关系。在转移记忆集合 A 中，以区域 B 的地址为键记录了卡片的索引 2048（对象 b 对应的卡片索引），此时对象 b 对对象 a 的引用被准确记录了下来。</p><h2 id="转移专用写屏障"><a href="#转移专用写屏障" class="headerlink" title="转移专用写屏障"></a>转移专用写屏障</h2><p>那 GC 是如何感知域的变化呢？是通过<code>转移专用写屏障</code>，当对象修改时，会被转移专用写屏障记录到转移专用记忆集合中。</p><p>每个应用程序线程都持有一个<code>转移专用记忆集合日志</code>的缓冲区，其中存放的是卡片索引的数组。当对象 b 的域被修改时，写屏障就会感知，并会将对象 b 所对应的卡片索引添加到转移专用记忆集合日志中。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309093018.png" alt="转移专用记忆集合日志及其集合"></p><h2 id="转移专用记忆集合维护线程"><a href="#转移专用记忆集合维护线程" class="headerlink" title="转移专用记忆集合维护线程"></a>转移专用记忆集合维护线程</h2><p>是和应用程序并发执行的线程，是基于上述日志维护转移专用记忆集合。主要步骤：</p><ul><li>从转移专用记忆集合日志的集合中取出转移专用记忆集合日志，从头开始扫描</li><li>将卡片变为净卡片</li><li>检查卡片所对应存储空间内的所有对象的域</li><li>向域中地址所指向的区域的记忆集合中添加卡片</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309093506.png"></p><h2 id="热卡片"><a href="#热卡片" class="headerlink" title="热卡片"></a>热卡片</h2><p>频繁发生修改的存储空间所对应的卡片就是<code>热卡片</code>。热卡片可能会多次进入转移专用记忆集合日志，被多次处理成脏卡片，增加维护线程的负担。</p><p>可以通过卡片计数器，发现热卡片，当某个卡片变成脏卡片的次数超过阈值，可以等到转移的时候再处理。</p><h2 id="转移的执行步骤"><a href="#转移的执行步骤" class="headerlink" title="转移的执行步骤"></a>转移的执行步骤</h2><ul><li><code>选择回收集合</code>：参考并发标记提供的信息，选择要转移的区域。</li><li><code>根转移</code>：将回收集合内由根直接引用的对象，及被其他区域引用的对象转移到空闲区域中。</li><li><code>转移</code>：以根转移的对象为起点，扫描子孙对象，将所有存活对象一并转移。此时回收集合内所有存活对象都转移完成了。</li></ul><h2 id="步骤-1——选择回收集合"><a href="#步骤-1——选择回收集合" class="headerlink" title="步骤 1——选择回收集合"></a>步骤 1——选择回收集合</h2><p>选择待回收区域的标准：</p><ul><li>转移效率要高</li><li>转移的预测停顿时间在用户的容忍范围内</li></ul><p>在并发标记阶段结束时，堆中区域已经按照转移效率降序了。这里就是按照排好的顺序依次计算各个区域内的预测暂停时间，当所有已选区域预测的暂停时间和快要超过用户的容忍范围时，后续区域的选择就会停止，当前所选的区域就是 1 个回收集合。</p><h2 id="步骤-2——根转移"><a href="#步骤-2——根转移" class="headerlink" title="步骤 2——根转移"></a>步骤 2——根转移</h2><p>根转移的对象包括：</p><ul><li>由根直接引用的对象</li><li>并发标记处理中的对象</li><li>由其他区域对象直接引用的回收集合内的对象</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309094703.png" alt="对象转移"></p><ol><li>对象 a 转移到空闲区域。</li><li>对象 a 在空闲区域中的新地址写入到转移前所在区域中的旧位置。</li><li>将对象 a 引用的所有<code>位于回收集合内的对象</code>，都添加到转移队列中。转移队列临时保存<code>待转移对象的引用方</code>。因为对象 a 引用了对象 b，两个都是要转移的对象，地址都会变化。</li><li>针对对象 a 引用的<code>位于回收集合外的对象</code>，更新转移专用记忆集合。对象 c 所在区域不在回收集合内，但是区域 C 的转移专用记忆集合记录了 a 对应的卡片，在 a 转移之后，需要更新区域 C 的转移专用记忆集合。</li><li>针对<code>对象 a 的引用方</code>，更新转移专用记忆集合。</li></ol><h2 id="步骤-3——转移"><a href="#步骤-3——转移" class="headerlink" title="步骤 3——转移"></a>步骤 3——转移</h2><p>完成根转移后，被转移队列引用的对象会依次转移。当转移队列清空后，转移就完成了。此时回收集合内所有存活对象都转移完成了。</p><h1 id="分代-G1GC-模式"><a href="#分代-G1GC-模式" class="headerlink" title="分代 G1GC 模式"></a>分代 G1GC 模式</h1><p>G1GC 有 2 中模式：</p><ul><li><code>纯 G1GC 模式</code>：pure garbage-first mode</li><li><code>分代 G1GC 模式</code>：generational garbage-first mode</li></ul><p>本文上面讲的都是纯 G1GC 模式。</p><h2 id="两种-GC-的区别"><a href="#两种-GC-的区别" class="headerlink" title="两种 GC 的区别"></a>两种 GC 的区别</h2><p>和纯 G1GC 模式相比，分代 G1GC 模式主要有以下两个不同点。</p><ul><li>区域是分代的</li><li>回收集合的选择是分代的</li></ul><p>在分代 G1GC 模式中，区域被分为<code>新生代区域</code>和<code>老年代区域</code>两类。 和其他分代 GC 算法一样，分代 G1GC 的对象也保存了自身<code>在各次转移中存活下来的次数</code>。新生代区域用来存放新生代对象，老年代区域用来存放老年代对象。</p><p>G1GC 中新生代 GC 是<code>完全新生代 GC</code>，老年代 GC 是<code>部分新生代 GC</code>。二者区别在于完全新生代 GC 将所有新生代区域选入回收集合，而部分新生代 GC 将所有新生代区域，以及一部分老年代区域选入回收集合。</p><h2 id="新生代区域"><a href="#新生代区域" class="headerlink" title="新生代区域"></a>新生代区域</h2><p>新生代区域可以进一步分为两类：</p><ul><li>创建区域：存放刚刚生成，一次也没有转移过的对象</li><li>存活区域：存放至少转移过一次的对象</li></ul><p><em>转移专用写屏障不会应用在新生代区域的对象上</em>。为什么这样做是可以的呢？因为转移专用记忆集合维护的是<code>区域之间的引用关系</code>，所以在转移时不用扫描整个区域就能找到待转移对象所在区域的存活对象。而在分代 G1GC 模式中，所有新生代区域都会被选入回收集合，所有对象的引用都会被检查，这些信息就没有记录在转移专用记忆集合中了。</p><h2 id="分代对象转移"><a href="#分代对象转移" class="headerlink" title="分代对象转移"></a>分代对象转移</h2><p>存活对象保存了自己被转移的次数，这个次数就是<code>对象的年龄</code>。</p><ul><li>年龄&lt;阈值：转移到存活区域</li><li>年龄&gt;&#x3D;阈值：转移到老年代区域</li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309102101.png" alt="完全新生代 GC 的执行过程"></p><p>如上图，完全新生代 GC 不会选择老年代区域，而是将所有新生代区域都选入回收集合，然后统一转移回收集合的对象。晋升的对象会被转移到老年代区域，其余的转移到存活区域。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309102244.png" alt="部分新生代 GC 的执行过程"></p><p>如上图，部分新生代 GC 除了所有新生代区域外，还会选择一些老年代区域进入回收集合。其余都和完全新生代 GC 一样。</p><h2 id="GC-的切换"><a href="#GC-的切换" class="headerlink" title="GC 的切换"></a>GC 的切换</h2><p>如果新生代的区域数太多，可能导致 GC 暂停时间上限的增加，无法保证软实时性。分代 G1GC 模式需要计算出<code>合理的最大新生代区域</code>。该值的设置是在并发标记结束后。</p><p>参考并发标记中标记出的死亡对象个数，预测出下次部分新 生代 GC 的转移效率。然后，根据过去的完全新生代 GC 的转移效率， 预测出下次完全新生代 GC 的转移效率。如果预测出完全新生代 GC 的 转移效率更高，则切换为完全新生代 GC。</p><h2 id="GC-的执行时机"><a href="#GC-的执行时机" class="headerlink" title="GC 的执行时机"></a>GC 的执行时机</h2><p>当新生代区域数达到上限时，会触发转移的执行。，当转移完成并通过以下 4 项检查，会执行并发标记：</p><ul><li>不在并发标记执行过程中</li><li>并发标记的结果已被上次转移使用完</li><li>已经使用了一定量的堆内存</li><li>相比上次转移完成后，堆内存的使用量有所增加</li></ul><h1 id="G1-算法总结"><a href="#G1-算法总结" class="headerlink" title="G1 算法总结"></a>G1 算法总结</h1><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309103635.png"></p><p>图中并列的箭头表示可能会并行执行。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>软实时性</li><li>充分发挥高配置机器的性能，缩减 GC 暂停时间</li><li>区域内不会产生内存碎片</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>被限定为“搭载多核处理器、拥有大容量内存的机器”，适用受限。</li><li>尽管区域内不会出现碎片化，但是会出现以区域为单位（整个堆）的碎片化。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入 Java 虚拟机-JVM G1GC 的算法与实现》中村成洋&#x2F;著 吴炎昌 杨文轩&#x2F;译 1-6章<br>《深入探索JVM垃圾回收》彭成寒 4-6章<br><a href="https://zhuanlan.zhihu.com/p/463179141">关于 G1 GC 的一些研究</a><br><a href="https://www.redhat.com/en/blog/part-1-introduction-g1-garbage-collector">Part 1: Introduction to the G1 Garbage Collector</a><br><a href="https://www.redhat.com/en/blog/collecting-and-reading-g1-garbage-collector-logs-part-2?source=author&term=22991">Collecting and reading G1 garbage collector logs - part 2</a><br><a href="https://blog.csdn.net/weixin_45101064/article/details/123478022">(八)JVM成神路之GC分区篇：G1、ZGC、ShenandoahGC高性能收集器深入剖析</a> G1部分</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>G1GC算法篇</title>
    <link href="/2022/12/13/G1GC%E7%AE%97%E6%B3%95%E7%AF%87%20copy/"/>
    <url>/2022/12/13/G1GC%E7%AE%97%E6%B3%95%E7%AF%87%20copy/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>G1GC(Garbage First Garbage Collection)(简称G1)概念在04年的一篇论文就已经被提出，在JDK 6 Update 14 发布时推出了G1的测试版，并在其后经过不断地完善，最终在12年的 JDK7 Update 4正式发布，直到 JDK9 时被正式扶正，替代了原来的 Parallel Scavenge 和 Parallel Old的组合，成为Hotspot 在Server端的默认垃圾回收器。</p><p>本文将通过对G1的整个回收周期的算法原理进行解读，如有偏差，请指正。</p><h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><h2 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h2><p>程序具有实时性，是指程序必须能在最后期限（deadline）之前完成，其中最后期限可以自由指定。实时性分为两种：</p><ul><li><code>硬实时性</code>（hard real-time）：每次处理的时间都不能超过最后期限，比如医疗机器人控制系统、航空管制系统。</li><li><code>软实时性</code>（soft real-time）：稍微超出几次最后期限也没有什么问题的系统，例如网络银行系统。</li></ul><p>G1GC 具有软实时性，为了实现软实时性，必须具备以下功能：</p><ul><li>设置<code>期望暂停时间</code>（最后期限）</li><li><code>可预测性</code>：预测下次 GC 会导致应用程序暂停多长时间。根据预测出的结果，G1GC 会通过<code>延迟执行 GC</code>、<code>拆分 GC 目标对象</code>等手段来遵守上面设置的期望暂停时间。</li></ul><h2 id="G1GC-有什么特点？"><a href="#G1GC-有什么特点？" class="headerlink" title="G1GC 有什么特点？"></a>G1GC 有什么特点？</h2><p>Java 中已经有很多种 GC 算法了，为什么还要增加 G1GC 算法呢？</p><ul><li>以往的 GC 都是尽可能缩短最大暂停时间，但是缩短最大暂停时间很容易导致吞吐量下降。</li><li>以往的 GC 无法预测暂停时间，GC 时可能会使应用程序长时间暂停的风险。</li><li>G1GC 的目的就是高效地实现软实时性，能够让用户设置期望暂停时间。在确保吞吐量比以往的 GC 更好的前提下，实现了软实时性。</li><li>G1GC 能最大程度利用服务器上多处理器的优势，而且在处理巨大的堆时，也不会降低 GC 的性能。</li></ul><h1 id="G1GC-的堆结构是什么样的？"><a href="#G1GC-的堆结构是什么样的？" class="headerlink" title="G1GC 的堆结构是什么样的？"></a>G1GC 的堆结构是什么样的？</h1><p>G1GC 堆的内部被划分为大小相等的区域，所有区域排成一排。G1GC 以区域为单位进行 GC。用户可以随意设置区域大小，但是内部会将用户设置的值向上调整为 2 的指数幂，并以该正数作为区域的大小（如下图）。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210307224725.png" alt="图 1.1"></p><h1 id="G1GC-的执行过程是什么样的？"><a href="#G1GC-的执行过程是什么样的？" class="headerlink" title="G1GC 的执行过程是什么样的？"></a>G1GC 的执行过程是什么样的？</h1><ul><li><code>并发标记</code>（concurrent marking）：和应用程序并发执行，针对区域内所有的存活对象进行标记。</li><li><code>转移</code>（evacuation）：释放堆中死亡对象所占的内存空间。</li></ul><p>白色区域是空闲区域，灰色区域是使用中的区域。</p><ul><li>左图表示的是在选中区域后开始将存活对象复制到空闲区域的操作</li><li>右图表示的是转移后堆的状态。</li></ul><p>为了方便演示，图中的区域以二维的方式排列，但是在内存中其实如下图是排列成一排的。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210307225026.png"></p><h1 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h1><h2 id="并发标记是什么"><a href="#并发标记是什么" class="headerlink" title="并发标记是什么"></a>并发标记是什么</h2><p>简单标记，所有可从根直接触达的对象都会被添加标记。带标记的是存活对象，不带标记的是死亡对象。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308075521.png"></p><p>在并发标记中，存活对象的标记和应用程序几乎是并发进行的，步骤更加复杂。并发标记并不是直接在对象上添加标记，而是在<code>标记位图</code>上添加标记。</p><h2 id="标记位图"><a href="#标记位图" class="headerlink" title="标记位图"></a>标记位图</h2><p>下图表示堆中的一个区域，位图中黑色表示已标记，白色表示未标记。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308075725.png"></p><p>每个区域有两个标记位图：</p><ul><li><code>next</code>：本次标记的标记位图。</li><li><code>prev</code>：上次标记的标记位图，保存了上次标记的结果。</li></ul><p>标记位图中的每个比特都对应关联区域内的对象的开头部分。图中区域部分：</p><ul><li><code>bottom</code>：区域内众多对象的末尾</li><li><code>top</code>：区域中对象的开头</li><li><code>nextTAMS</code>：本次标记开始时的 top（TAMS-Top At Marking Start）</li><li><code>prevTAMS</code>：上次标记开始时的 top</li></ul><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol><li><code>初始标记阶段</code>：暂停应用程序，标记可由根直接引用的对象。</li><li><code>并发标记阶段</code>：与应用程序并发进行，扫描 1 中标记的对象所引用的对象。</li><li><code>最终标记阶段</code>：暂停应用程序，扫描 2 中没有标记的对象。本步骤结束后，堆内所有存活对象都会被标记。</li><li><code>存活对象计数</code>：对每个区域中被标记的对象进行计数，并发执行。</li><li><code>收尾工作</code>：暂停应用程序，收尾工作，并为下次标记做准备。</li></ol><h2 id="步骤-1——初始标记阶段"><a href="#步骤-1——初始标记阶段" class="headerlink" title="步骤 1——初始标记阶段"></a>步骤 1——初始标记阶段</h2><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308080825.png"></p><p>在初始标记阶段，GC 线程首先创建标记位图 next。其中 nextTAMS 是标记开始时，top 所在的位置。位图的大小也和 top 对齐，是 (top-botton)&#x2F;8 字节。</p><p>等所有区域的标记位图都创建完成后，标记由根直接引用的对象（根扫描）。此时是需要暂停应用程序的，这是为了防止扫描过程中根被修改。</p><p>如果一个对象本身被标记，但是子对象没有被扫描，我们称之为<code>未扫描对象</code>，上图用灰色标识，C 持有子对象 A 和 E，但是 A 和 E 并未被扫描。</p><h2 id="步骤-2——并发标记阶段"><a href="#步骤-2——并发标记阶段" class="headerlink" title="步骤 2——并发标记阶段"></a>步骤 2——并发标记阶段</h2><p>在并发标记阶段，GC 线程扫描在 1 阶段标记过的对象，完成对大部分存活对象的标记。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308082022.png"></p><p>上图表示并发标记结束的状态，对象 C 的子对象 A 和 E 都被标记了。E 对应了标记位图中多个位，只有起始的标记位（mark bit）会被涂成黑色。</p><p>因为并发标记是和应用程序并发执行的，所以在这个阶段可能会产生的对象，上图中 J 和 K 就是在并发标记期间新创建的对象，直接会被 GC 当成存活对象。</p><p>同时因为是并发执行，应用程序可能会改变了对象之间的引用关系，需要使用写屏障技术来记录对象间引用关系的变化。并发标记阶段也会标记和扫描被写屏障感知变化的对象。</p><h3 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h3><p>SATB（Snapshot At The Beginning，初始快照）是将并发标记阶段开始时对象间的引用关系，以逻辑快照的形式保存起来。标记过程中新生成的对象是“已完成扫描和标记”的，其子对象不会被标记。那如何区分是标记过程中新生成的对象呢？初始标记阶段记录的 nextTAMS 和 当前 top 之间的对象，所以并不需要专门为新生成的对象创建标记位图。</p><p>还有个很重要的问题，在并发标记过程中，对象的域发生了写操作怎么办？此时必须以某种方式记录被改写之前的引用关系。</p><p>G1GC 使用<code>SATB 专用写屏障</code>。在一个对象的域发生写操作时，这个对象会被放入 SATB 本地队列（SATB 本地队列满后，会被添加到全局的 SATB 队列结合）。在并发标记阶段，GC 线程会定期检查 SATB 队列集合的大小，对队列中的全部对象进行标记和扫描。如果获取到已经被标记的对象，这些对象不会再次被标记和扫描。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308085208.png"></p><h2 id="步骤-3——最终标记阶段"><a href="#步骤-3——最终标记阶段" class="headerlink" title="步骤 3——最终标记阶段"></a>步骤 3——最终标记阶段</h2><p>主要扫描 SATB 本地队列（队里里仍然存放了待扫描对象）。因为 SATB 本地队列会被应用程序操作，所以需要暂停应用程序。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308085617.png"></p><p>上图中 SATB 本地队列中还有对象 G 和 H 的引用，扫描后对象 G 和 H，以及对象 H 的子对象 I 都会变成黑色。</p><h2 id="步骤-4——存活对象计数"><a href="#步骤-4——存活对象计数" class="headerlink" title="步骤 4——存活对象计数"></a>步骤 4——存活对象计数</h2><p>扫描各个区域的标记位图 next，统计区域内存活对象的字节数，存到区域内的 next_marked_bytes 中。下图中存活对象 A、C、E、G、H 和 I，一共 6 个对象，其中 E 真实大小是 16 个字节，其余 5 个对象分别是 8 个字节，所以 next_marked_bytes 是 56 个字节。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210308090430.png" alt="存活对象计数结束后区域的状态"></p><p>在计数的过程中，又新创建了对象 L 和 M，nextTAMS 和 top 之间的对象都会被当做存活对象处理，没有特意进行计数。</p><h2 id="步骤-5——收尾工作"><a href="#步骤-5——收尾工作" class="headerlink" title="步骤 5——收尾工作"></a>步骤 5——收尾工作</h2><p>收尾工作所操作的数据中有些是和应用程序共享的，所以需要暂停应用程序。</p><p>收尾阶段主要做了两件事情：</p><ul><li>GC 线程逐个扫描每个区域，将标记位图 next 的并发标记结果移动到标记位图 prev 中，再重置标记，为下次并发做准备。</li><li>在扫描过程中，<code>计算每个区域的转移效率</code>，并按照该效率对区域进行降序排序。</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309085124.png" alt="收尾工作完成后区域的状态"></p><p>上图中 prevTAMS 被移动到了 nextTAMS 原来的位置，表示“上次并发标记开始时 top 的位置”。next.next_marked_bytes 也会被重置，同时  nextTAMS 移动到 bottom 的位置，其会在下次并发标记开始时，移动到 top 的最新位置。</p><h2 id="转移效率"><a href="#转移效率" class="headerlink" title="转移效率"></a>转移效率</h2><p>指转移 1 个字节所需的时间。通俗理解就是，区域内死亡对象越多，存活对象就越少；而存活对象越少，那么转移所需的时间就越少。</p><p>计算公式为：死亡对象的字节数 &#x2F; 转移所需时间</p><h2 id="并发标记总结"><a href="#并发标记总结" class="headerlink" title="并发标记总结"></a>并发标记总结</h2><p>并发标记结束后，可以得到：</p><ul><li>并发标记完成时，<code>存活对象和死亡对象的区分</code>（此时在标记位图 prev）</li><li><code>存活对象的字节数</code>（prev_marked_bytes）</li></ul><p>如果新的对象是在并发标记结束后被创建的，因为新对象是分配在 prevTAMS 和 top 之间的，所以后被当成存活对象处理。</p><h1 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h1><h2 id="转移是什么？"><a href="#转移是什么？" class="headerlink" title="转移是什么？"></a>转移是什么？</h2><p>将所选区域内的所有存活对象都转移到空闲区域，因此被转移区域就只剩下死亡对象。重置之后，该区域就会成为空闲区域。</p><h2 id="转移专用记忆集合"><a href="#转移专用记忆集合" class="headerlink" title="转移专用记忆集合"></a>转移专用记忆集合</h2><p>上节介绍的<code>SATB 队列集合</code>是记录<code>标记过程中对象之间引用关系的变化</code>，这里的转移专用记忆集合记录<code>区域间的引用关系</code>，这样不用扫描所有区域的对象，也能查到待转移对象所占区域内的对象被其他区域引用的情况。</p><p>G1GC 是通过卡表（card table）来实现转移专用记忆集合的。</p><h3 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h3><p>是元素大小为 1B 的数组，堆中大小适当的一段存储空间（通常是 512B）对应卡表中的 1 个元素。在堆大小是 1GB 时，卡表大小为 2MB。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309091556.png" alt="卡表的构造"></p><p>堆中对象所对应的卡片在卡表的索引值 &#x3D; （对象的地址 - 堆的头部地址） &#x2F; 512</p><p>因为卡片的大小是 1B，所有可以表示很多状态，状态有很多，在后面只介绍两种：</p><ul><li>净卡片</li><li>脏卡片</li></ul><h3 id="转移专用记忆集合的构造"><a href="#转移专用记忆集合的构造" class="headerlink" title="转移专用记忆集合的构造"></a>转移专用记忆集合的构造</h3><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309092433.png" alt="转移专用记忆集合的构造"></p><p>每个区域都有一个转移专用记忆集合，是通过散列表实现的：</p><ul><li>键：引用本区域的其他区域的地址</li><li>值：数组，数组元素是<code>引用方的对象所对应的卡片索引</code></li></ul><p>在上图中，区域 B 中的对象 b 引用了区域 A 中的对象 a。因为对象 b 不是区域 A 中的对象，所以必须记录这个引用关系。在转移记忆集合 A 中，以区域 B 的地址为键记录了卡片的索引 2048（对象 b 对应的卡片索引），此时对象 b 对对象 a 的引用被准确记录了下来。</p><h2 id="转移专用写屏障"><a href="#转移专用写屏障" class="headerlink" title="转移专用写屏障"></a>转移专用写屏障</h2><p>那 GC 是如何感知域的变化呢？是通过<code>转移专用写屏障</code>，当对象修改时，会被转移专用写屏障记录到转移专用记忆集合中。</p><p>每个应用程序线程都持有一个<code>转移专用记忆集合日志</code>的缓冲区，其中存放的是卡片索引的数组。当对象 b 的域被修改时，写屏障就会感知，并会将对象 b 所对应的卡片索引添加到转移专用记忆集合日志中。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309093018.png" alt="转移专用记忆集合日志及其集合"></p><h2 id="转移专用记忆集合维护线程"><a href="#转移专用记忆集合维护线程" class="headerlink" title="转移专用记忆集合维护线程"></a>转移专用记忆集合维护线程</h2><p>是和应用程序并发执行的线程，是基于上述日志维护转移专用记忆集合。主要步骤：</p><ul><li>从转移专用记忆集合日志的集合中取出转移专用记忆集合日志，从头开始扫描</li><li>将卡片变为净卡片</li><li>检查卡片所对应存储空间内的所有对象的域</li><li>向域中地址所指向的区域的记忆集合中添加卡片</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309093506.png"></p><h2 id="热卡片"><a href="#热卡片" class="headerlink" title="热卡片"></a>热卡片</h2><p>频繁发生修改的存储空间所对应的卡片就是<code>热卡片</code>。热卡片可能会多次进入转移专用记忆集合日志，被多次处理成脏卡片，增加维护线程的负担。</p><p>可以通过卡片计数器，发现热卡片，当某个卡片变成脏卡片的次数超过阈值，可以等到转移的时候再处理。</p><h2 id="转移的执行步骤"><a href="#转移的执行步骤" class="headerlink" title="转移的执行步骤"></a>转移的执行步骤</h2><ul><li><code>选择回收集合</code>：参考并发标记提供的信息，选择要转移的区域。</li><li><code>根转移</code>：将回收集合内由根直接引用的对象，及被其他区域引用的对象转移到空闲区域中。</li><li><code>转移</code>：以根转移的对象为起点，扫描子孙对象，将所有存活对象一并转移。此时回收集合内所有存活对象都转移完成了。</li></ul><h2 id="步骤-1——选择回收集合"><a href="#步骤-1——选择回收集合" class="headerlink" title="步骤 1——选择回收集合"></a>步骤 1——选择回收集合</h2><p>选择待回收区域的标准：</p><ul><li>转移效率要高</li><li>转移的预测停顿时间在用户的容忍范围内</li></ul><p>在并发标记阶段结束时，堆中区域已经按照转移效率降序了。这里就是按照排好的顺序依次计算各个区域内的预测暂停时间，当所有已选区域预测的暂停时间和快要超过用户的容忍范围时，后续区域的选择就会停止，当前所选的区域就是 1 个回收集合。</p><h2 id="步骤-2——根转移"><a href="#步骤-2——根转移" class="headerlink" title="步骤 2——根转移"></a>步骤 2——根转移</h2><p>根转移的对象包括：</p><ul><li>由根直接引用的对象</li><li>并发标记处理中的对象</li><li>由其他区域对象直接引用的回收集合内的对象</li></ul><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309094703.png" alt="对象转移"></p><ol><li>对象 a 转移到空闲区域。</li><li>对象 a 在空闲区域中的新地址写入到转移前所在区域中的旧位置。</li><li>将对象 a 引用的所有<code>位于回收集合内的对象</code>，都添加到转移队列中。转移队列临时保存<code>待转移对象的引用方</code>。因为对象 a 引用了对象 b，两个都是要转移的对象，地址都会变化。</li><li>针对对象 a 引用的<code>位于回收集合外的对象</code>，更新转移专用记忆集合。对象 c 所在区域不在回收集合内，但是区域 C 的转移专用记忆集合记录了 a 对应的卡片，在 a 转移之后，需要更新区域 C 的转移专用记忆集合。</li><li>针对<code>对象 a 的引用方</code>，更新转移专用记忆集合。</li></ol><h2 id="步骤-3——转移"><a href="#步骤-3——转移" class="headerlink" title="步骤 3——转移"></a>步骤 3——转移</h2><p>完成根转移后，被转移队列引用的对象会依次转移。当转移队列清空后，转移就完成了。此时回收集合内所有存活对象都转移完成了。</p><h1 id="分代-G1GC-模式"><a href="#分代-G1GC-模式" class="headerlink" title="分代 G1GC 模式"></a>分代 G1GC 模式</h1><p>G1GC 有 2 中模式：</p><ul><li><code>纯 G1GC 模式</code>：pure garbage-first mode</li><li><code>分代 G1GC 模式</code>：generational garbage-first mode</li></ul><p>本文上面讲的都是纯 G1GC 模式。</p><h2 id="两种-GC-的区别"><a href="#两种-GC-的区别" class="headerlink" title="两种 GC 的区别"></a>两种 GC 的区别</h2><p>和纯 G1GC 模式相比，分代 G1GC 模式主要有以下两个不同点。</p><ul><li>区域是分代的</li><li>回收集合的选择是分代的</li></ul><p>在分代 G1GC 模式中，区域被分为<code>新生代区域</code>和<code>老年代区域</code>两类。 和其他分代 GC 算法一样，分代 G1GC 的对象也保存了自身<code>在各次转移中存活下来的次数</code>。新生代区域用来存放新生代对象，老年代区域用来存放老年代对象。</p><p>G1GC 中新生代 GC 是<code>完全新生代 GC</code>，老年代 GC 是<code>部分新生代 GC</code>。二者区别在于完全新生代 GC 将所有新生代区域选入回收集合，而部分新生代 GC 将所有新生代区域，以及一部分老年代区域选入回收集合。</p><h2 id="新生代区域"><a href="#新生代区域" class="headerlink" title="新生代区域"></a>新生代区域</h2><p>新生代区域可以进一步分为两类：</p><ul><li>创建区域：存放刚刚生成，一次也没有转移过的对象</li><li>存活区域：存放至少转移过一次的对象</li></ul><p><em>转移专用写屏障不会应用在新生代区域的对象上</em>。为什么这样做是可以的呢？因为转移专用记忆集合维护的是<code>区域之间的引用关系</code>，所以在转移时不用扫描整个区域就能找到待转移对象所在区域的存活对象。而在分代 G1GC 模式中，所有新生代区域都会被选入回收集合，所有对象的引用都会被检查，这些信息就没有记录在转移专用记忆集合中了。</p><h2 id="分代对象转移"><a href="#分代对象转移" class="headerlink" title="分代对象转移"></a>分代对象转移</h2><p>存活对象保存了自己被转移的次数，这个次数就是<code>对象的年龄</code>。</p><ul><li>年龄&lt;阈值：转移到存活区域</li><li>年龄&gt;&#x3D;阈值：转移到老年代区域</li></ul><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309102101.png" alt="完全新生代 GC 的执行过程"></p><p>如上图，完全新生代 GC 不会选择老年代区域，而是将所有新生代区域都选入回收集合，然后统一转移回收集合的对象。晋升的对象会被转移到老年代区域，其余的转移到存活区域。</p><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309102244.png" alt="部分新生代 GC 的执行过程"></p><p>如上图，部分新生代 GC 除了所有新生代区域外，还会选择一些老年代区域进入回收集合。其余都和完全新生代 GC 一样。</p><h2 id="GC-的切换"><a href="#GC-的切换" class="headerlink" title="GC 的切换"></a>GC 的切换</h2><p>如果新生代的区域数太多，可能导致 GC 暂停时间上限的增加，无法保证软实时性。分代 G1GC 模式需要计算出<code>合理的最大新生代区域</code>。该值的设置是在并发标记结束后。</p><p>参考并发标记中标记出的死亡对象个数，预测出下次部分新 生代 GC 的转移效率。然后，根据过去的完全新生代 GC 的转移效率， 预测出下次完全新生代 GC 的转移效率。如果预测出完全新生代 GC 的 转移效率更高，则切换为完全新生代 GC。</p><h2 id="GC-的执行时机"><a href="#GC-的执行时机" class="headerlink" title="GC 的执行时机"></a>GC 的执行时机</h2><p>当新生代区域数达到上限时，会触发转移的执行。，当转移完成并通过以下 4 项检查，会执行并发标记：</p><ul><li>不在并发标记执行过程中</li><li>并发标记的结果已被上次转移使用完</li><li>已经使用了一定量的堆内存</li><li>相比上次转移完成后，堆内存的使用量有所增加</li></ul><h1 id="G1-算法总结"><a href="#G1-算法总结" class="headerlink" title="G1 算法总结"></a>G1 算法总结</h1><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="http://yano.oss-cn-beijing.aliyuncs.com/blog/20210309103635.png"></p><p>图中并列的箭头表示可能会并行执行。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>软实时性</li><li>充分发挥高配置机器的性能，缩减 GC 暂停时间</li><li>区域内不会产生内存碎片</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>被限定为“搭载多核处理器、拥有大容量内存的机器”，适用受限。</li><li>尽管区域内不会出现碎片化，但是会出现以区域为单位（整个堆）的碎片化。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入 Java 虚拟机-JVM G1GC 的算法与实现》中村成洋&#x2F;著 吴炎昌 杨文轩&#x2F;译 1-6章<br>《深入探索JVM垃圾回收》彭成寒 4-6章<br><a href="https://zhuanlan.zhihu.com/p/463179141">关于 G1 GC 的一些研究</a><br><a href="https://www.redhat.com/en/blog/part-1-introduction-g1-garbage-collector">Part 1: Introduction to the G1 Garbage Collector</a><br><a href="https://www.redhat.com/en/blog/collecting-and-reading-g1-garbage-collector-logs-part-2?source=author&term=22991">Collecting and reading G1 garbage collector logs - part 2</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
