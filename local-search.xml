<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UseMembar?</title>
    <link href="/2023/06/07/UseMembar/"/>
    <url>/2023/06/07/UseMembar/</url>
    
    <content type="html"><![CDATA[<p>这一篇文章的切入口是 JVM 中的 UseMembar 参数，并依此聊一聊对 Store Buffer 的粗浅理解，如有不当之处欢迎指正。</p><span id="more"></span><p><strong>注：读者最好提前了解了<code>缓存一致性协议</code>的相关知识</strong></p><h1 id="写屏障的概念"><a href="#写屏障的概念" class="headerlink" title="写屏障的概念"></a>写屏障的概念</h1><p>这里回顾一下 <code>MESI协议</code><br>MESI 是四个单词的缩写，每个单词分别代表缓存行的一个状态：</p><ul><li>M：modified，已修改。缓存行与主存的值不同。如果别的 CPU 内核要读主存这块数据，该缓存行必须回写到主存，状态变为共享状态（S）。</li><li>E：exclusive，独占的。缓存行只在当前缓存中，但和主存数据一致。当别的缓存读取它时，状态变为共享；当前写数据时，变为已修改状态（M）。</li><li>S：shared，共享的。缓存行也存在于其它缓存中且是干净的。缓存行可以在任意时刻抛弃。</li><li>I：invalid，无效的。缓存行是无效的。</li></ul><p>当 CPU0 发生<code>Store</code>操作时，如果这个数据不在私有缓存里，那么 CPU0 就会发送一个 Read + Invalidate 消息去读取对应的数据，并让其他的缓存副本失效。其他 CPU 收到 Invalidate 消息 完成对应缓存副本的失效操作后，其他 CPU 向 CPU0 发送 Invalidate Acknowledge 信息。等 CPU0 收到所有其他 CPU 响应的 Invalidate Acknowledge 信息后，再将数据写入 CPU0 的缓存。CPU0 等待其他 CPU 响应的 Invalidate Acknowledge 信息，这段时间是一种浪费。</p><p>为了减少这种等待，就引入了 Store Buffer，结构如下图：</p><p><img src="/img/UseMembar/storebuffer.png" alt="Store Buffer"></p><p>引入了 Store Buffer 确实能够解决一部分等待时间长的问题，但是也破坏了内存的一致性，考虑这个经典的案例（忽略 cache 与 内存的交互过程）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// CPU0 执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; <br>    a = <span class="hljs-number">1</span>;<br>    b = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// CPU1 执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">assert</span>(a == <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>假设：CPU0 只缓存了 b，因为是独占，所以状态是 E。CPU1 只缓存了 a，同样是独占状态 E。</p><ol><li>CPU0 执行 a&#x3D;1，因为 a 不在 CPU0 的 cache 中，有 store buffer 的存在，直接写将 a&#x3D;1 写到 store buffer，同时发送一个 read invalidate 消息。<br>（此时状态：CPU0 认为完成了 a&#x3D;1，可以进行 b&#x3D;1 操作）</li><li>CPU0 执行 b&#x3D;1，因为 b 在 CPU0 的 cache 中，且状态为独占 E，直接将 b 的 cache 行设置为已修改 M，并将新值写入 cache<br>（此时状态：invalidate 消息还没有被传到 CPU1，CPU1 的 cache 中 a 的值依旧为 0；自然也没有回传 Invalidate Acknowledge 信息，a 的新值 1 依旧在 CPU0 的 store buffer 中）</li><li>CPU1 执行 while(b&#x3D;&#x3D;1)，因为 b 不在 CPU1 的缓存中，所以 CPU1 发送一个 read 消息去读。</li><li>CPU0 收到 CPU1 的 read 消息，知道 CPU1 想要读 b，于是返回一个 read response 消息，同时将对应缓存行的状态改成 S。</li><li>CPU1 收到 read response 消息，知道 b&#x3D;1，于是将 b&#x3D;1 放到缓存，同时结束 while 循环。</li><li>CPU1 执行 assert(a&#x3D;&#x3D;1)，从 CPU1 的 cache 看 CPU1 独占 a ，直接拿到 a&#x3D;0，assert 失败。</li></ol><p>指令乱序的简化理解：从 CPU0 的角度 a&#x3D;1 先于 b&#x3D;1；从 CPU1 的角度看 CPU0 b&#x3D;1 先于 a&#x3D;1。<br>为了消除这种乱序问题，硬件设计师为软件开发者提供了写屏障 smp_wmb()，写屏障的直观目的是为了保障 a&#x3D;1 写入cache 之后才能将 b&#x3D;1 写入 cache。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// CPU0 执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; <br>    a = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">smp_wmb</span>();<br>    b = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述方式能规避指令乱序带来的问题。</p><h1 id="UseMembar-应用场景"><a href="#UseMembar-应用场景" class="headerlink" title="UseMembar 应用场景"></a>UseMembar 应用场景</h1><p>为什么会讲到这个小例子，因为 Hotspot 中 UseMembar 的应用场景和小例子很相似。假设平台单核单线程，存在如下情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//CPU0</span><br>Thread <span class="hljs-number">0</span> :<br>    <span class="hljs-built_in">Java</span>()  <span class="hljs-comment">// Thread _state = _thread_in_Java</span><br>    <span class="hljs-built_in">J2N</span>()   <span class="hljs-comment">//_thread_in_Java -&gt; _thread_in_native</span><br>    <span class="hljs-built_in">Native</span>()<span class="hljs-comment">// Thread _state = _thread_in_native</span><br><br><span class="hljs-comment">//CPU1</span><br>Thread <span class="hljs-number">1</span> :<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(Thread0-&gt;_state == _thread_in_native)<br>            <span class="hljs-built_in">assert</span>(Thread <span class="hljs-number">0</span> is <span class="hljs-keyword">not</span> running <span class="hljs-built_in">Java</span>())<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">assert</span>(Thread <span class="hljs-number">0</span> is <span class="hljs-keyword">not</span> running <span class="hljs-built_in">Native</span>())<br>    &#125;<br></code></pre></td></tr></table></figure><p>很显然，这种情况与上一节的小例子几乎可以说一模一样。那么也会出现相似的乱序问题，也可以通过添加内存写屏障的方式来避免，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//CPU0</span><br>Thread <span class="hljs-number">0</span> :<br>    <span class="hljs-built_in">Java</span>()<br>    <span class="hljs-built_in">J2N</span>()   <span class="hljs-comment">// Thread _state = _thread_in_native</span><br>            <span class="hljs-comment">// smp_wmb();</span><br>    <span class="hljs-built_in">Native</span>()<br></code></pre></td></tr></table></figure><p>这种情况就是 UseMembar 开启的情况</p><h1 id="伪内存屏障"><a href="#伪内存屏障" class="headerlink" title="伪内存屏障"></a>伪内存屏障</h1><p>很显然当 Thread 0 高频次交替运行 Java 方法和 Native 方法，而 Thread 1 仅少量次数调用 bar() 方法时，写内存屏障的存在就只能带来性能上的损耗，回到开头的小例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// CPU0 执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; <br>    a = <span class="hljs-number">1</span>;<br>    b = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// CPU1 执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">assert</span>(a == <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>考虑第二种处理方式（对应-XX:-UseMembar），我们是不是可以考虑不添加写屏障，变为只在 assert(a &#x3D;&#x3D; 1) 之前，保证所有其他 CPU 接受到 Invalidate 消息，这样也能保证正确性。实际上 CPU1 并不知道有没有没收到的 Invalidate 消息，那么索性将要读的值 a 置为 invalid 状态，但这又引来了新问题，需要保证所有 store buffer 中的 a 的值刷到内存上。即变为如下情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> b = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// CPU0 执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; <br>    a = <span class="hljs-number">1</span>;<br>    b = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// CPU1 执行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(b == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-comment">//使 a 在 cache 中状态变为 invalid，且将所有 CPU store buffer 中 a 的值刷入内存</span><br>    <span class="hljs-built_in">serialize_thread_states</span>();<br>    <span class="hljs-built_in">assert</span>(a == <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的 serialize_thread_states() 函数的函数名延用了 Hotspot 中的名字，实现的效果是将 a 在 cache 中状态变为 invalid。我们来看看 Hotspot 中的实现逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 前提 a 存在指定内存页 P 上</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">serialize_thread_states</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-number">1.</span> 当前线程获取内存页 P 的锁<br>  <span class="hljs-number">2.</span> 将内存页 P 的权限变为 只读<br>  <span class="hljs-number">3.</span> 将内存页 P 的权限变回 写读<br>  <span class="hljs-number">4.</span> 当前线程释放内存页 P 的锁<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Hotspot 中将提供上述四步完成，步骤 1 和 4 将内存页 P 上锁，避免在修改权限时有新的数据写入；步骤 2 完成将 store buffer 中信息刷入 cache 的操作；步骤 3 单纯将权限修改回写读。其中，改变内存页权限的函数为内核函数 mprotect。mprotect 函数的解析可以参考<a href="#references">《mprotect do memory barrier on SMP》</a></p><p>mprotect 的本意是用来更改 Page 的属性 - 读、写、执行等页属性。它有一个副作用，就是更改页属性后，OS 会向各 CPU 发送 IPI 中断来失效处理器的 TLB (Translation Lookaside Buffer) 和 cache-line ，并为每个 CPU 添加 write memory barrier ，保证 Page 属性修改前对应页的本地 store buffer 刷新到内存。</p><p>从处理上不难看出，伪内存屏障的处理更加损耗性能，那为什么还要提出这种处理方式呢，原因就在于方法调用的频次。当CPU0 调用 foo 方法的次数非常多时，伪内存屏障优化就会出现反效果。</p><h1 id="UseMembar-如何选择"><a href="#UseMembar-如何选择" class="headerlink" title="UseMembar 如何选择"></a>UseMembar 如何选择</h1><p>如何选择是否开启 UseMembar 选项，一方面需要考虑 Hotspot 运行的平台上内存屏障的性能损耗（可能出现使用内存屏障性能损耗非常小，不构成性能瓶颈的情况）。另一方面需要判断伪内存屏障被调用频次多不多的问题，考虑如下两种情况。</p><p>情况1：安全点</p><p>正常需要进入安全点时，会将<code>safepoint _state（_synchronizing）</code>写入某处，然后所有可以进入安全点的线程会去同一个地方读取标志，来实现进入<code>Safepoint</code>的操作。但是需要注意，如果线程的状态是<code> _thread_in_native</code>即线程处运行在<code>native code</code>时，不需要等待该线程的阻塞，如果由于写读乱序导致了意外的STW，不会影响正确性。但是当<code>native</code>方法退出时，需要将线程的状态设置为<code> _thread_in_native_trans</code>，这一步必须在<code>Safepoint</code>开始之前完成，否则会出错！！</p><p>所以将<code>_thread_in_native_trans</code>状态写入线程状态的操作与将<code>_synchronizing</code>状态写入内存的操作<strong>顺序</strong>需要保证在多核（is_MP）运行情况下一致！！</p><p>此时有两种实现方式</p><ol><li>在写入<code> _thread_in_native_trans</code>状态之后添加内存写屏障，保证写入正确（-XX:+UseMembar）</li><li>将<code> _thread_in_native_trans</code>状态写入<code>serialize_page</code>页，通过改变<code>serialize_page</code>页写读权限<br>（伪内存屏障-XX:-UseMembar）</li></ol><p>考虑到进 safepoint 的频次要小于 Native Java 方法切换的频次，可以考虑使用伪内存屏障（-XX:-UseMembar）</p><p>情况2：JFR Method Profiling</p><p>JFR 的 方法采样事件分为 <code>Java 方法采样</code>与<code>Native 方法采样</code>，在暂停线程之前需要判断被采样线程的线程状态，也需要保证<code>_thread_in_native_trans</code>状态已经写入线程状态。如果是 -XX:-UseMembar 状态则也会在判断前调用伪内存屏障，考虑到方法采样的频次会很高，这时候频繁调用伪内存屏障就成了 JFR 给应用程序带来的性能损耗的主要部分。所以，此时应该考虑使用物理屏障（-XX:+UseMembar）。</p><p id="references"></p>    <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/Soul_wh/article/details/125318641">《关于缓存一致性协议、MESI、StoreBuffer、InvalidateQueue、内存屏障、Lock指令和JMM的那点事》</a><br><a href="https://blog.csdn.net/sunboylife/article/details/125247619">《内存屏障今生之Store Buffer, Invalid Queue》</a><br><a href="https://zhuanlan.zhihu.com/p/65760539">《mprotect do memory barrier on SMP》</a><br>[《Adventures with Memory Barriers and Seastar on Linux》]</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hotspot</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JFR MethodProfiling</title>
    <link href="/2023/06/05/JFR-MethodProfiling/"/>
    <url>/2023/06/05/JFR-MethodProfiling/</url>
    
    <content type="html"><![CDATA[<h1 id="JFR-MethodProfiling-Event-简介"><a href="#JFR-MethodProfiling-Event-简介" class="headerlink" title="JFR MethodProfiling Event 简介"></a>JFR MethodProfiling Event 简介</h1><p>JMC 的 “方法分析” 页用于查看特定方法的运行频率以及运行方法所需的时间。可以帮助用户通过识别执行时间过长的方法来确定方法瓶颈。<span id="more"></span></p><p>方法分析页面如下：</p><p><img src="/img/JFRMethodProfiling/JMCmp.png" alt="Method Profiling 页面"></p><p>页面中能提供的信息包括：</p><ul><li>根据采样信息 JMC 分析得出的热点方法堆栈（红框）</li><li>被采样到的正在运行的方法，及方法计数（黄色箭头）</li><li>通过点击被采样到的方法，查看调用该方法的堆栈（黄色方框）</li></ul><p>细心的读者估计可以发现，JMC 分析得出的热点方法与采样次数最多的方法并不一致。那是因为 JMC 分析的依据是所有方法，包括堆栈内的方法。</p><p>方法分析页面的数据来源是 JFR 记录的 ExecutionSample 事件信息与 NativeMethodSample 事件信息。通过 JFR 进行方法采样分析与通过 perf 采样分析，两者存在如下区别：</p><ul><li>采样原理不同，perf 基于内核，JFR 基于 Hotspot</li><li>采样过程不同</li></ul><p>perf的原理过程可以参考网上资料，本文主要分析 JFR ExecutionSample 事件的采样逻辑</p><h1 id="JFR-MethodProfiling-Event-采样算法文字描述"><a href="#JFR-MethodProfiling-Event-采样算法文字描述" class="headerlink" title="JFR MethodProfiling Event 采样算法文字描述"></a>JFR MethodProfiling Event 采样算法文字描述</h1><ol><li>JFR 线程为 JFR 方法采样线程的对象设置采样间隔时间参数，并启动 JFR 采样线程（下文简称采样线程）。JFR 线程通过加减信号量（semaphore）_sample 的方式开关方法采样。</li><li>采样线程获取当前时间，初始化<code>上次采样结束的时间</code></li><li>采样线程调用 sem_wait 尝试将信号量 _sample 减去 1  (初始由 JFR 线程将信号量 _sample + 1 -&gt; 1)</li></ol><ul><li>3.1 大于 0 _sample 成功被减去 1，转到 4 (采样线程获得锁可运行)</li><li>3.2 小于等于 0  阻塞当前线程直到 JFR线程 将 _sample 设置为大于0</li></ul><ol start="4"><li>采样线程对信号量 _sample + 1 ，根据<code>上次采样结束的时间</code> + <code>设置的间隔时间</code> &#x3D; <code>下次采样的时间</code>，计算出下次预计的采样时间</li><li>采样线程判断 <code>下次采样的时间</code> 是否大于 <code>当前时间</code>（通过 clock_gettime 获得）</li></ol><ul><li>5.1 <code>下次采样的时间</code> 大于 <code>当前时间</code>说明还不到预计的采样时间，不能开始采样，sleep 一段时间。<code>睡眠时间</code> &#x3D; <code>下次采样的时间</code> - <code>当前时间</code></li><li>5.2 <code>下次采样的时间</code> 小于 <code>当前时间</code>说明已经过了预计的采样时间可以开始采样了</li></ul><ol start="6"><li>采样线程根据上次被采样的线程 lT（初始为 Null ），对往后固定个数(Java 5 Native 1)个 Java 线程进行采样</li></ol><ul><li>6.1 采样线程将采样成功计数置为 0，将 Threads table 上锁，并获取 <code>JVM 线程列表</code>。</li><li>6.2 采样线程 根据 上一次被采样的线程 lT ，找到<code> JVM 线程列表</code>中下一个线程 t（如果上次遍历完列表 或 这是第一次遍历，则从列表第一个线程开始），并将 lT 设置为 t</li><li>6.3 如果线程 t 非空也非编译线程，则转到 6.4 尝试对该线程进行采样，否则转回到 6.2 继续寻找下一个被采样线程</li><li>6.4 （通过线程 t 的 state 状态）判断当前被采样线程 t 是运行 Java 方法的线程还是运行 Native 方法的线程（这里分析的事件是 ExecutionSample 事件，只需要采样 运行 Java 方法的线程），<br><strong>注：</strong>此时需要获得准确的线程状态！（细节参考文章 <a href="/2023/06/07/UseMembar/" title="UseMembar?">UseMembar?</a>）<ul><li>6.4.1 如果线程 t 在运行 Java 方法，跳转到 6.5 继续采样</li><li>6.4.2 如果线程 t 在运行 Native 方法，跳转回到 6.2</li></ul></li><li>6.5 采样线程通过 pthread_kill 函数给被采样线程 t 发出异常信号，使线程 t 进入异常处理逻辑（异常处理逻辑提前被初始化为 SR_handler 函数）<ul><li>6.5.1 被采样线程 t 进异常处理函数时会获得传入的参数 ucontext_t（其中记录着线程 t 当前运行的程序上下文）。将上下文信息保存到线程 t 对象中后，线程 t 调用 sigsuspend 函数将自己暂停</li><li>6.5.2 采样线程读取线程 t 的上下文信息 ucontext_t</li></ul></li><li>6.6 采样线程依据被采样线程 t 的上下文完成堆栈采样，采样线程发送 UNBLOCK 信号给被采样线程 t ，恢复被采样线程 t 的上下文。采样完成计数 + 1，并判断总采样成功计数是否大于阈值(Java 5 Native 1)。<ul><li>6.6.1 如果总采样成功计数小于阈值则转回到 6.2，继续采样</li><li>6.6.2 如果总采样成功计数大于阈值则释放 Threads table 锁，然后转到步骤 7</li></ul></li></ul><ol start="7"><li>采样线程一次采样结束（此时 lT 为最后被采样的线程），更新<code>上次采样结束的时间</code>（为当前时间，通过 clock_gettime 获得），并回第 3 步。</li></ol><h1 id="JFR-MethodProfiling-Event-采样算法源码分析"><a href="#JFR-MethodProfiling-Event-采样算法源码分析" class="headerlink" title="JFR MethodProfiling Event 采样算法源码分析"></a>JFR MethodProfiling Event 采样算法源码分析</h1><h2 id="方法采样频次控制"><a href="#方法采样频次控制" class="headerlink" title="方法采样频次控制"></a>方法采样频次控制</h2><p>ExecutionSample 与 NativeMethodSample 事件属于采样事件，需要按照一定频率进行。 Hotspot 会起一个专门的线程按照一定频次完成采样任务，一次采样任务只会采集固定个数的指定类型线程，并记录最后采集的线程；等下一次采集任务发生时会根据上次采集的线程，继续采集固定个数的指定类型线程，知道线程队列都被采集过一遍，再从头开始采集。</p><p>接下来通过分析 OpenJDK11 源码的方式看一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/share/jfr/periodic/sampling/jfrThreadSampler.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">JfrThreadSampler::run</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// 当前为新建的采样任务线程</span><br>  _sampler_thread = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// 初始化变量，last_java_ms 与 last_native_ms 分别记录最后一次 java/native方法采样的时间</span><br>  jlong last_java_ms = <span class="hljs-built_in">get_monotonic_ms</span>();<br>  jlong last_native_ms = last_java_ms;<br>  <span class="hljs-comment">//死循环，采样将持续进行，直到当前应用程序结束或者手动关闭 JFR 记录</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">//尝试获取信号量锁，_semaphore &gt; 0 =&gt; _semaphore -1 就不用进循环</span><br>    <span class="hljs-keyword">if</span> (!_sample.<span class="hljs-built_in">trywait</span>()) &#123;<br>      <span class="hljs-comment">// disenrolled</span><br>      _sample.<span class="hljs-built_in">wait</span>();<br>      <span class="hljs-comment">// 信号量 _semaphore -1 ，更新 last 时间</span><br>      last_java_ms = <span class="hljs-built_in">get_monotonic_ms</span>();<br>      last_native_ms = last_java_ms;<br>    &#125;<br>    <span class="hljs-comment">// 设置进程信号量 _sample 的 _semaphore +1 </span><br>    _sample.<span class="hljs-built_in">signal</span>();<br>    <span class="hljs-comment">// 设置记录间隔</span><br>    jlong java_interval = _interval_java == <span class="hljs-number">0</span> ? max_jlong : <span class="hljs-built_in">MAX2</span>&lt;jlong&gt;(_interval_java, <span class="hljs-number">1</span>);<br>    jlong native_interval = _interval_native == <span class="hljs-number">0</span> ? max_jlong : <span class="hljs-built_in">MAX2</span>&lt;jlong&gt;(_interval_native, <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 设置当前时间</span><br>    jlong now_ms = <span class="hljs-built_in">get_monotonic_ms</span>();<br>    <span class="hljs-comment">// 还剩 next 时间可以开始下次的方法采样</span><br>    jlong next_j = java_interval + (last_java_ms - now_ms);<br>    jlong next_n = native_interval + (last_native_ms - now_ms);<br><br>    jlong sleep_to_next = <span class="hljs-built_in">MIN2</span>&lt;jlong&gt;(next_j, next_n);<br>    <span class="hljs-comment">// sleep_to_next &gt; 0 还需等待，还不能开始</span><br>    <span class="hljs-keyword">if</span> (sleep_to_next &gt; <span class="hljs-number">0</span>) &#123;<br>      os::<span class="hljs-built_in">naked_short_sleep</span>(sleep_to_next);<span class="hljs-comment">//短暂等待，更新 sleep_to_next</span><br>    &#125;<br><br>    <span class="hljs-comment">// &lt;= 0 说明需要等待的时间为 &quot;负&quot; 可以开始采样</span><br>    <span class="hljs-comment">// 相同的判断，分别开始采样 Java 方法 与 Native 方法</span><br>    <span class="hljs-comment">// 最后更新 最后采样时间。</span><br>    <span class="hljs-keyword">if</span> ((next_j - sleep_to_next) &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 传入上一次采样的 Java 线程指针，传址调用，会在函数内部被修改为这次采样的最后一个线程</span><br>      <span class="hljs-built_in">task_stacktrace</span>(JAVA_SAMPLE, &amp;_last_thread_java);<br>      last_java_ms = <span class="hljs-built_in">get_monotonic_ms</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((next_n - sleep_to_next) &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">task_stacktrace</span>(NATIVE_SAMPLE, &amp;_last_thread_native);<br>      last_native_ms = <span class="hljs-built_in">get_monotonic_ms</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法采样频次的源码分析在上述源码中已经详细分析，不难看出 Java 方法的采样与 Native 方法的采样调用相同的方法，故此处只以 Java 方法的采样为例，进行分析。Native 方法的采样逻辑留待有兴趣的读者自行挖掘。</p><h2 id="Java-方法采样准备工作"><a href="#Java-方法采样准备工作" class="headerlink" title="Java 方法采样准备工作"></a>Java 方法采样准备工作</h2><p>上一节的源码部分实现的是固定间隔时间的采样频次控制，task_stacktrace 函数实现的是每次对固定个数线程反栈的操作。源码分析如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/share/jfr/periodic/sampling/jfrThreadSampler.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">JfrThreadSampler::task_stacktrace</span><span class="hljs-params">(JfrSampleType type, JavaThread** last_thread)</span> </span>&#123;<br>  ResourceMark rm;<br>  <span class="hljs-comment">// 方法采样事件组</span><br>  <span class="hljs-comment">// MAX_NR_OF_JAVA_SAMPLES = 5 MAX_NR_OF_NATIVE_SAMPLES = 1</span><br>  <span class="hljs-comment">// 每一次采样 Java 方法只采 5 个线程 Native 只采 1 个线程</span><br>  EventExecutionSample samples[MAX_NR_OF_JAVA_SAMPLES];<br>  EventNativeMethodSample samples_native[MAX_NR_OF_NATIVE_SAMPLES];<br>  <span class="hljs-function">JfrThreadSampleClosure <span class="hljs-title">sample_task</span><span class="hljs-params">(samples, samples_native)</span></span>;<br><br>  <span class="hljs-type">const</span> uint sample_limit = JAVA_SAMPLE == type ? MAX_NR_OF_JAVA_SAMPLES : MAX_NR_OF_NATIVE_SAMPLES;<br>  uint num_samples = <span class="hljs-number">0</span>;<br>  JavaThread* start = <span class="hljs-literal">NULL</span>;<br><br>  &#123;<br>    elapsedTimer sample_time;<br>    sample_time.<span class="hljs-built_in">start</span>();<br>    &#123; <span class="hljs-comment">// 将 monitor Threads_lock 上锁，在括号外调用析构函数解锁</span><br>      <span class="hljs-function">MonitorLockerEx <span class="hljs-title">tlock</span><span class="hljs-params">(Threads_lock, Mutex::_allow_vm_block_flag)</span></span>;<br>      <span class="hljs-comment">// Java 线程列表（包括在执行 Native 和 Java 方法的所有 JavaThread）</span><br>      ThreadsListHandle tlh;<br>      <span class="hljs-comment">// Resolve a sample session relative start position index into the thread list array.</span><br>      <span class="hljs-comment">// In cases where the last sampled thread is NULL or not-NULL but stale, find_index() returns -1.</span><br>      <span class="hljs-comment">// 上一次被采样的线程在线程列表中的线程号（如果是从头遍历，*last_thread = NULL，_cur_index = -1）</span><br>      _cur_index = tlh.<span class="hljs-built_in">list</span>()-&gt;<span class="hljs-built_in">find_index_of_JavaThread</span>(*last_thread);<br>      JavaThread* current = _cur_index != <span class="hljs-number">-1</span> ? *last_thread : <span class="hljs-literal">NULL</span>;<br><br>      <span class="hljs-keyword">while</span> (num_samples &lt; sample_limit) &#123;<br>        <span class="hljs-comment">// 找到下一个要被采样的线程 </span><br>        <span class="hljs-comment">//（如果 current 为 NULL 说明是一次新的遍历，current被更新为 0 号 Java 线程）</span><br>        current = <span class="hljs-built_in">next_thread</span>(tlh.<span class="hljs-built_in">list</span>(), start, current);<br>        <span class="hljs-comment">// current == NULL 说明线程列表都被采样完了，这一次即使没采满指定线程数也要退出了</span><br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">NULL</span>) &#123;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// start == NULL 说明是从头开始的新遍历，需要初始化 start</span><br>        <span class="hljs-keyword">if</span> (start == <span class="hljs-literal">NULL</span>) &#123;<br>          start = current;  <span class="hljs-comment">// remember the thread where we started to attempt sampling</span><br>        &#125;<br>        <span class="hljs-comment">// 被采样线程是编译线程也不采样</span><br>        <span class="hljs-keyword">if</span> (current-&gt;<span class="hljs-built_in">is_Compiler_thread</span>()) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对被采样线程进行反栈，反栈成功则采样数 +1</span><br>        <span class="hljs-keyword">if</span> (sample_task.<span class="hljs-built_in">do_sample_thread</span>(current, _frames, _max_frames, type)) &#123;<br>          num_samples++;<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 采样结束，将最后采样的线程设置为当前采样的线程</span><br>      *last_thread = current;  <span class="hljs-comment">// remember the thread we last attempted to sample</span><br>    &#125;<br>    sample_time.<span class="hljs-built_in">stop</span>();<br>    <span class="hljs-built_in">log_trace</span>(jfr)(<span class="hljs-string">&quot;JFR thread sampling done in %3.7f secs with %d java %d native samples&quot;</span>,<br>                   sample_time.<span class="hljs-built_in">seconds</span>(), sample_task.<span class="hljs-built_in">java_entries</span>(), sample_task.<span class="hljs-built_in">native_entries</span>());<br>  &#125;<br>  <span class="hljs-keyword">if</span> (num_samples &gt; <span class="hljs-number">0</span>) &#123;<br>    sample_task.<span class="hljs-built_in">commit_events</span>(type);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一部分主要包括采样线程的确定，单个线程的采样过程又被包装在 do_sample_thread 函数内，do_sample_thread 函数完成对正在执行不同方法的 Java 线程进行分类（按 Native 和 Java 方法）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JfrThreadSampleClosure::do_sample_thread</span><span class="hljs-params">(JavaThread* thread, JfrStackFrame* frames, u4 max_frames, JfrSampleType type)</span> </span>&#123;<br>  <span class="hljs-comment">// 被采样线程无法被反栈的话就当没采到</span><br>  <span class="hljs-keyword">if</span> (thread-&gt;<span class="hljs-built_in">is_hidden_from_external_view</span>() || thread-&gt;<span class="hljs-built_in">in_deopt_handler</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-type">bool</span> ret = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 将当前被采线程的 _suspendible_thread 状态原子的（cmpxchg）设置为 _trace_flag</span><br>  thread-&gt;<span class="hljs-built_in">set_trace_flag</span>();<br>  <span class="hljs-comment">// 对于虚拟屏障技术需要置换状态记录页的权限，确保 JavaThread 类的 _thread_state 状态是最新的 </span><br>  <span class="hljs-keyword">if</span> (!UseMembar) &#123;<br>    os::<span class="hljs-built_in">serialize_thread_states</span>();<br>  &#125;<br>  <span class="hljs-comment">// 根据采样事件类型确定当前线程是否是需要被采样的</span><br>  <span class="hljs-keyword">if</span> (JAVA_SAMPLE == type) &#123;<br>    <span class="hljs-comment">// 判断当前被采样的 JavaThread 的 _thread_state 是否为 Java 方法</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">thread_state_in_java</span>(thread)) &#123;<br>      <span class="hljs-comment">// 按照 Java 方法线程的方式进行反栈</span><br>      ret = <span class="hljs-built_in">sample_thread_in_java</span>(thread, frames, max_frames);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 采样 Native 方法的情况</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">thread_state_in_native</span>(thread)) &#123;<br>      ret = <span class="hljs-built_in">sample_thread_in_native</span>(thread, frames, max_frames);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">clear_transition_block</span>(thread);<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>sample_thread_in_java 函数除了包含反栈操作，还将得到的方法信息存储起来，并返回方法栈的在仓库中的 ID</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JfrThreadSampleClosure::sample_thread_in_java</span><span class="hljs-params">(JavaThread* thread, JfrStackFrame* frames, u4 max_frames)</span> </span>&#123;<br>  <span class="hljs-function">OSThreadSampler <span class="hljs-title">sampler</span><span class="hljs-params">(thread, *<span class="hljs-keyword">this</span>, frames, max_frames)</span></span>;<br>  <span class="hljs-comment">// 采样线程对被采样线程进行反栈获得函数调用栈</span><br>  sampler.<span class="hljs-built_in">take_sample</span>();<br>  <span class="hljs-comment">// 判断反栈是否成功</span><br>  <span class="hljs-keyword">if</span> (!sampler.<span class="hljs-built_in">success</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 方法采样事件</span><br>  EventExecutionSample *event = &amp;_events[_added_java - <span class="hljs-number">1</span>];<br>  <span class="hljs-comment">// 将得到的函数调用栈信息存储到 Heap 上，获得一个 id。</span><br>  <span class="hljs-comment">// Heap 上的信息会在程序退出或者根据启动 JFR 的 duration 参数 dump 到磁盘上。</span><br>  traceid id = JfrStackTraceRepository::<span class="hljs-built_in">add</span>(sampler.<span class="hljs-built_in">stacktrace</span>());<br>  <span class="hljs-comment">// 方法采样时间记录 id</span><br>  event-&gt;<span class="hljs-built_in">set_stackTrace</span>(id);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSThreadSampler::take_sample</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">run</span>();<br>&#125;<br><br><span class="hljs-comment">//class OSThreadSampler : public os::SuspendedThreadTask</span><br><span class="hljs-type">void</span> os::SuspendedThreadTask::<span class="hljs-built_in">run</span>() &#123;<br>  <span class="hljs-built_in">internal_do_task</span>();<br>  _done = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/os/linux/os_linux.cpp</span><br><span class="hljs-type">void</span> os::SuspendedThreadTask::<span class="hljs-built_in">internal_do_task</span>() &#123;<br>  <span class="hljs-comment">// suspend 被采样的线程</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">do_suspend</span>(_thread-&gt;<span class="hljs-built_in">osthread</span>())) &#123;<br>    <span class="hljs-comment">// 获得线程 TaskContext</span><br>    <span class="hljs-function">SuspendedThreadTaskContext <span class="hljs-title">context</span><span class="hljs-params">(_thread, _thread-&gt;osthread()-&gt;ucontext())</span></span>;<br>    <span class="hljs-comment">// 根据 TaskContext 获得函数调用栈信息</span><br>    <span class="hljs-built_in">do_task</span>(context);<br>    <span class="hljs-comment">// 恢复线程</span><br>    <span class="hljs-built_in">do_resume</span>(_thread-&gt;<span class="hljs-built_in">osthread</span>());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，最后反栈的过程会通过四部曲完成 —— suspend 被采样线程 ,采样线程获得 ucontext, 采样线程 do_task 获得堆栈信息, 采样线程 resume 被采样线程</p><h1 id="被采样的线程-suspend-与-resume-过程"><a href="#被采样的线程-suspend-与-resume-过程" class="headerlink" title="被采样的线程 suspend 与 resume 过程"></a>被采样的线程 suspend 与 resume 过程</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/os/linux/os_linux.cpp</span><br><span class="hljs-comment">// 采样线程调用 do_suspend 函数尝试将被采样的线程 suspend</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">do_suspend</span><span class="hljs-params">(OSThread* osthread)</span> </span>&#123;<br><br>  <span class="hljs-comment">// osthread-&gt;sr-&gt;_state 变为 SR_SUSPEND_REQUEST</span><br>  <span class="hljs-keyword">if</span> (osthread-&gt;sr.<span class="hljs-built_in">request_suspend</span>() != os::SuspendResume::SR_SUSPEND_REQUEST) &#123;<br>    <span class="hljs-comment">// failed to switch, state wasn&#x27;t running?</span><br>    <span class="hljs-built_in">ShouldNotReachHere</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 向线程传入 signal 信号（信号与对应的信号处理后续补充）</span><br>  <span class="hljs-comment">// pthread_kill(osthread-&gt;pthread_id(), SR_signum)</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sr_notify</span>(osthread) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">ShouldNotReachHere</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 尝试将全局对象 sr_semaphore 的信号量 _semaphore  -1</span><br>    <span class="hljs-keyword">if</span> (sr_semaphore.<span class="hljs-built_in">timedwait</span>(<span class="hljs-built_in">create_semaphore_timespec</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * NANOSECS_PER_MILLISEC))) &#123;<br>      <span class="hljs-comment">// 完成 -1，跳出循环</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 没完成即超过 2 ms的时间限制</span><br>      <span class="hljs-comment">// timeout</span><br>      os::SuspendResume::State cancelled = osthread-&gt;sr.<span class="hljs-built_in">cancel_suspend</span>();<br>      <span class="hljs-keyword">if</span> (cancelled == os::SuspendResume::SR_RUNNING) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cancelled == os::SuspendResume::SR_SUSPENDED) &#123;<br>        <span class="hljs-comment">// make sure that we consume the signal on the semaphore as well</span><br>        sr_semaphore.<span class="hljs-built_in">wait</span>();<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">ShouldNotReachHere</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-built_in">guarantee</span>(osthread-&gt;sr.<span class="hljs-built_in">is_suspended</span>(), <span class="hljs-string">&quot;Must be suspended&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// pthread_kill 传递信号后，被采样的线程会进入异常处理函数，context 中会保留 CPU 上下文</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">SR_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">siginfo_t</span>* siginfo, <span class="hljs-type">ucontext_t</span>* context)</span> </span>&#123;<br>  <span class="hljs-comment">// Save and restore errno to avoid confusing native code with EINTR</span><br>  <span class="hljs-comment">// after sigsuspend.</span><br>  <span class="hljs-type">int</span> old_errno = errno;<br>  Thread* thread = Thread::<span class="hljs-built_in">current_or_null_safe</span>();<br><br>  OSThread* osthread = thread-&gt;<span class="hljs-built_in">osthread</span>();<br><br>  os::SuspendResume::State current = osthread-&gt;sr.<span class="hljs-built_in">state</span>();<br>  <span class="hljs-comment">// 状态会在do_suspend 函数内被设置为 SR_SUSPEND_REQUEST</span><br>  <span class="hljs-keyword">if</span> (current == os::SuspendResume::SR_SUSPEND_REQUEST) &#123;<br>    <span class="hljs-comment">// 将上下文信息保存到被采样的线程对象中去</span><br>    <span class="hljs-built_in">suspend_save_context</span>(osthread, siginfo, context);<br><br>    <span class="hljs-comment">// attempt to switch the state, we assume we had a SUSPEND_REQUEST</span><br>    <span class="hljs-comment">// 准备将当前被采样线程暂停，需要将 state 变为 SR_SUSPENDED</span><br>    os::SuspendResume::State state = osthread-&gt;sr.<span class="hljs-built_in">suspended</span>();<br>    <span class="hljs-keyword">if</span> (state == os::SuspendResume::SR_SUSPENDED) &#123;<br>      <span class="hljs-type">sigset_t</span> suspend_set;  <span class="hljs-comment">// signals for sigsuspend()</span><br>      <span class="hljs-built_in">sigemptyset</span>(&amp;suspend_set);<br>      <span class="hljs-comment">// get current set of blocked signals and unblock resume signal</span><br>      <span class="hljs-built_in">pthread_sigmask</span>(SIG_BLOCK, <span class="hljs-literal">NULL</span>, &amp;suspend_set);<br>      <span class="hljs-built_in">sigdelset</span>(&amp;suspend_set, SR_signum);<br><br>      sr_semaphore.<span class="hljs-built_in">signal</span>();<br>      <span class="hljs-comment">// wait here until we are resumed</span><br>      <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 暂停线程，等待 UNBLOCK 信号唤醒</span><br>        <span class="hljs-built_in">sigsuspend</span>(&amp;suspend_set);<br><br>        os::SuspendResume::State result = osthread-&gt;sr.<span class="hljs-built_in">running</span>();<br>        <span class="hljs-keyword">if</span> (result == os::SuspendResume::SR_RUNNING) &#123;<br>          sr_semaphore.<span class="hljs-built_in">signal</span>();<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == os::SuspendResume::SR_RUNNING) &#123;<br>      <span class="hljs-comment">// request was cancelled, continue</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">ShouldNotReachHere</span>();<br>    &#125;<br>    <span class="hljs-comment">// 恢复运行，清楚记下的上下文</span><br>    <span class="hljs-built_in">resume_clear_context</span>(osthread);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == os::SuspendResume::SR_RUNNING) &#123;<br>    <span class="hljs-comment">// request was cancelled, continue</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == os::SuspendResume::SR_WAKEUP_REQUEST) &#123;<br>    <span class="hljs-comment">// ignore</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// ignore</span><br>  &#125;<br><br>  errno = old_errno;<br>&#125;<br><br><span class="hljs-comment">// 采样线程完成采样后，需要调用 do_resume 函数，使被采样线程恢复运行</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">do_resume</span><span class="hljs-params">(OSThread* osthread)</span> </span>&#123;<br>  <span class="hljs-comment">// 将被采样线程的 state 设置为 SR_WAKEUP_REQUEST</span><br>  <span class="hljs-keyword">if</span> (osthread-&gt;sr.<span class="hljs-built_in">request_wakeup</span>() != os::SuspendResume::SR_WAKEUP_REQUEST) &#123;<br>    <span class="hljs-comment">// failed to switch to WAKEUP_REQUEST</span><br>    <span class="hljs-built_in">ShouldNotReachHere</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 再次向被采样线程传递信号，恢复被采样线程的运行状态</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sr_notify</span>(osthread) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (sr_semaphore.<span class="hljs-built_in">timedwait</span>(<span class="hljs-built_in">create_semaphore_timespec</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> * NANOSECS_PER_MILLISEC))) &#123;<br>        <span class="hljs-keyword">if</span> (osthread-&gt;sr.<span class="hljs-built_in">is_running</span>()) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">ShouldNotReachHere</span>();<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="采样线程反栈"><a href="#采样线程反栈" class="headerlink" title="采样线程反栈"></a>采样线程反栈</h1><p>通过信号暂停了被采样线程后，同时还获取到被采样线程的上下文信息，并且这部分上下文信息被记录到被采样线程对象中去。此时采样线程将通过这部分上下文信息完成反栈工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSThreadSampler::do_task</span><span class="hljs-params">(<span class="hljs-type">const</span> os::SuspendedThreadTaskContext&amp; context)</span> </span>&#123;<br><br>  _suspend_time = JfrTicks::<span class="hljs-built_in">now</span>();<br>  <br>  <span class="hljs-keyword">if</span> (JfrOptionSet::<span class="hljs-built_in">sample_protection</span>()) &#123;<br>    <span class="hljs-function">OSThreadSamplerCallback <span class="hljs-title">cb</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>, context)</span></span>;<br>    os::ThreadCrashProtection crash_protection;<br>    <span class="hljs-comment">// call 方法传入对象 cb ，进行反栈</span><br>    <span class="hljs-keyword">if</span> (!crash_protection.<span class="hljs-built_in">call</span>(cb)) &#123;<br>      <span class="hljs-built_in">log_error</span>(jfr)(<span class="hljs-string">&quot;Thread method sampler crashed&quot;</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">protected_task</span>(context);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//src/hotspot/os/posix/os_posix.cpp</span><br><span class="hljs-type">bool</span> os::ThreadCrashProtection::<span class="hljs-built_in">call</span>(os::CrashProtectionCallback&amp; cb) &#123;<br>  <span class="hljs-type">sigset_t</span> saved_sig_mask;<br>  <span class="hljs-comment">// 获取 _crash_mux 锁</span><br>  Thread::<span class="hljs-built_in">muxAcquire</span>(&amp;_crash_mux, <span class="hljs-string">&quot;CrashProtection&quot;</span>);<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sigsetjmp</span>(_jmpbuf, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// make sure we can see in the signal handler that we have crash protection</span><br>    <span class="hljs-comment">// installed</span><br>    _crash_protection = <span class="hljs-keyword">this</span>;<br>    cb.<span class="hljs-built_in">call</span>();<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//src/hotspot/share/jfr/periodic/sampling/jfrThreadSampler.cpp</span><br><span class="hljs-comment">// 最终方法采样调用的是 OSThreadSamplerCallback 类的 call 方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OSThreadSamplerCallback</span> : <span class="hljs-keyword">public</span> os::CrashProtectionCallback &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 最终的反栈函数</span><br>    _sampler.<span class="hljs-built_in">protected_task</span>(_context);<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSThreadSampler::protected_task</span><span class="hljs-params">(<span class="hljs-type">const</span> os::SuspendedThreadTaskContext&amp; context)</span> </span>&#123;<br>  <span class="hljs-comment">// 被采样线程</span><br>  JavaThread* jth = (JavaThread*)context.<span class="hljs-built_in">thread</span>();<br>  <span class="hljs-comment">// Skip sample if we signaled a thread that moved to other state</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">thread_state_in_java</span>(jth)) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-function">JfrGetCallTrace <span class="hljs-title">trace</span><span class="hljs-params">(<span class="hljs-literal">true</span>, jth)</span></span>;<br>  frame topframe;<br>  <span class="hljs-comment">// 获取被采样线程的函数调用栈，放入 topframe</span><br>  <span class="hljs-keyword">if</span> (trace.<span class="hljs-built_in">get_topframe</span>(context.<span class="hljs-built_in">ucontext</span>(), topframe)) &#123;<br>    <span class="hljs-comment">// 将采样得到的函数调用堆栈存储到线程私有的内存内</span><br>    <span class="hljs-keyword">if</span> (_stacktrace.<span class="hljs-built_in">record_thread</span>(*jth, topframe)) &#123;<br>      <span class="hljs-comment">/* If we managed to get a topframe and a stacktrace, create an event</span><br><span class="hljs-comment">      * and put it into our array. We can&#x27;t call Jfr::_stacktraces.add()</span><br><span class="hljs-comment">      * here since it would allocate memory using malloc. Doing so while</span><br><span class="hljs-comment">      * the stopped thread is inside malloc would deadlock. */</span><br>     <span class="hljs-comment">// jfr event 记录</span><br>      _success = <span class="hljs-literal">true</span>;<br>      EventExecutionSample *ev = _closure.<span class="hljs-built_in">next_event</span>();<br>      ev-&gt;<span class="hljs-built_in">set_starttime</span>(_suspend_time);<br>      ev-&gt;<span class="hljs-built_in">set_endtime</span>(_suspend_time); <span class="hljs-comment">// fake to not take an end time</span><br>      ev-&gt;<span class="hljs-built_in">set_sampledThread</span>(<span class="hljs-built_in">JFR_THREAD_ID</span>(jth));<br>      ev-&gt;<span class="hljs-built_in">set_state</span>(java_lang_Thread::<span class="hljs-built_in">get_thread_status</span>(jth-&gt;<span class="hljs-built_in">threadObj</span>()));<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//src/hotspot/share/jfr/periodic/sampling/jfrCallTrace.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JfrGetCallTrace::get_topframe</span><span class="hljs-params">(<span class="hljs-type">void</span>* ucontext, frame&amp; topframe)</span> </span>&#123;<br>  <span class="hljs-comment">// 获得 top_frame，并存储到 topframe 内</span><br>  <span class="hljs-keyword">if</span> (!_thread-&gt;<span class="hljs-built_in">pd_get_top_frame_for_profiling</span>(&amp;topframe, ucontext, _in_java)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 栈顶的 codebuffer 不能是 NULL</span><br>  <span class="hljs-keyword">if</span> (topframe.<span class="hljs-built_in">cb</span>() == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  frame first_java_frame;<br>  Method* method = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find_top_frame</span>(topframe, &amp;method, first_java_frame)) &#123;<br>    <span class="hljs-keyword">if</span> (method == <span class="hljs-literal">NULL</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    topframe = first_java_frame;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 接下来进入平台相关部分，以x86_64为例</span><br><span class="hljs-comment">//src/hotspot/os_cpu/linux_x86/thread_linux_x86.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JavaThread::pd_get_top_frame_for_profiling</span><span class="hljs-params">(frame* fr_addr, <span class="hljs-type">void</span>* ucontext, <span class="hljs-type">bool</span> isInJava)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">pd_get_top_frame</span>(fr_addr, ucontext, isInJava);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">JavaThread::pd_get_top_frame</span><span class="hljs-params">(frame* fr_addr, <span class="hljs-type">void</span>* ucontext, <span class="hljs-type">bool</span> isInJava)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">is_Java_thread</span>(), <span class="hljs-string">&quot;must be JavaThread&quot;</span>);<br>  JavaThread* jt = (JavaThread *)<span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// 如果有一个last_Java_frame，那么直接使用它。它应该比 ucontext 信息更可靠。</span><br>  <span class="hljs-keyword">if</span> (jt-&gt;<span class="hljs-built_in">has_last_Java_frame</span>() &amp;&amp; jt-&gt;<span class="hljs-built_in">frame_anchor</span>()-&gt;<span class="hljs-built_in">walkable</span>()) &#123;<br>    *fr_addr = jt-&gt;<span class="hljs-built_in">pd_last_frame</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果没有 last_Java_frame，尝试从ucontext中收集一些信息。</span><br>  <span class="hljs-keyword">if</span> (isInJava) &#123;<br>    <span class="hljs-type">ucontext_t</span>* uc = (<span class="hljs-type">ucontext_t</span>*) ucontext;<br><br>    <span class="hljs-type">intptr_t</span>* ret_fp;<br>    <span class="hljs-type">intptr_t</span>* ret_sp;<br>    ExtendedPC addr = os::Linux::<span class="hljs-built_in">fetch_frame_from_ucontext</span>(<span class="hljs-keyword">this</span>, uc,<br>      &amp;ret_sp, &amp;ret_fp);<br>    <span class="hljs-keyword">if</span> (addr.<span class="hljs-built_in">pc</span>() == <span class="hljs-literal">NULL</span> || ret_sp == <span class="hljs-literal">NULL</span> ) &#123;<br>      <span class="hljs-comment">// ucontext wasn&#x27;t useful</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (MetaspaceShared::<span class="hljs-built_in">is_in_trampoline_frame</span>(addr.<span class="hljs-built_in">pc</span>())) &#123;<br>      <span class="hljs-comment">// In the middle of a trampoline call. Bail out for safety.</span><br>      <span class="hljs-comment">// This happens rarely so shouldn&#x27;t affect profiling.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function">frame <span class="hljs-title">ret_frame</span><span class="hljs-params">(ret_sp, ret_fp, addr.pc())</span></span>;<br>    <span class="hljs-keyword">if</span> (!ret_frame.<span class="hljs-built_in">safe_for_sender</span>(jt)) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> COMPILER2_OR_JVMCI</span><br>      <span class="hljs-comment">// C2 and JVMCI use ebp as a general register see if NULL fp helps</span><br>      <span class="hljs-function">frame <span class="hljs-title">ret_frame2</span><span class="hljs-params">(ret_sp, <span class="hljs-literal">NULL</span>, addr.pc())</span></span>;<br>      <span class="hljs-keyword">if</span> (!ret_frame2.<span class="hljs-built_in">safe_for_sender</span>(jt)) &#123;<br>        <span class="hljs-comment">// nothing else to try if the frame isn&#x27;t good</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      ret_frame = ret_frame2;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>      <span class="hljs-comment">// nothing else to try if the frame isn&#x27;t good</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// COMPILER2_OR_JVMCI</span></span><br>    &#125;<br>    *fr_addr = ret_frame;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// nothing else to try</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Hotspot</tag>
      
      <tag>Java</tag>
      
      <tag>JDK Flight Recorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 锁同步</title>
    <link href="/2023/05/19/JVM-%E9%94%81%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/05/19/JVM-%E9%94%81%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>Java 锁相关的资料有很多，此处是笔者的粗浅理解，如有不当之处欢迎指正。<span id="more"></span></p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><p>synchronized 原理的解析与后文源码分析借鉴引用了<a href="#references">《这才叫Synchronized的源码分析》</a>一文。</p><p>synchronized 关键字，用于方法加锁，要求任一线程运行到这个方法时，都要检查有没有其它线程正在用这个方法（或者该类的其他同步方法），有的话要等正在使用 synchronized 方法的线程运行完这个方法后再运行此线程；没有的话,锁定调用者，然后直接运行。</p><p>想要实现 synchronized 关键字的上述功能，可以将加锁的逻辑转换为：对一个对象的监视器( monitor )进行排他获取（即同一个时刻只能有一个线程获得由 synchronized 所保护对象的监视器）。在Hotspot中，是通过 ObjectMonitor 来实现，每个对象中都会内置一个 ObjectMonitor 对象</p><h2 id="对象头的-Mark-Word"><a href="#对象头的-Mark-Word" class="headerlink" title="对象头的 Mark Word"></a>对象头的 Mark Word</h2><p><img src="/img/monitor%E5%88%86%E6%9E%90/mark.png" alt="HotSpot虚拟机对象头的 Mark Word "></p><p>这里参考马智的<a href="#references">《深入剖析Java虚拟机》</a>给出64位的对象头的 Mark Word 的图解，整体与32位的对象头没有大的出入。对象头是一个Java对象在内存中的布局的一部分，当锁膨胀为重量级锁后，指向重量级锁的指针实际上就是指向对象对应的 monitor，依托 monitor 实现争抢锁的逻辑。</p><h2 id="锁状态转换"><a href="#锁状态转换" class="headerlink" title="锁状态转换"></a>锁状态转换</h2><p>Hotspot 中锁一共四种状态：</p><p><code>未锁定状态</code> -&gt; <code>偏向锁状态</code> -&gt; <code>轻量级锁状态</code> -&gt; <code>重量级锁状态</code></p><p>锁只能升级，不能降级，状态转化及对象 Mark word 的关系图如下：</p><p><img src="/img/monitor%E5%88%86%E6%9E%90/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.png" alt="偏向锁、轻量级锁状态转换与对象头关系图"></p><p>偏向锁状态的 Mark Word 可以很自然地通过计算 hash code 转换为不可用偏向锁的无锁状态；但是被轻量级&#x2F;重量级锁定状态转换为无锁状态需要恢复 Mark Word 的 age 、 cms_free 属性，这就要求有地方对这几项属性进行保存。</p><h2 id="Lock-Record"><a href="#Lock-Record" class="headerlink" title="Lock Record"></a>Lock Record</h2><p>对于偏向锁和轻量级锁，在代码即将进入同步块的时候，如果此同步对象没有被锁定，jvm 首先将在当前线程 A 的栈帧中建立一个名为锁记录（Lock Record）的空间，轻量级锁将它用于存储锁对象目前的 Mark Word 的拷贝。获取锁的过程可以简化为尝试将对象的锁拥有者（ Mark Word &#x2F; _owner ） 写为当前线程 A 的过程。</p><p>锁重入：同一个线程执行外层同步方法时获得对象锁之后，对象的所有同步方法都已被上锁，内层同步方法再次获取该锁称为重入。</p><p>Displayed Mark Word 用于存储对象加锁前的 Mark Word</p><p>下图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录：</p><p><img src="/img/monitor%E5%88%86%E6%9E%90/LockRecord.png" alt=" 持有偏向锁的线程堆栈 "></p><h1 id="Hotspot-中锁的实现逻辑"><a href="#Hotspot-中锁的实现逻辑" class="headerlink" title="Hotspot 中锁的实现逻辑"></a>Hotspot 中锁的实现逻辑</h1><p>想要理解锁的实现逻辑，首先需要理解这个锁被设计出来的目的以及它的作用；再通过逻辑转换图的方式理解锁的实现逻辑，同时印证锁的作用；三种锁有不同的处理逻辑，处理逻辑也包含着状态转换的逻辑。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><h3 id="偏向锁的目的作用"><a href="#偏向锁的目的作用" class="headerlink" title="偏向锁的目的作用"></a>偏向锁的目的作用</h3><p>大多数情况下，锁不仅存在多线程竞争，当一个线程获取锁，后面还有大概率该线程还会需要继续持有这把锁。为了优化性能，于是在无竞争的情况下将同步过程移除（不需要 CAS ）。偏向锁的加锁与撤销流程，博客<a href="#references">《偏向锁的获取和撤销详解》</a>一文非常详实，此处直接引用。</p><h3 id="偏向锁的加锁"><a href="#偏向锁的加锁" class="headerlink" title="偏向锁的加锁"></a>偏向锁的加锁</h3><ul><li><p>线程 A 第一次访问同步代码块时，先检查对象头 Mark Word 中锁标志位是否为 01 ，依此判断此时对象是否处于无锁状态或者偏向锁状态；</p></li><li><p>若锁标志位是为 01 ，然后判断偏向锁的标识是否为 1 ：</p><ul><li>如果不是，则进入轻量级锁逻辑（使用CAS竞争锁）（注意：此时不是使用CAS尝试获取偏向锁，而是直接升级为轻量级锁；原因是：当偏向锁的标识为0时，表明偏向锁在此对象上被禁用，禁用原因可能是JVM关闭了偏向锁模式，或该类刚经历过 bulk revocation ，等等。所以应该入轻量级锁逻辑）：</li><li>如果是 1 ，表明此对象是偏向锁状态，则进行下一步流程。</li></ul></li><li><p>判断是偏向锁时，检查对象头 Mark Word 中记录的 ThreadID 是否是当前线程 A 的 ID ：</p><ul><li>如果是，则表明当前线程 A 已经获得过该对象锁，以后线程A进入同步代码块时，不需要 CAS 进行加锁，只会往当前线程 A 的栈中添加一条 Displaced Mark Word 为空的 Lock Record ，用来统计重入的次数。</li><li>如果不是，则进行 CAS 操作（比较对象 Mark Word 和 匿名的 Mark Word （ThreadID属性为 0 ） 是否一致，一致则将 当前线程写入对象 Mark Word），尝试将当前线程 A 的 ID 替换进 Mark Word ：<ul><li>如果当前对象锁的 ThreadID 为 0（匿名偏向锁状态），则会替换成功（将 Mark Word 中的 Thread id 由匿名 0 改成当前线程 A 的 ID ，在当前线程 A 栈中找到内存地址最高的可用 Lock Record ，将线程 A 的 ID 存入），获得到锁，执行同步代码块。</li><li>如果当前对象锁的 ThreadID 不为 0 ，即该对象锁已经被其他线程 B 占用了，则会替换失败，开始进行偏向锁撤销。这也是偏向锁的特点，一旦出现线程竞争，就会撤销偏向锁。</li></ul></li></ul></li></ul><p>当线程 A 对对象加偏向锁后，在同步方法退出甚至线程死亡时并不会对这个锁做传统的解锁操作，只有当另一个线程 B 也需要持有这个对象的锁，才会发生偏向锁的撤销操作。</p><h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><p>此时持有偏向锁的线程为 A ，线程 B 尝试进入同步块（获取锁），此时会发生偏向锁的撤销</p><ul><li>偏向锁的撤销需要等待全局安全点（ safe point ，代表了一个状态，在该状态下所有线程都是暂停的， stop-the-world ），到达全局安全点后，持有偏向锁的线程 A 也被暂停了。</li><li>检查持有偏向锁的线程 A 的状态（会遍历当前 JVM 的所有线程，如果能找到线程 A ，则说明偏向的线程 A 还存活着）：<ul><li>如果线程还存活，则检查线程是否还在执行同步代码块中的代码：<ul><li>如果是，则把该偏向锁升级为轻量级锁，且原持有偏向锁的线程 A 继续获得该轻量级锁。</li><li>如果否，处理同线程未存活。</li></ul></li><li>如果线程未存活，或线程未在执行同步代码块中的代码（线程 A 的栈中是否存在指向该对象的 Lock Record），则进行校验是否允许重偏向：<ul><li>如果不允许重偏向，则将 Mark Word 设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行轻量级锁的 CAS 竞争锁操作。</li><li>如果允许重偏向，设置为匿名偏向锁状态（即线程 A 释放偏向锁）。当唤醒线程后，进行 CAS 将偏向锁指向线程 B （在对象头和线程栈帧的锁记录中存储当前线程 ID ）。</li></ul></li></ul></li><li>唤醒暂停的线程，从安全点继续执行代码。</li></ul><p>如何判断线程是否还在执行同步代码块中的代码：每次进入同步块（即执行 monitorenter ）的时候都会以从高往低的顺序在栈中找到第一个可用的 Lock Record ，并设置偏向线程 ID ；每次解锁（即执行 monitorexit ）的时候都会从最低的一个 Lock Record 移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。</p><h3 id="批量重偏向与批量撤销逻辑"><a href="#批量重偏向与批量撤销逻辑" class="headerlink" title="批量重偏向与批量撤销逻辑"></a>批量重偏向与批量撤销逻辑</h3><p>默认开启批量重偏向<br>BiasedLockingBulkRebiasThreshold 20 偏向锁批量重偏问阈值<br>BiasedLockingBulkRevokeThreshold 40 偏向锁批量撤销值阈值</p><p><strong>批量重偏向</strong></p><ul><li>线程 A 创建了同一个类( a.class )的 50 个对象 obj ，jvm 会在 obj 对象的<code>类class对象</code>中， 定义了一个偏向 revoke （撤销）计数器以及 epoch 偏向版本。</li><li>线程 A 都调用了1~49 号对象的同步方法并退出不再进入，调用第 50 号对象的同步方法并停留，此时这 50 个对象都获取到了指向线程 A 的偏向锁。</li><li>线程 B 依次调用第 1~50 号对象的同步方法，第 1~19 号对象的偏向锁发生撤销（ a.class类对象 的偏向锁撤销计数器 +1）。<ul><li>由于线程 A 已经退出了 1~49 号对象的同步块且不再进入，此时将第 1~19 号对象的 Mark Word 设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁。</li><li>线程 B 调用第 20 号对象的同步方法，发生第 20 次偏向锁撤销，a.class 类对象的偏向撤销计数器自增为20，认为出现大规模的锁撤销动作，a.class 类对象 中的 epoch 值 +1。</li><li>偏向锁撤销一定发生在安全点， 此时 jvm 会找到所有正处在同步代码块中的obj对象（第 50 号对象），让他们的 epoch 等于 a.class 类对象的 epoch。其他不在同步代码块中的 obj 对象，则不修改 epoch 。</li><li>线程 B 继续获取第 20~49 号对象的锁，此时在撤销指向线程 A 的偏向锁时，判断到 obj 对象的 epoch 和 a.class 对象的 epoch 不相等（即允许重偏向状态），会将偏向锁设置为匿名偏向锁。当唤醒线程后，进行 CAS 将偏向锁直接指向线程 B （在对象头和线程栈帧的锁记录中存储当前线程 ID ）。</li><li>（在批量重偏向之后，B 调用 50 号对象的同步方法之前，线程 A 退出 50 号对象的同步方法）当线程 B 获取第 50 号对象锁时，发生偏向锁的撤销，由于发生批量重偏向时该对象处在同步块中，它的 epoch 更新已经等于 a.class 类对象的 epoch，属于不允许重偏向，将第 50 号对象的 Mark Word 设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁。</li><li>线程 B 释放所有对象锁退出同步块，此时状态 第 1~19,50 号对象 Mark Word 为未锁定不可偏向状态（0|01），第 20~49 号对象的 Mark Word 为指向线程 B 的偏向锁</li></ul></li></ul><p><strong>批量撤销</strong></p><ul><li>线程 C 依次调用第 20~39 号对象的同步方法，第 20~39 号对象的偏向锁发生撤销（ a.class类对象 的偏向锁撤销计数器 +1）。</li><li>由于线程 B 已经退出了所有对象的同步块，此时将第 20~39 号对象的 Mark Word 设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁。<ul><li>线程 C 调用第 39 个对象的同步方法，发生第 40 次偏向锁撤销，a.class 类对象的偏向撤销计数器自增为40，发生批量撤销。</li><li>jvm 此时会将 a.class 类对象中的偏向标记（注意是类中的偏向锁开启标记，而不是对象头中的偏向锁标记）设置为禁用偏向锁。</li></ul></li><li>后续 a.class 对应的对象的 new 操作将直接走轻量级锁的逻辑。</li><li>如果此时线程 B 调用第 40~49 号对象（这几个对象的 Mark Word 为已偏向状态，偏向线程 B ），此时由于已经发生了批量撤销，获取锁的方式变换为获取轻量级锁，不再走偏向锁逻辑。</li></ul><p><img src="/img/monitor%E5%88%86%E6%9E%90/%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E3%80%81%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80.png" alt="批量重偏向与批量撤销"></p><h3 id="偏向锁过程转换图"><a href="#偏向锁过程转换图" class="headerlink" title="偏向锁过程转换图"></a>偏向锁过程转换图</h3><p>可以结合流程图理解：</p><p><img src="/img/monitor%E5%88%86%E6%9E%90/biased.png" alt=" 偏向锁的加锁与撤销 "></p><p>图中，黄色块CAS操作的成功、失败的判断依据为 Mark Word 的线程 ID 是否为匿名状态。<br>偏向锁的获取撤销涉及的对象头转换涵盖了上文<a href="#%E9%94%81%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">偏向锁、轻量级锁状态转换与对象头关系图</a>的左半部分</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>偏向锁针对的情况是单一线程长期持有锁的情况，轻量级锁针对的情况是线程交替（不能是同时）执行同步块的情况。</p><h3 id="轻量级锁的加锁"><a href="#轻量级锁的加锁" class="headerlink" title="轻量级锁的加锁"></a>轻量级锁的加锁</h3><ul><li>在代码进入同步块的时候，先检查对象头 Mark Word 中锁标志位是否为 01 ，依此判断此时对象是否处于无锁状态或者偏向锁状态；</li><li>若锁标志位是为 01 ，然后判断偏向锁的标识是否为 1 ：<ul><li>如果是 1 ，表明此对象是偏向锁状态，上文已经讨论。</li><li>如果不是，则进入轻量级锁逻辑</li></ul></li><li>由于已经有同步对象锁状态为无锁状态（锁标志位为“ 01 ”状态），于是在当前线程的栈帧中建立一个名为锁记录（ Lock Record ）的空间，用于存储锁对象目前的 Mark Word 的拷贝，官方称之为 Displaced Mark Word。<ul><li>拷贝对象头中的 Mark Word 复制到锁记录中。</li><li>拷贝成功后，将使用 CAS 操作（比较拷贝过来的 Displaced Mark Word 与 对象头的 Mark Word 是否一致，防止拷贝期间锁被其他线程已经抢占）尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock record 里的 owner 指针指向 object mark word 。<ul><li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，说明此时对象头的 Mark Word 已经被修改了（在尝试获取期间被其他线程抢到了锁），需要进入锁膨胀流程。</li></ul></li></ul></li><li>若锁标志位是为 00 ，则说明此时已经处于轻量级锁的上锁状态，判断对象的 Mark Word 是否指向当前线程的栈帧；<ul><li>如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。</li><li>如果不是说明多个线程竞争锁，需要进入锁膨胀流程。</li></ul></li><li>当抢锁失败（01锁状态和00锁状态都会出现抢锁失败）之后，就需要进入锁膨胀过程，轻量级锁膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word 中存储的就变成指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li></ul><h3 id="轻量级锁的解锁"><a href="#轻量级锁的解锁" class="headerlink" title="轻量级锁的解锁"></a>轻量级锁的解锁</h3><ul><li>线程推出同步块方法后，首先获取当前线程中末尾的 Lock Record 中的 Mark Word ，判断 Mark Word 是否为 Null<ul><li>如果为 Null 说明是从重入锁退出，那只需要删除当前的 Lock Record 即可。</li><li>如果不是 Null 说明是当前线程释放该锁，进入轻量级锁的实际解锁过程。</li></ul></li><li>通过CAS操作（比较对象头 Mark Word 指向的地址 和 线程栈帧中 Displayed Mark Word 的地址是否一致，一致说明是轻量级锁，否则说明已经指向重量级锁了）尝试把线程中复制的 Displaced Mark Word 对象替换当前的Mark Word（回到无锁状态）。</li><li>如果替换成功，整个同步过程就完成了，锁完成解锁。</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程（过程在重量级锁中展开）。</li></ul><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h1 id="加锁过程源码分析"><a href="#加锁过程源码分析" class="headerlink" title="加锁过程源码分析"></a>加锁过程源码分析</h1><p id="references"></p>    <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/qq_42986622/article/details/120845878">这才叫Synchronized的源码分析</a><br><a href="https://cloud.tencent.com/developer/article/1036756">锁原理：偏向锁、轻量锁、重量锁1.加锁2.撤销偏向锁1.加锁2.解锁3.膨胀为重量级锁</a><br><a href="https://blog.csdn.net/A_BCDEF_/article/details/89436705">java中的锁——偏向锁，轻量级锁，重量级锁</a><br><a href="https://blog.csdn.net/weixin_43882265/article/details/121318419">偏向锁的获取和撤销详解</a><br><a href="https://www.cnblogs.com/paddix/p/5405678.html">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a><br><a href="https://zhuanlan.zhihu.com/p/537852119">7000+字图文并茂解带你深入理解java锁升级的每个细节</a><br><a href="https://github.com/farmerjohngit/myblog/issues/13">死磕Synchronized底层实现–偏向锁</a><br>《深入理解Java虚拟机》周志明<br>《深入剖析Java虚拟机》马智</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hotspot</tag>
      
      <tag>Java</tag>
      
      <tag>monitor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JFR可靠性分析</title>
    <link href="/2023/05/15/JFR%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <url>/2023/05/15/JFR%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="JFR-Event-记录源码分析"><a href="#JFR-Event-记录源码分析" class="headerlink" title="JFR Event 记录源码分析"></a>JFR Event 记录源码分析</h1><p>JDK Flight Recorder ( JFR ) 记录以 Event 为单位，每个 Event 都有<code>事件类型</code>，<code>开始时间</code>，<code>结束时间</code>，<code>发生事件的线程</code>，<code>事件发生的线程堆栈</code>还有<code>Event 数据体组成</code>。<span id="more"></span></p><p>下面我们通过源码的方式理解 JFR 记录的过程</p><h1 id="开启记录并提交"><a href="#开启记录并提交" class="headerlink" title="开启记录并提交"></a>开启记录并提交</h1><p>以 JavaMonitorEnter 为例，首先查看 JavaMonitorEnter 的 Event 数据体（大多数 Event 的数据体描述都记录在 metadata.xml 文件中，category&#x3D;”Java Development kit” 的 Event 数据体不在里面 ）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--bishengjdk-11-mirror/src/hotspot/share/jfr/metadata/metadata.xml--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Event</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;JavaMonitorEnter&quot;</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;Java Application&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Java Monitor Blocked&quot;</span> <span class="hljs-attr">thread</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">stackTrace</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Field</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Class&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;monitorClass&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Monitor Class&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Field</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Thread&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;previousOwner&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Previous Monitor Owner&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Field</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;ulong&quot;</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Monitor Address&quot;</span> <span class="hljs-attr">relation</span>=<span class="hljs-string">&quot;JavaMonitorAddress&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Event</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>通过 metadata.xml 中的描述可知 JavaMonitorEnter Event 的数据体包括 <code>monitorClass</code> <code>previousOwner</code> <code>address</code>，相应的描述也在 metadata.xml 中。当开启 JFR 对 JavaMonitorEnter Event 采集时，会在 ObjectMonitor::enter 函数内额外执行以下部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/share/runtime/objectMonitor.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::enter</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">//...</span><br>    EventJavaMonitorEnter event;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-built_in">should_commit</span>()) &#123;<br>    event.<span class="hljs-built_in">set_monitorClass</span>(((oop)<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">object</span>())-&gt;<span class="hljs-built_in">klass</span>());<br>    event.<span class="hljs-built_in">set_address</span>((<span class="hljs-type">uintptr_t</span>)(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">object_addr</span>()));<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-built_in">should_commit</span>()) &#123;<br>    event.<span class="hljs-built_in">set_previousOwner</span>((<span class="hljs-type">uintptr_t</span>)_previous_owner_tid);<br>    event.<span class="hljs-built_in">commit</span>();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>代码抽象出来看其实包括4个部分：</p><ol><li>某个 Event 对象初始化</li><li>判断是否开启某个 Event 的检测</li><li>设置某个 Event 对应的<code>数据体</code></li><li>event.commit()</li></ol><p>这部分代码首先回答了<code>Event 数据体</code>信息的采集过程，另一方面 commit 会完成剩余的<code>开始时间</code>，<code>结束时间</code>，<code>发生事件的线程</code>，<code>事件发生的线程堆栈</code>信息的采集（<code>事件类型</code>由 Event 类确定），下面通过源码方式理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bishengjdk-11-mirror/build/linux-x86_64-normal-server-release/hotspot/variant-server/gensrc/jfrfiles/jfrEventClasses.hpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventJavaMonitorEnter</span> : <span class="hljs-keyword">public</span> JfrEvent&lt;EventJavaMonitorEnter&gt;<br>&#123;<br>    <span class="hljs-comment">//初始化对象，当timing=TIMED时，需要记下当前时刻的时间作为测试开始时间</span><br>    <span class="hljs-built_in">EventJavaMonitorEnter</span>(EventStartTime timing=TIMED) : <span class="hljs-built_in">JfrEvent</span>&lt;EventJavaMonitorEnter&gt;(timing) &#123;&#125;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//使用父类的commit函数</span><br>    <span class="hljs-keyword">using</span> JfrEvent&lt;EventJavaMonitorEnter&gt;::commit;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">//bishengjdk-8/hotspot/src/share/vm/jfr/recorder/service/jfrEvent.hpp</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JfrEvent</span> &#123;<br>  <span class="hljs-keyword">private</span>:<br>  jlong _start_time;<br>  jlong _end_time;<br>  <span class="hljs-type">bool</span> _started;<br><br>  <span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">//初始化函数，当TIMED == timing &amp;&amp; !T::isInstant时会设置当前 Event 对象的开始时间（为当前）</span><br>  <span class="hljs-built_in">JfrEvent</span>(EventStartTime timing=TIMED) : _start_time(<span class="hljs-number">0</span>), _end_time(<span class="hljs-number">0</span>), _started(<span class="hljs-literal">false</span>)  &#123;<br>    <span class="hljs-keyword">if</span> (T::<span class="hljs-built_in">is_enabled</span>()) &#123;<br>      _started = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span> (TIMED == timing &amp;&amp; !T::isInstant) &#123;<br>        <span class="hljs-built_in">set_starttime</span>(JfrTicks::<span class="hljs-built_in">now</span>());<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//当完成 Event 数据体采集后调用 commit 函数</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//判断是否需要commit</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">should_commit</span>()) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 针对不同 Event 有不同采集需求，有的需要同时记录开始结束时间，有的只需要一个开始时间</span><br>    <span class="hljs-comment">// 如果初始化没有设置 _start_time，则 _start_time 为当前时间</span><br>    <span class="hljs-keyword">if</span> (_start_time == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">set_starttime</span>(JfrTicks::<span class="hljs-built_in">now</span>());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_end_time == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">//正常情况下在初始化对象时设置完_start_time，在commit函数内设置_endtime为当前时间</span><br>      <span class="hljs-built_in">set_endtime</span>(JfrTicks::<span class="hljs-built_in">now</span>());<br>    &#125;<br>    <span class="hljs-comment">// 记录线程信息与堆栈信息</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">should_write</span>()) &#123;<br>      <span class="hljs-built_in">write_event</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write_event</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//获取当前线程  </span><br>  Thread* <span class="hljs-type">const</span> event_thread = Thread::<span class="hljs-built_in">current</span>();<br>  <span class="hljs-comment">//获取当前线程的 jfr 的线程私有信息</span><br>  JfrThreadLocal* <span class="hljs-type">const</span> tl = event_thread-&gt;<span class="hljs-built_in">jfr_thread_local</span>();<br>  <span class="hljs-comment">//找到线程私有内存中的 jfr buffer</span><br>  JfrBuffer* <span class="hljs-type">const</span> buffer = tl-&gt;<span class="hljs-built_in">native_buffer</span>();<br>  <span class="hljs-comment">//buffer 为空直接返回</span><br>  <span class="hljs-keyword">if</span> (buffer == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// most likely a pending OOM</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-function">JfrNativeEventWriter <span class="hljs-title">writer</span><span class="hljs-params">(buffer, event_thread)</span></span>;<br>  <span class="hljs-comment">//将当前 Event 的Id写入buffer</span><br>  writer.<span class="hljs-built_in">write</span>&lt;u8&gt;(T::eventId);<br>  <span class="hljs-comment">//将当前 Event 的开始时间写入buffer</span><br>  writer.<span class="hljs-built_in">write</span>(_start_time);<br>  <span class="hljs-keyword">if</span> (!(T::isInstant || T::isRequestable) || T::hasCutoff) &#123;<br>  <span class="hljs-comment">//将当前 Event 的持续时间写入buffer</span><br>    writer.<span class="hljs-built_in">write</span>(_end_time - _start_time);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (T::hasThread) &#123;<br>  <span class="hljs-comment">//将当前 Event 的线程号写入buffer</span><br>    writer.<span class="hljs-built_in">write</span>(tl-&gt;<span class="hljs-built_in">thread_id</span>());<br>  &#125;<br>  <span class="hljs-comment">//将当前 Event 的堆栈写入buffer</span><br>  <span class="hljs-keyword">if</span> (T::hasStackTrace) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_stacktrace_enabled</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (tl-&gt;<span class="hljs-built_in">has_cached_stack_trace</span>()) &#123;<br>      writer.<span class="hljs-built_in">write</span>(tl-&gt;<span class="hljs-built_in">cached_stack_trace_id</span>());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      writer.<span class="hljs-built_in">write</span>(JfrStackTraceRepository::<span class="hljs-built_in">record</span>(event_thread));<br>    &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        writer.<span class="hljs-built_in">write</span>&lt;traceid&gt;(<span class="hljs-number">0</span>);<br>      &#125;<br>    &#125;<br>  <span class="hljs-comment">// payload</span><br>  <span class="hljs-built_in">static_cast</span>&lt;T*&gt;(<span class="hljs-keyword">this</span>)-&gt;<span class="hljs-built_in">writeData</span>(writer);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述方式，将 Event 的<code>事件类型</code>，<code>开始时间</code>，<code>持续时间</code>，<code>发生事件的线程</code>，<code>事件发生的线程堆栈</code>还有<code>Event 数据体组成</code>都写入线程私有的 Buffer 内存中，后续会在 buffer 满之后，将 buffer 内的数据提交到 global buffer 内。</p><h1 id="时间获取的方式"><a href="#时间获取的方式" class="headerlink" title="时间获取的方式"></a>时间获取的方式</h1><p>通过上文的源码分析可以发现，JFR 获取时间戳的方式为 JfrTicks::now() 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/share/jfr/utilities/jfrTime.hpp</span><br><span class="hljs-keyword">typedef</span> TimeInstant&lt;CounterRepresentation, FastUnorderedElapsedCounterSource&gt; JfrTicks;<br><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/share/utilities/ticks.hpp</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rep</span>, <span class="hljs-keyword">typename</span> TimeSource&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeInstant</span> : <span class="hljs-keyword">public</span> Rep&lt;TimeSource&gt; &#123;<br>    <span class="hljs-comment">//...</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stamp</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;_rep = TimeSource::<span class="hljs-built_in">now</span>();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">static</span> TimeInstant&lt;Rep, TimeSource&gt; <span class="hljs-title">now</span><span class="hljs-params">()</span> </span>&#123;<br>    TimeInstant&lt;Rep, TimeSource&gt; temp;<br>    temp.<span class="hljs-built_in">stamp</span>();<br>    <span class="hljs-keyword">return</span> temp;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/share/utilities/ticks.cpp</span><br><span class="hljs-function">FastUnorderedElapsedCounterSource::Type <span class="hljs-title">FastUnorderedElapsedCounterSource::now</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(X86) &amp;&amp; !defined(ZERO)</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">bool</span> valid_rdtsc = Rdtsc::<span class="hljs-built_in">initialize</span>();<br>  <span class="hljs-keyword">if</span> (valid_rdtsc) &#123;<br>    <span class="hljs-keyword">return</span> Rdtsc::<span class="hljs-built_in">elapsed_counter</span>();<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-keyword">return</span> os::<span class="hljs-built_in">elapsed_counter</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>不难看出 x86 对应 JVM 获取时间的方式是通过调用 Rdtsc::elapsed_counter() 函数获取，而非 x86 操作系统对应的 JVM 获取时间的方式是通过调用 os::elapsed_counter() 函数实现的。</p><p>os::elapsed_counter()函数最终依赖的是操作系统库函数的 clock_gettime 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/os/linux/os_linux.cpp</span><br><span class="hljs-function">jlong <span class="hljs-title">os::elapsed_counter</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">javaTimeNanos</span>() - initial_time_count;<br>&#125;<br><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/os/linux/os_linux.cpp</span><br><span class="hljs-function">jlong <span class="hljs-title">os::javaTimeNanos</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//return Linux::_clock_gettime != NULL;</span><br>  <span class="hljs-keyword">if</span> (os::<span class="hljs-built_in">supports_monotonic_clock</span>()) &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> tp;<br>    <span class="hljs-type">int</span> status = Linux::<span class="hljs-built_in">clock_gettime</span>(CLOCK_MONOTONIC, &amp;tp);<br>    jlong result = <span class="hljs-built_in">jlong</span>(tp.tv_sec) * (<span class="hljs-number">1000</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>) + <span class="hljs-built_in">jlong</span>(tp.tv_nsec);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/os/linux/os_linux.hpp</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-built_in">clock_gettime</span>(<span class="hljs-type">clockid_t</span> clock_id, <span class="hljs-keyword">struct</span> timespec *tp) &#123;<br><span class="hljs-keyword">return</span> _clock_gettime ? _clock_gettime(clock_id, tp) : <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/os/linux/os_linux.cpp</span><br><span class="hljs-type">void</span> os::Linux::<span class="hljs-built_in">clock_init</span>() &#123;<br>  <span class="hljs-type">void</span>* handle = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;librt.so.1&quot;</span>, RTLD_LAZY);<br>  <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">NULL</span>) &#123;<br>    handle = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;librt.so&quot;</span>, RTLD_LAZY);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (handle) &#123;<br>    <span class="hljs-built_in">int</span> (*clock_getres_func)(<span class="hljs-type">clockid_t</span>, <span class="hljs-keyword">struct</span> timespec*) =<br>           (<span class="hljs-built_in">int</span>(*)(<span class="hljs-type">clockid_t</span>, <span class="hljs-keyword">struct</span> timespec*))<span class="hljs-built_in">dlsym</span>(handle, <span class="hljs-string">&quot;clock_getres&quot;</span>);<br>    <span class="hljs-built_in">int</span> (*clock_gettime_func)(<span class="hljs-type">clockid_t</span>, <span class="hljs-keyword">struct</span> timespec*) =<br>           (<span class="hljs-built_in">int</span>(*)(<span class="hljs-type">clockid_t</span>, <span class="hljs-keyword">struct</span> timespec*))<span class="hljs-built_in">dlsym</span>(handle, <span class="hljs-string">&quot;clock_gettime&quot;</span>);<br>    <span class="hljs-keyword">if</span> (clock_getres_func &amp;&amp; clock_gettime_func) &#123;<br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> res;<br>      <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> tp;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">clock_getres_func</span> (CLOCK_MONOTONIC, &amp;res) == <span class="hljs-number">0</span> &amp;&amp;<br>          <span class="hljs-built_in">clock_gettime_func</span>(CLOCK_MONOTONIC, &amp;tp)  == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// yes, monotonic clock is supported</span><br>        _clock_gettime = clock_gettime_func;<br>        <span class="hljs-keyword">return</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// close librt if there is no monotonic clock</span><br>        <span class="hljs-built_in">dlclose</span>(handle);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> x86 对应 JVM 的 Rdtsc::elapsed_counter() 函数最终通过指令 __rdtsc获取时间周期数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/cpu/x86/rdtsc_x86.cpp</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Rdtsc::initialize</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">bool</span> initialized = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">if</span> (!initialized) &#123;<br>     VM_Version_Ext::<span class="hljs-built_in">initialize</span>();<br>    <span class="hljs-type">bool</span> result = <span class="hljs-built_in">initialize_elapsed_counter</span>(); <span class="hljs-comment">// init hw</span><br>    <span class="hljs-keyword">if</span> (result) &#123;<br>      result = <span class="hljs-built_in">ergonomics</span>(); <span class="hljs-comment">// check logical state</span><br>    &#125;<br>    rdtsc_elapsed_counter_enabled = result;<br>    initialized = <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> rdtsc_elapsed_counter_enabled;<br>&#125;<br><br><span class="hljs-function">jlong <span class="hljs-title">Rdtsc::elapsed_counter</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> os::<span class="hljs-built_in">rdtsc</span>() - _epoch;<br>&#125;<br><span class="hljs-comment">//bishengjdk-11-mirror/src/hotspot/os_cpu/linux_x86/os_linux_x86.inline.hpp</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> jlong <span class="hljs-title">os::rdtsc</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> AMD64</span><br>  <span class="hljs-comment">// 64 bit result in edx:eax</span><br>  <span class="hljs-type">uint64_t</span> res;<br>  __asm__ __volatile__ (<span class="hljs-string">&quot;rdtsc&quot;</span> : <span class="hljs-string">&quot;=A&quot;</span> (res));<br>  <span class="hljs-keyword">return</span> (jlong)res;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">uint64_t</span> res;<br>  <span class="hljs-type">uint32_t</span> ts1, ts2;<br>  __asm__ __volatile__ (<span class="hljs-string">&quot;rdtsc&quot;</span> : <span class="hljs-string">&quot;=a&quot;</span> (ts1), <span class="hljs-string">&quot;=d&quot;</span> (ts2));<br>  res = ((<span class="hljs-type">uint64_t</span>)ts1 | (<span class="hljs-type">uint64_t</span>)ts2 &lt;&lt; <span class="hljs-number">32</span>);<br>  <span class="hljs-keyword">return</span> (jlong)res;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// AMD64</span></span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Hotspot</tag>
      
      <tag>Java</tag>
      
      <tag>JDK Flight Recorder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JFR概述</title>
    <link href="/2023/05/12/JFR%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/05/12/JFR%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JFR-简述"><a href="#JFR-简述" class="headerlink" title="JFR 简述"></a>JFR 简述</h1><p>JDK Flight Recorder ( JDK 飞行记录器, JFR ) 是内置于 JVM 中的用于提供时间分析和诊断的引擎。JDK Mission Control ( JDK 任务控制, JMC ) 是用于查看 JFR 生成的记录的客户端工具。<span id="more"></span></p><p>基于 <a href="#references">OpenJDK wiki</a> 中关于 JFR 的介绍可知，JFR 内置于 JVM 中用于记录 JVM 运行过程中若干行为事件的相关数据，具有以下功能：</p><ul><li>更快地解决程序问题</li><li>查找应用程序中的瓶颈</li><li>查找 ISV 提供的应用程序中的瓶颈</li></ul><p>JFR 与其他类似工具对比，JFR具有以下关键特点：</p><ul><li>极低的开销<ul><li>JFR 由开发 JVM 的人构建到 JVM &#x2F; JDK 中</li><li>高性能飞行记录引擎和高性能数据收集<br>  （时间戳基于固定的 Time Stamp Counter (TSC)，线程本地本机缓冲区( thread local native buffers )，访问运行时中已收集的数据，更准确的方法分析（分析方法的数据甚至有来自外部安全点的），更快、更准确的分配分析）</li></ul></li><li>安全可靠<ul><li>作为 JVM&#x2F;JDK 测试的一部分，在所有平台上进行了测试</li><li>低开销意味着对正在运行的应用程序影响很小</li></ul></li><li>低开销 + 可靠性 &#x3D; 始终开启<ul><li>在出现问题时转储记录数据，并查看问题发生之前、放生时和发生之后的运行时在做什么</li><li>即使在 JVM 进程崩溃时，过去几分钟的飞行记录数据也会在转储中以便解决问题</li></ul></li></ul><h1 id="JFR-基本原理"><a href="#JFR-基本原理" class="headerlink" title="JFR 基本原理"></a>JFR 基本原理</h1><h2 id="JFR-的生命周期"><a href="#JFR-的生命周期" class="headerlink" title="JFR 的生命周期"></a>JFR 的生命周期</h2><p>博客<a href="#references">通过 JFR 与日志深入探索 JVM - 2. JFR 基本原理以及快慢因素</a>描述了如下的JFR记录过程<br><img src="/img/JFR%E6%A6%82%E8%BF%B0/JFR_record.png" alt="JFR 记录"><br>JFR 记录开始：每个 JVM 进程可以同时启用多个 JFR 记录采集，可以在 JVM 启动的时候利用 JVM 启动参数启用 JFR 记录，也可以通过<code>jcmd</code>动态开启 JFR 记录采集，也可以在程序内通过代码开启采集。</p><p>JFR 记录结束：可以启动时指定在采集多久后结束，也可以通过jcmd动态关闭 JFR 记录采集，也可以在程序内通过代码结束采集。在结束时，可以指定让 JFR 记录 dump 到一个文件中。JFR 记录也会随着 JVM 的结束而结束。</p><p>JFR 记录分析：可以随时通过 jcmd 动态将 JFR 记录 dump 到一个文件中，或者通过代码程序中执行 dump，进行后续分析。注意 dump 并不会结束一个 JFR 记录，并且 dump 最多只能 dump 出上次 dump 到现在的所有记录。</p><p>JFR 记录实时分析：可以通过 JFR Stream 实现对于 JFR 记录的实时消费与处理。</p><h2 id="JFR-的记录对象-——-event"><a href="#JFR-的记录对象-——-event" class="headerlink" title="JFR 的记录对象 —— event"></a>JFR 的记录对象 —— event</h2><p>在 JFR 记录中，以事件(Event)为记录单位，每个 Event 记录特定粒度的 JVM 行为。</p><p>例如：类加载是一个 Event，对应 ClassLoad Event ，开始进入安全点是一个 Event，对应 SafepointBegin Event 等等。根据 oracle 网站提供的<a href="#references">JDK Mission Control User Guide</a>给出的分类如下：</p><ul><li>持续时间事件（Duration events）：在特定持续时间内发生，具有特定的开始时间和停止时间。例如有 GC 发生的时候的 GC Event</li><li>即时事件（Instant events）：立即发生并立即记录，例如，线程被阻塞。</li><li>示例事件（Sample events）：定期发生（按照一定的频率采集）以检查系统的整体运行状况。例如，每分钟打印一次堆诊断。</li><li>自定义事件（Custom events）：使用 JMC 或 API 创建的用户定义事件。</li></ul><p>按照事件类型，以 JDK11 为例，可以将 Event 分为 5 大类:</p><table><thead><tr><th align="center">Event 类型</th><th align="center">该类 Event 对应 JVM 行为</th><th align="center">补充描述</th></tr></thead><tbody><tr><td align="center">Flight Recorder</td><td align="center">JFR记录监控</td><td align="center">包括：JFR数据丢失、开始记录、配置、记录原因等信息</td></tr><tr><td align="center">Java Application</td><td align="center">Java应用监控</td><td align="center">包括：锁与同步、文件IO、网络IO、Java异常与错误、类加载、TLAB分配统计 等信息</td></tr><tr><td align="center">Java Development Kit</td><td align="center">JDK信息</td><td align="center">包括：安全检查、X509证书及验证等信息</td></tr><tr><td align="center">Java Virtual Machine</td><td align="center">JVM信息</td><td align="center">包括：类加载、代码高速缓存、JVM配置运行信息、运行时（安全点、模块化操作）、GC、编译、方法堆栈、偏向锁等信息</td></tr><tr><td align="center">Operating System</td><td align="center">操作系统信息</td><td align="center">包括：内存、网络利用率、线程、CPU占用等信息</td></tr></tbody></table><p>这些 Event 在某些特定的时间点或者特定的场景下产生，每个 Event 都由 <code>Event 类型</code>，<code>开始时间</code>，<code>结束时间</code>，<code>发生事件的线程</code>，<code>事件发生的线程堆栈</code>还有 <code>Event 数据体</code>组成。</p><p>当 JFR 开启记录时，不会在事件发生时立即将其写入磁盘。相反，Event 会先将数据存储到自己的线程 JFR 缓冲（Thread Buffer）中；然后在这个 Buffer 满了之后，会将 Buffer 的内容刷入全局 JFR 缓冲（Global Buffer ）中；当 Global Buffer 存储到达上限之后，根据配置选择丢弃或者写入磁盘。数据存储到本地线程 JFR 缓冲这一操作，消除了对每个事件在线程之间进行同步的需要，从而提高了吞吐量。当程本地缓冲区被填满，将数据传输到全局缓冲区这种情况发生时，线程之间需要同步，但是由于不同的线程本地缓冲区以不同的速率填充，因此很少发生争用。JFR 在写入磁盘时通过写入格式紧凑二进制格式文件，增强应用程序的读写。</p><p>也可以配置 JFR，使其不向磁盘写入任何数据。在这种模式下，全局缓冲区充当循环缓冲区，当缓冲区满时，将删除最旧的数据。这种情况下全局缓冲区中永远保存最新的数据，当操作或监视系统检测到问题时，再根据需要将信息写入磁盘。</p><h2 id="JFR-event-基础信息采集"><a href="#JFR-event-基础信息采集" class="headerlink" title="JFR event 基础信息采集"></a>JFR event 基础信息采集</h2><p>已知 Event 由 <code>Event 类型</code>，<code>开始时间</code>，<code>结束时间</code>，<code>发生事件的线程</code>，<code>事件发生的线程堆栈</code>还有 <code>Event 数据体</code>组成。</p><p>其中 <code>Event 类型</code> 由 Event 自身确定。<code>开始时间</code> 与 <code>结束时间</code> 在支持 Read Time-Stamp Counter (RDTSC)的x86架构上，通过RDTSC获取时间值；在其他（除x86）架构，通过操作系统 OS 时钟获取时间值（接口为 time.h 的 clock_gettime 函数）。由于Java可用多个时钟可能带来的时钟漂移可以参考文章<a href="#references">How to Tell Time in Java’s Garbage Collection</a></p><p>由于 Event 是由事件发生线程各自记录，所以 Event 的 <code>发生事件的线程</code> 信息通过 <code>Thread::current()</code> 方法直接获取。同时，在获取到当前线程后先判断是否为 Java 线程，再通过构造 vframeStream 遍历获取<code>事件发生的线程堆栈</code>（当开启 OldObjectSample 事件分析时，会追踪内存泄漏，此时会额外在线程 buffer 处记录堆栈。这种情况下堆栈的获取不需要遍历）</p><p>最后<code>Event 数据体</code>中会记录与关注 Event 相关的信息，这部分信息可以通过读取 JVM 行为产生的变量数据直接获取。这部分数据及数据的描述（除Java Development Kit相关的 Event 信息）都可以在<code>metadata.xml</code>中获取</p><p>以 <code>EventThreadSleep</code> 为例，<code>metadata.xml</code>中的描述如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Event</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ThreadSleep&quot;</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;Java Application&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Java Thread Sleep&quot;</span> <span class="hljs-attr">thread</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">stackTrace</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Field</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;long&quot;</span> <span class="hljs-attr">contentType</span>=<span class="hljs-string">&quot;millis&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;time&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Sleep Time&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Event</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最终通过JMC打开查看可以得到如下信息（JMC作为单独的项目，会在后续文章中进行介绍）<br><img src="/img/JFR%E6%A6%82%E8%BF%B0/EventThreadSleep.png" alt="EventThreadSleep"></p><p>可以很清晰地看出<code>EventThreadSleep</code>记录了 <code>Event 类型</code>，<code>开始时间</code>，<code>结束时间</code>（作差即持续时间），<code>发生事件的线程</code>，<code>事件发生的线程堆栈</code>还有 <code>Event 数据体</code>（ Sleep Time ）这几项。</p><h1 id="JMC-分析-JFR"><a href="#JMC-分析-JFR" class="headerlink" title="JMC 分析 JFR"></a>JMC 分析 JFR</h1><p>JDK Mission Control (JMC)是一套用于管理、监视、分析和故障排除 Java 应用程序的高级工具。JMC 支持对代码性能、内存和延迟等领域进行高效和详细的数据分析，而不会引入通常与分析和监视工具相关的性能开销。随着发展 JMC 已发展成为应用程序故障排除的一站式商店，它现在（插件形式）集成了许多其他 Java 性能监控实用程序和 Java 虚拟机 (JVM) 调整工具。主要包括：用于托管各种有用的Java工具的框架，用于可视化Java飞行记录内容以及内容自动分析结果的工具，JMX 控制台，堆废物分析工具。</p><h2 id="自动结果分析页"><a href="#自动结果分析页" class="headerlink" title="自动结果分析页"></a>自动结果分析页</h2><p>JMC 从 JFR 记录中提取并分析数据，然后在“自动分析结果”页上显示彩色编码的报告日志，界面如下：</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/%E8%87%AA%E5%8A%A8%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90.png" alt="自动结果分析页面"></p><p>问题主要分为以下三个方面呈现：</p><ul><li>Java Application —— Java 应用程序</li><li>JVM internal —— JVM 内部</li><li>Environment —— 环境</li></ul><p>这三块也对应 Outline 视图中的三个大类，还有额外的一类 Event Browser 这一块存储了所有 JFR 采集到的单独事件信息。针对每一个得分可以通过点击 <code>+</code> 符号下拉获取 JMC 针对某个分数的分析，如下</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/%E5%88%86%E6%95%B0%E5%88%86%E6%9E%90.png" alt="分数分析"></p><p>默认情况下，只显示黄色和红色分数的结果即可能是潜在问题的点。一共四种颜色，灰色 <code>Not Applicable</code> 绿色 <code>OK</code> 黄色 <code>Information</code> 红色 <code>Warning</code>，状态依次从未使用到警告事项。可以通过页面右上角<code>OK</code>按钮查看每一类包括的所以得分；也可以通过 <code>Table</code> 按钮，查看 JMC 计算的所有分数信息，如下</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/score.png" alt="所有得分"></p><p>Table 页面展示了所有的 result 的 score,name,ID,Page ，其中 score 为严重性得分，Page 为该项结果产生依赖的数据页面，对应 Outline 视图下三大分类下的页面，如下</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/page-result.png"></p><p>可以通过双击条目直接去往产生结果的页面。</p><h2 id="Java-应用程序-分析"><a href="#Java-应用程序-分析" class="headerlink" title="Java 应用程序 分析"></a>Java 应用程序 分析</h2><p>Java 应用程序页面显示 Java 应用程序的整体健康状况。需要注意可以在 JMC 工具的 Window -&gt; show view -&gt; Results ，通过这种方式附加显示结果信息。这部分结果信息对应自动结果分析页面展示的 Java 应用程序 类的结果，如下图展示</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90.png" alt="Java 应用程序分析"></p><p>其中红色方框内为这一页计算出的结果，与自动结果分析页面中结果对应。红框内的结果分析依据与当前页面内提供的信息对应印证。</p><p>分析页的上半部分是文字形式的线程信息，下半部分为图形界面。图形界面中展示了：中断信息、整体的 CPU 利用率（分机器整体 和 JVM+应用）、堆使用情况、方法概要分析、分配情况、异常抛出信息和活跃线程。当单独选中某一&#x2F;几个线程时，整体信息会聚焦在某一线程上（CPU 利用率、堆使用情况依旧为全局状态，不做改变），可以通过鼠标悬停获得额外信息</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/%E6%82%AC%E5%81%9C.png"></p><p>对于本文给出的 jfr 文件中的结果可以如下图寻找印证现象</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/%E7%BB%93%E6%9E%9C%E5%AF%B9%E7%85%A7.png"></p><p>通过选中 halt 中断信息，找到持续中断时间片最长的，查看对应线程和 VM Operation 可以定位到产生中断的事件是 JFR 本身，结果与分析情况一致。在图中其他的中断可以留给读者自行分析（多数情况为 GC ）。</p><h3 id="Threads-页"><a href="#Threads-页" class="headerlink" title="Threads 页"></a>Threads 页</h3><p>“线程”页面提供属于 Java 应用程序的所有线程的快照。它揭示了有关应用程序的线程活动的信息，这些信息可以用于诊断问题并优化应用程序和 JVM 性能。线程在一个表中表示，每一行都有一个关联的图形，图形用于识别有问题的执行模式，它提供了关注区域的上下文信息。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/thread.png" alt="Threads 页面"></p><p>如图中所示，图中展示了线程运行的状态，页面不与任何结果关联。当前页面还存在下拉页，但不具有更多有意义信息，故不再赘述。</p><p>可以通过页面给的 <code>Thread State Selection</code> 选项个性化定制在当前页面显示的 <code>Event</code> 如下</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/TSS.png"></p><p>当选中线程和时刻后可以在页面中分析当前时刻的线程堆栈（当打开 jfr 堆栈跟踪后可见）如下</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/StackTrace.png"></p><h3 id="Memmory-页"><a href="#Memmory-页" class="headerlink" title="Memmory 页"></a>Memmory 页</h3><p>检测 Java 应用程序性能问题的另一种方法是查看它在运行时如何使用内存。在 Memory 页面中，下图表示 Java 应用程序的堆内存使用情况。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/Memory.png"></p><p>每个周期由一个 Java 堆增长阶段组成，该阶段表示堆内存分配的周期，随后是一个表示垃圾收集的短暂下拉，然后循环重新开始。从图中可以得出的重要推论是，内存分配是短期的，因为垃圾收集器在每个周期都会将堆推到开始位置。选中 <code>Garbage Collection</code> 复选框，可以在图中查看垃圾收集的暂停时间。它表示垃圾收集器在暂停期间停止 Java 应用程序来完成垃圾收集。一般长暂停时间会导致 Java 应用程序性能较差。</p><p>与 Memory 页面对应的 Results 分析可以在 Results 页面查看。上图中有一个红色的警告结果分析为物理内存偏小，这一点可以通过看 <code>Used size</code> 和 <code>Total size</code> 得出。但是需要注意的是自动分析结果只能程序化地得出一些结论，只能作为参考，真实原因可能不在现象处。</p><p>上图中很多结果没有分数是因为在 JFR 记录中没有打开相应的 Event 记录。</p><h3 id="Method-Profiling-页"><a href="#Method-Profiling-页" class="headerlink" title="Method Profiling 页"></a>Method Profiling 页</h3><p>“方法分析”页用于查看特定方法的运行频率以及运行方法所需的时间。通过识别执行时间过长的方法来确定方法瓶颈。</p><p>由于分析会生成大量数据，因此默认情况下不会打开。通过验证堆栈跟踪中的详细信息、检查代码、验证内存分配是否集中在特定对象上的方式，JFR 找到特定行号的特定问题并输出为结果。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/MethodProfiling.png" alt="Method Profiling 页面"></p><p>上图中自动分析结果信息显示占用CPU最多的方法为 <code>void org.spec.jbb.core.collections.HashMultiSet.update(Object, int)</code> 这一点从方法部分无法准确感知，但是通过分析多个方法堆栈能够得出，<code>update</code> 方法的占用确实是最高的。方法分析页面的数据来源是 ExecutionSample 事件，是通过周期线程堆栈的方式搜集方法频次。</p><h3 id="其他页面"><a href="#其他页面" class="headerlink" title="其他页面"></a>其他页面</h3><p>除了上述比较重要的页面，Java 应用程序分析还包括：锁实例页面、File I&#x2F;O、Socket I&#x2F;O、Exceptions、Thread Dumps</p><p>其中，锁实例页面提供有关指定锁信息（额外显示监视类、统计独立线程数与争用总次数）的线程的详细信息，即线程是否尝试获取锁或等待锁上的通知。如果线程已经采用任何锁，那么会在堆栈跟踪中显示详细信息。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/lock.png" alt="lock instance 页面"></p><p>File I&#x2F;O、Socket I&#x2F;O用于检测文件和 socket 的读写持续时间，将记录持续读写时间超过阈值的记录，同时可以选择记录堆栈。Exceptions 用于记录测试过程中抛出的异常和警告信息。这部分页面与其对应的结果分析方式类似之前的页面，同时都需要在 JFR 中指定打开对应的事件采集。</p><p>Thread Dumps 页面对应线程转储事件，这里包括某一时刻的所有线程堆栈信息，可以用于细节分析线程阻塞等问题。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/ThreadDump.png" alt="Thread Dumps 页面"></p><h2 id="JVM-Internals-分析"><a href="#JVM-Internals-分析" class="headerlink" title="JVM Internals 分析"></a>JVM Internals 分析</h2><p>“JVM内部”页面提供了有关 JVM 传入参数、默认 flags 值的信息。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/JVMInternals.png" alt="JVM Internals 页面"></p><p>针对参数的不合理设置会给出结果分析。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>JVM Internals 一块最重要参数之一是 <code>Garbage Collections</code> 垃圾收集。垃圾收集是一个删除未使用对象的过程，这样空间就可以用于分配新对象。垃圾收集相关的信息通过三页来展示，分别为垃圾收集详细信息、垃圾收集配置信息、垃圾收集汇总信息。</p><h4 id="GC-Summary"><a href="#GC-Summary" class="headerlink" title="GC Summary"></a>GC Summary</h4><p>界面如下图所示：</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/GCSummary.png" alt="JVM Internals 页面"></p><p>GC Summary 页面不与任何结果先关联，分块输出不同对象类型垃圾收集的信息，包括 GC 次数、平均 GC 时间、最大 GC 时间和总 GC 时间。需要用户根据经验判断 GC 是否存在问题。</p><h4 id="GC-Configuration"><a href="#GC-Configuration" class="headerlink" title="GC Configuration"></a>GC Configuration</h4><p>界面如下图所示：</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/GCConfiguration.png" alt="JVM Internals 页面"></p><p>GC Configuration 页面只关联是否使用压缩指针这一结果，主页面输出垃圾收集配置信息、Flags、堆配置信息、年轻代配置信息。这些配置信息展现了 JVM 运行过程中的真实信息，辅助用户作出调整。</p><h4 id="Garbage-Collections"><a href="#Garbage-Collections" class="headerlink" title="Garbage Collections"></a>Garbage Collections</h4><p>Garbage Collections 页保有垃圾收集相关的细节信息，通过图的方式展现。这些图表显示了堆使用情况与（最长、平均、总和）暂停时间的比较以及在指定时间段内的变化情况。这一页还列出了记录过程中发生的所有垃圾回收事件。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/GC.png" alt="GC 页面"></p><p>安装用户手册的提示，观察堆上最长的停顿时间，如果在应用程序运行期间暂停时间越来越长，则表明垃圾收集释放的堆空间在变少。这种情况说明可能存在内存泄漏情况。</p><h3 id="Compilations-页"><a href="#Compilations-页" class="headerlink" title="Compilations 页"></a>Compilations 页</h3><p>“编译”页提供了有关代码编译以及编译持续时间、代码大小、内敛代码大小的详细信息。柱状图按编译时间统计了方法数，有利于精准定位编译耗时较长的方法。下表还可以切换为编译失败的方法，此处不做展示。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/compile.png" alt="Compilations 页面"></p><p>在大型应用程序中，可能有许多已编译的方法，并且可能会耗尽内存，从而导致性能问题。通过 Compilations 页可以获取相关信息</p><h3 id="Class-Loading-页"><a href="#Class-Loading-页" class="headerlink" title="Class Loading 页"></a>Class Loading 页</h3><p>“类加载”页图部分显示随时间类加载与类卸载的统计情况。下表中展示的是具体相关的类加载器、初始类加载器、类加载线程与类加载持续时间。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/classload.png" alt="Class Loading 页"></p><p>结果分析对应类加载压力与类泄露两个得分，需要开启相关事件记录才能获取得分。</p><h3 id="VM-Operations-页"><a href="#VM-Operations-页" class="headerlink" title="VM Operations 页"></a>VM Operations 页</h3><p>VM 操作页面统计以 VM 操作为单位的信息，上表信息包括统计时间段内的触发次数、暂停时间、总持续时间、最长持续时间。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/VMO.png" alt="VM Operations 页面"></p><p>通过选中单个 VM Operation 可以分别查看三张图表：根据时间线查看当前操作的持续时间、根据持续时间统计持续时间范围内的操作个数、所有时间组成的表。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/VMOtimeline.png"><img src="/img/JFR%E6%A6%82%E8%BF%B0/VMOduration.png"><img src="/img/JFR%E6%A6%82%E8%BF%B0/VMOeventlog.png"></p><h3 id="TLAB-Allocations"><a href="#TLAB-Allocations" class="headerlink" title="TLAB Allocations"></a>TLAB Allocations</h3><p>当开始分析 TLAB 相关功能时可以先进入 summary 标签页查看一些汇总信息，分 TLAB 内&#x2F;外 统计包括：</p><ul><li>新建 TLAB 计数</li><li>最大 TLAB 大小</li><li>最小 TLAB 大小</li><li>平均 TLAB 大小</li><li>TLAB 总大小的估计值</li></ul><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/TLABsummary.png" alt="TLAB Allocations summary"></p><p>当具体分析 TLAB 时，可以根据不同情况选择 By Thread &#x2F; Top Method &#x2F; Class 三种情况分析</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/TLABThread.png" alt="By Thread"></p><p>当选中不同情况时只会改变上表中第一列的属性，再重新统计表格。以 By Thread 为例，表中后续列分别为</p><ul><li>某个 Thread &#x2F; Method &#x2F; Class 在 TLAB 内申请的大小</li><li>某个 Thread &#x2F; Method &#x2F; Class 在 TLAB 内申请的大小在本次统计到的TLAB 内申请的大小的占比</li><li>某个 Thread &#x2F; Method &#x2F; Class 在 TLAB 外申请的大小</li><li>某个 Thread &#x2F; Method &#x2F; Class 在 TLAB 外申请的大小在本次统计到的TLAB 外申请的大小的占比</li></ul><p>下半部分图显示的是：某一时间段内，JVM在 TLAB 内&#x2F;外 申请的空间大小</p><h2 id="Environment-分析"><a href="#Environment-分析" class="headerlink" title="Environment 分析"></a>Environment 分析</h2><p>“环境”页面统计的是当前 JAVA 应用程序运行的环境信息，包括 CPU 类型、核心数量、硬件线程数、插槽数、CPU 说明、可用内存、操作系统版本</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/Environment.png" alt="Environment 页面"></p><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p>Processes “进程”页统计正在运行的并发进程以及这些进程的竞争 CPU 情况。如果许多进程使用 CPU 和其他系统资源，将影响被测试应用程序的性能。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/Processes.png" alt="Processes 页面"></p><p>如页面中所示，上半部分为图，分别是</p><ul><li>随时间的 CPU 占用率图（机器总 CPU 占用、JVM+应用程序占用、JVM+应用程序（内核）占用）</li><li>随时间的并发进程图</li></ul><p>下半部分是记录某一时刻的进程信息表，包括进程号、指令、（第一&#x2F;最后）取样时间</p><p>系统信息还包括以下3页：</p><ul><li>Environment Variables “环境变量”页顾名思义统计机器的环境变量</li><li>Native Libraries “本地库”页存储的是本地库的 首地址 与 基地址</li><li>System Properties “系统属性页”记录 Java 系统信息包括如下</li></ul><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/SystemProperties.png" alt="System Properties 键"></p><h3 id="Recording-页"><a href="#Recording-页" class="headerlink" title="Recording 页"></a>Recording 页</h3><p>Recording “记录”页记录了本次 JFR 测试的相关信息，如下：</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/Recording.png" alt="Recording 页面"></p><p>呈现的信息包括 JFR 开启时间、结束时间、事件总数、记录时间长度、事件开启的个数。以及在页面最下方的表中记录了开启记录的事件配置信息。</p><h2 id="Event-Browser"><a href="#Event-Browser" class="headerlink" title="Event Browser"></a>Event Browser</h2><p>Event Browser “事件浏览器”页面用于查看所有 JFR Event 事件类型的统计信息。可以使用“事件浏览器”页创建自定义页。从 Event Type Tree 中选择所需的事件类型，然后使用页面右上角的 Select Event Type 按钮单击 Create a new page。自定义页在事件浏览器页下列为新的事件页</p><h1 id="JFR-JMC-调优分析"><a href="#JFR-JMC-调优分析" class="headerlink" title="JFR + JMC 调优分析"></a>JFR + JMC 调优分析</h1><p>无论是 JVM 的调优过程还是应用程序的调优过程，首先需要做的是性能瓶颈的定位。两者的区别在于性能瓶颈的产生位置不同，其中大多数情况下 JMC 分析的直接结果能够由于指导应用程序的问题寻找；而调优 JVM 则需要进一步根据 JFR 的 Event 测试区间定位问题细节。我们首先来分析 JMC 给出的有用信息</p><p>首先在测试平台上稳定运行应用程序，通过 jcmd 命令获取应用程序进程号，开启 JFR 测试并输出 jfr 文件。使用 JMC 离线打开 jfr 文件，首先查看如下页面自动分析页面：</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/eg1AAR.png" alt="案例结果自动分析 页面"></p><p>通过自动分析页面的结果和结果分析可以看出，当前应用程序的瓶颈可能出在 4 个黄色 information 级别的模块上。<br>首先分析严重程度最高的 Context Switches 问题上，根据分析文字可以得知应用程序的问题可能出在锁的争用上。 点击 Table 按钮切换到 Table 视图，可以得知 Context Switches 问题的产生是通过分析 Lock Instances 页面得出的。</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/CSLock.png"></p><p>我们需要切换到 Lock Instances 页面:</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/egLI.png" alt="案例 Lock Instances 页面"></p><p>通过页面分析确实可以看出应用程序对 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">com.sun.xml.bind.v2.runtime.JAXBContextImpl<br></code></pre></td></tr></table></figure><p>的争用很多，且导致了很高的总停顿时间，怀疑这里是性能的瓶颈。打开堆栈视图，针对 Monitor Class 分析函数调用情况</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/egST.png"></p><p>可以看出最终调用的是函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Encoded[] com.sun.xml.bind.v2.runtime.JAXBContextImpl.getUTF8NameTable()<br><br><span class="hljs-comment">//bishengjdk-8/jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/JAXBContextImpl.java</span><br><span class="hljs-comment">//not in openjdk11</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Encoded[] getUTF8NameTable() &#123;<br>        <span class="hljs-keyword">if</span>(utf8nameTable==<span class="hljs-literal">null</span>) &#123;<br>            Encoded[] x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Encoded</span>[nameList.localNames.length];<br>            <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;x.length; i++ ) &#123;<br>                <span class="hljs-type">Encoded</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Encoded</span>(nameList.localNames[i]);<br>                e.compact();<br>                x[i] = e;<br>            &#125;<br>            utf8nameTable = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> utf8nameTable;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以得到的结论是，getUTF8NameTable() 同步函数导致了严重的锁争用情况，从而导致了线程的等待性能的下降。<br>查看 Properities 视图如下</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/Properties.png"></p><p>从图中能够得知，Lock Instances 页面的 Monitor Class 信息来源是 JFR 的 Java Monitor Blocked 事件记录的。将视图切换到 Event Browser 页面的 Java Monitor Blocked 项如下</p><p><img src="/img/JFR%E6%A6%82%E8%BF%B0/egEB.png" alt="案例 Event Browser 页面"></p><p>基于 JMC + JFR 的信息分析到此为止，作为应用程序的开发人员可以基于此处给出的函数堆栈优化函数调用，当然也可能需要像 JVM 调优工作者一样再次将目光聚焦在 Java Monitor Blocked 的事件记录上。</p><p id="references"></p>   <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://wiki.openjdk.org/display/jmc/Overview">JFR Overview</a><br><a href="https://blog.csdn.net/zhxdick/article/details/111562928">通过 JFR 与日志深入探索 JVM - 2. JFR 基本原理以及快慢因素</a><br><a href="https://docs.oracle.com/en/java/java-components/jdk-mission-control/8/user-guide/index.html">JDK Mission Control User Guide</a><br><a href="https://docs.oracle.com/javacomponents/jmc-5-5/jfr-runtime-guide/toc.htm">Java Platform, Standard Edition Java Flight Recorder Runtime Guide</a><br><a href="https://devblogs.microsoft.com/java/how-to-tell-time-in-javas-garbage-collection/">How to Tell Time in Java’s Garbage Collection</a><br><a href="https://www.oracle.com/java/technologies/jdk-mission-control.html">Advanced Java Diagnostics and Monitoring Without Performance Overhead</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hotspot</tag>
      
      <tag>Java</tag>
      
      <tag>JDK Flight Recorder</tag>
      
      <tag>JDK Mission Control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C2编译match阶段</title>
    <link href="/2023/04/25/C2%E7%BC%96%E8%AF%91match%E9%98%B6%E6%AE%B5/"/>
    <url>/2023/04/25/C2%E7%BC%96%E8%AF%91match%E9%98%B6%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<p>本文主要分析C2编译器的指令选择原理，如有偏差，请指正。</p><span id="more"></span><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>ad文件是个 DSL（domain-specific language），描述了一个BURS匹配系统的匹配规则。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hotspot</tag>
      
      <tag>Java</tag>
      
      <tag>C2 match</tag>
      
      <tag>BRUS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Specjbb测试集分析</title>
    <link href="/2023/01/25/Specjbb%E6%B5%8B%E8%AF%95%E9%9B%86%E5%88%86%E6%9E%90/"/>
    <url>/2023/01/25/Specjbb%E6%B5%8B%E8%AF%95%E9%9B%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>specjbb2015</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hotspot源码分析(G1)——write_barrier</title>
    <link href="/2023/01/15/Hotspot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-G1-%E2%80%94%E2%80%94write-barrier/"/>
    <url>/2023/01/15/Hotspot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-G1-%E2%80%94%E2%80%94write-barrier/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将针对<a href="/2022/12/20/G1GC%E7%AE%97%E6%B3%95%E7%AF%87"> G1GC 算法篇</a>中提到的 write barrier 技术基于源码进行分析，如有偏差，请指正。<span id="more"></span></p><p>G1 SATB 与 Rset维护都会调用到 write-barrier （ SATB 采用 pre write-barrier 完成，维护 RSet 采用 post write-barrier 完成） mutator 在 write-barrier 中仅仅将要做的事推送到队列中，然后通过另外的线程取出队列中的信息批量完成剩余的动作。</p><p>本文将分析 write-barrier 在OpenJDK8源码中解释器与C2编译中的实现。</p><h1 id="write-barrier-在模板解释器的实现"><a href="#write-barrier-在模板解释器的实现" class="headerlink" title="write-barrier 在模板解释器的实现"></a>write-barrier 在模板解释器的实现</h1><p>在 G1GC 算法篇介绍两种 write-barrier 时提过， SATB 写屏障的目的是当并发标记时避免<code>漏标</code>，而维护的 Rset 记录的则是<code>跨界引用</code>。<code>漏标的产生</code>和<code>跨界引用的修改</code>根本原因都与对象的域被修改有关。查看如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况 1 ：假设 G1 正在并发标记，对象 t 作为根对象已经被标记（灰色），但是 t 引用的对象还没被标记</span><br><span class="hljs-comment">//情况 2 ：假设对象 young 和 t 分别在不同的 Region 中</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">young</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<span class="hljs-comment">//步骤 1</span><br>t.next = young;<span class="hljs-comment">//步骤 2</span><br><span class="hljs-comment">//上述两种情况都需要在步骤 2 完成前记录下相关信息</span><br></code></pre></td></tr></table></figure><p>例子转换成字节码的核心部分如下，字节码的阅读不作详细解答，可查阅相关文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">26241</span>] <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> WriteBarrierShow.xxx(jobject, jint)<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769225</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">new</span> <span class="hljs-number">2</span> &lt;Node&gt;<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769226</span>     <span class="hljs-number">3</span>  dup<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769227</span>     <span class="hljs-number">4</span>  iload_1<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769228</span>     <span class="hljs-number">5</span>  invokespecial <span class="hljs-number">3</span> &lt;Node.&lt;init&gt;(I)V&gt; <br><br><span class="hljs-comment">//... virtual void Node.&lt;init&gt;(jint)</span><br><br>[<span class="hljs-number">26241</span>] <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> WriteBarrierShow.xxx(jobject, jint)<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769236</span>     <span class="hljs-number">8</span>  astore_2<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769237</span>     <span class="hljs-number">9</span>  aload_0<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769238</span>    <span class="hljs-number">10</span>  aload_2<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769239</span>    <span class="hljs-number">11</span>  putfield <span class="hljs-number">4</span> &lt;Node.p/LNode;&gt; <br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769240</span>    <span class="hljs-number">14</span>  <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><p>当解释执行时，会通过字节码 putfield 实现步骤2 ，所以来看一下 putfield 在模板解释器中的实现： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TemplateTable::putfield</span><span class="hljs-params">(<span class="hljs-type">int</span> byte_no)</span> </span>&#123;<br>  <span class="hljs-built_in">putfield_or_static</span>(byte_no, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TemplateTable::putfield_or_static</span><span class="hljs-params">(<span class="hljs-type">int</span> byte_no, <span class="hljs-type">bool</span> is_static)</span> </span>&#123;<br>  <span class="hljs-built_in">transition</span>(vtos, vtos);<br>  <span class="hljs-comment">// ... 此处的 putfield 是将 object 放到域上，此处的 _tos_in（模板执行前的TosState）为 </span><br>  <span class="hljs-comment">// atos （object cached）相关知识栈顶缓存</span><br>  &#123;<br>    <span class="hljs-function">__ <span class="hljs-title">pop</span><span class="hljs-params">(atos)</span></span>;<br>    <span class="hljs-keyword">if</span> (!is_static) <span class="hljs-built_in">pop_and_check_object</span>(obj);<br>    <span class="hljs-comment">// Store into the field</span><br>    <span class="hljs-built_in">do_oop_store</span>(_masm, field, rax, _bs-&gt;<span class="hljs-built_in">kind</span>(), <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-function">__ <span class="hljs-title">jmp</span><span class="hljs-params">(Done)</span></span>;<br>  &#125;<br>  <span class="hljs-function">__ <span class="hljs-title">bind</span><span class="hljs-params">(notObj)</span></span>;<br>  <span class="hljs-function">__ <span class="hljs-title">cmpl</span><span class="hljs-params">(flags, itos)</span></span>;<br>  <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::notEqual, notInt)</span></span>;<br><span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>事实上字节码 aastore 字节码也会调用到 do_oop_store 函数，本文仅用 putfield 举例， do_oop_store 函数会将 oop （或 NULL ）存储在 obj 描述的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">do_oop_store</span><span class="hljs-params">(InterpreterMacroAssembler* _masm, Address obj, Register val, BarrierSet::Name barrier, <span class="hljs-type">bool</span> precise)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (barrier) &#123;<br>    <span class="hljs-comment">// -XX:+UseG1GC 此处只关心 G1GC 会调用到的部分</span><br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCT:<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCTLogging:<br>      &#123;<br>        <span class="hljs-function">__ <span class="hljs-title">g1_write_barrier_pre</span><span class="hljs-params">(rdx <span class="hljs-comment">/* obj */</span>, rbx <span class="hljs-comment">/* pre_val */</span>, r15_thread <span class="hljs-comment">/* thread */</span>,  r8  <span class="hljs-comment">/* tmp */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                val != noreg <span class="hljs-comment">/* tosca_live */</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">/* expand_call */</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (val == noreg) &#123;<br>          <span class="hljs-function">__ <span class="hljs-title">store_heap_oop_null</span><span class="hljs-params">(Address(rdx, <span class="hljs-number">0</span>))</span></span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// G1 barrier needs uncompressed oop for region cross check.</span><br>          Register new_val = val;<br>          <span class="hljs-keyword">if</span> (UseCompressedOops) &#123;<br>            new_val = rbx;<br>            <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(new_val, val)</span></span>;<br>          &#125;<br>          <span class="hljs-function">__ <span class="hljs-title">store_heap_oop</span><span class="hljs-params">(Address(rdx, <span class="hljs-number">0</span>), val)</span></span>;<br>          <span class="hljs-function">__ <span class="hljs-title">g1_write_barrier_post</span><span class="hljs-params">(rdx <span class="hljs-comment">/* store_adr */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   new_val <span class="hljs-comment">/* new_val */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   r15_thread <span class="hljs-comment">/* thread */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   r8 <span class="hljs-comment">/* tmp */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   rbx <span class="hljs-comment">/* tmp2 */</span>)</span></span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>排除压缩指针与其他选项匹配的 barrier 代码，不难看出，当开启 G1GC 时，会在 store_heap_oop(_null) 之前调用 g1_write_barrier_pre ，之后调用 g1_write_barrier_post 函数。</p><p id="g1_write_barrier_pre"></p>    <h2 id="g1-write-barrier-pre-在解释运行中的实现"><a href="#g1-write-barrier-pre-在解释运行中的实现" class="headerlink" title="g1_write_barrier_pre 在解释运行中的实现"></a>g1_write_barrier_pre 在解释运行中的实现</h2><p>回顾 G1GC 算法实现，SATB 专用写屏障的伪代码如下所示：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//对应JVM 在oop_store方法的赋值动作的前的pre-write barrier</span><br>def satb_write_barrier(field, newobj):<br>    <span class="hljs-keyword">if</span> <span class="hljs-symbol">$gc</span>_phase == GC_CONCURRENT_MARK:<br>        oldobj = *field<br>        <span class="hljs-keyword">if</span> oldobj != <span class="hljs-literal">Null</span>:<br>            enqueue(<span class="hljs-symbol">$curre</span>nt_thread.stab_local_queue, oldobj)<br><br>        *field = newobj<br></code></pre></td></tr></table></figure><p>在伪代码中不难看出 SATB 专用写屏障，通过在将新对象写入域之前记录原来域对象,并滞后标记的方式来避免漏标。<br>在 G1GC 算法篇介绍 SATB 时提过，首先会将 old 对象放到本地线程的 SATB 队列中，所以首先来看一下 JavaThread 类的以下两个属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/runtime/thread.hpp</span><br><br>  <span class="hljs-comment">// Support for G1 barriers</span><br><br>  ObjPtrQueue _satb_mark_queue;          <span class="hljs-comment">// Thread-local log for SATB barrier.</span><br>  <span class="hljs-comment">// Set of all such queues.</span><br>  <span class="hljs-type">static</span> SATBMarkQueueSet _satb_mark_queue_set;<br><br>  DirtyCardQueue _dirty_card_queue;      <span class="hljs-comment">// Thread-local log for dirty cards.</span><br>  <span class="hljs-comment">// Set of all such queues.</span><br>  <span class="hljs-type">static</span> DirtyCardQueueSet _dirty_card_queue_set;<br></code></pre></td></tr></table></figure><p>_satb_mark_queue 与 _dirty_card_queue 属于线程私有，当线程本地队列满了之后，会分别提交到全局的 _satb_mark_queue_set 与 _dirty_card_queue_set 交给 G1 线程批量处理。</p><p> ObjPtrQueue 的父类 class PtrQueue 具有如下属性与函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/gc_implementation/g1/ptrQueue.hpp</span><br>  <span class="hljs-comment">// Whether updates should be logged.</span><br>  <span class="hljs-type">bool</span> _active;<br><br>  <span class="hljs-comment">// The buffer.</span><br>  <span class="hljs-type">void</span>** _buf;<br>  <span class="hljs-comment">// The index at which an object was last enqueued.  Starts at &quot;_sz&quot;</span><br>  <span class="hljs-comment">// (indicating an empty buffer) and goes towards zero.</span><br>  <span class="hljs-type">size_t</span> _index;<br><br>    <span class="hljs-comment">// Enqueues the given &quot;obj&quot;.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!_active) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">enqueue_known_active</span>(ptr);<br>  &#125;<br></code></pre></td></tr></table></figure><p>注释很好理解，三个属性分别是是否活跃、buffer 地址与最后一个对象的末尾索引。其中 _index 属性为 0 时代表队列满了，具体处理在后文分析。<br>接下来看一下 g1_write_barrier_pre 的核心实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/cpu/x86/vm/macroAssembler_x86.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MacroAssembler::g1_write_barrier_pre</span><span class="hljs-params">(Register obj,         <span class="hljs-comment">//rdx /* obj */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          Register pre_val,     <span class="hljs-comment">//rbx /* pre_val */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          Register thread,      <span class="hljs-comment">//r15_thread /* thread */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          Register tmp,         <span class="hljs-comment">//r8  /* tmp */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">bool</span> tosca_live,      <span class="hljs-comment">//val != noreg /* tosca_live */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">bool</span> expand_call)</span> </span>&#123;   <span class="hljs-comment">//false /* expand_call */</span><br><br>  Label done;   <span class="hljs-comment">//跳转标签 done 完成</span><br>  Label runtime;  <span class="hljs-comment">//跳转标签 runtime</span><br><br>  <span class="hljs-comment">//static ByteSize satb_mark_queue_offset()  &#123; return byte_offset_of(JavaThread, _satb_mark_queue); &#125;</span><br>  <span class="hljs-comment">//通过类的函数获取 JavaThread 的 satb 相关信息</span><br>  <span class="hljs-function">Address <span class="hljs-title">in_progress</span><span class="hljs-params">(thread, in_bytes(JavaThread::satb_mark_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_active()))</span></span>;<br>  <span class="hljs-function">Address <span class="hljs-title">index</span><span class="hljs-params">(thread, in_bytes(JavaThread::satb_mark_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_index()))</span></span>;<br>  <span class="hljs-function">Address <span class="hljs-title">buffer</span><span class="hljs-params">(thread, in_bytes(JavaThread::satb_mark_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_buf()))</span></span>;<br><br><br>  <span class="hljs-comment">// Is marking active? 是否处于并发标记阶段？</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_bytes</span>(PtrQueue::<span class="hljs-built_in">byte_width_of_active</span>()) == <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-built_in">cmpl</span>(in_progress, <span class="hljs-number">0</span>);       <span class="hljs-comment">//比较 _active 是否为 0，0需要跳转到 done ，即不需要写屏障</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">cmpb</span>(in_progress, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// Do we need to load the previous value? 空对象不需要写屏障</span><br>  <span class="hljs-keyword">if</span> (obj != noreg) &#123;<br>    <span class="hljs-built_in">load_heap_oop</span>(pre_val, <span class="hljs-built_in">Address</span>(obj, <span class="hljs-number">0</span>));<br>  &#125;<br><br>  <span class="hljs-comment">// Is the previous value null?    比较 pre_val 是否为空，空也不需要写屏障，直接跳转到 done</span><br>  <span class="hljs-built_in">cmpptr</span>(pre_val, (<span class="hljs-type">int32_t</span>) NULL_WORD);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// Can we store original value in the thread&#x27;s buffer?</span><br>  <span class="hljs-comment">// Is index == 0?</span><br>  <span class="hljs-comment">// (The index field is typed as size_t.)</span><br><br>  <span class="hljs-built_in">movptr</span>(tmp, index);                   <span class="hljs-comment">// tmp := *index_adr</span><br>  <span class="hljs-built_in">cmpptr</span>(tmp, <span class="hljs-number">0</span>);                       <span class="hljs-comment">// tmp == 0?</span><br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, runtime);       <span class="hljs-comment">// If yes, goto runtime 比较 _index是否 0 。为 0 意味着当前线程的 </span><br>                                        <span class="hljs-comment">// satb 队列满了，此时需要通过运行时调用，交给其他线程处理，具体为跳转到 bind(runtime) 处 </span><br><br>  <span class="hljs-comment">// 计算 pre_val 的入队位置</span><br>  <span class="hljs-built_in">subptr</span>(tmp, wordSize);                <span class="hljs-comment">// tmp := tmp - wordSize  将 _index 减去 oopSize</span><br>  <span class="hljs-built_in">movptr</span>(index, tmp);                   <span class="hljs-comment">// *index_adr := tmp</span><br>  <span class="hljs-built_in">addptr</span>(tmp, buffer);                  <span class="hljs-comment">// tmp := tmp + *buffer_adr</span><br><br>  <span class="hljs-comment">// Record the previous value 将 pre_val 入队</span><br>  <span class="hljs-built_in">movptr</span>(<span class="hljs-built_in">Address</span>(tmp, <span class="hljs-number">0</span>), pre_val);<br>  <span class="hljs-built_in">jmp</span>(done);<br><br>  <span class="hljs-built_in">bind</span>(runtime);<br>  <span class="hljs-comment">// 运行时，最终会调用 SharedRuntime::g1_wb_pre ，这里会在运行时章节展开</span><br>  <span class="hljs-built_in">bind</span>(done);<br>&#125;<br></code></pre></td></tr></table></figure><p>不难发现，整体实现与伪代码类似，完成了对前值的入队。</p><h2 id="g1-write-barrier-post-在解释运行中的实现"><a href="#g1-write-barrier-post-在解释运行中的实现" class="headerlink" title="g1_write_barrier_post 在解释运行中的实现"></a>g1_write_barrier_post 在解释运行中的实现</h2><p>g1_write_barrier_post 的伪代码如下</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs smali">def evacuation_write_barrier(obj, field, newobj):<br> <span class="hljs-built_in"> check </span>= obj ^ newobj<br> <span class="hljs-built_in"> check </span>=<span class="hljs-built_in"> check </span>&gt;&gt; LOG_OF_HEAP_REGION_SIZE<br> <span class="hljs-built_in"> if </span>newobj == Null:<br>   <span class="hljs-built_in"> check </span>= 0<br> <span class="hljs-built_in"> if </span>check == 0:<br>   <span class="hljs-built_in"> return</span><br><span class="hljs-built_in"></span><br> <span class="hljs-built_in"> if </span>not is_dirty_card(obj):<br>    to_dirty(obj)<br>    enqueue($current_thread.rs_log, obj)<br><br>  *field = newobj<br></code></pre></td></tr></table></figure><p>过滤 obj 和 newobj 位于同一个区域，或者 newobj 为 Null 的时候， is_dirty_card() 用来检查参数 obj 所对应的卡片是否<br>为脏卡片。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MacroAssembler::g1_write_barrier_post</span><span class="hljs-params">(Register store_addr,     <span class="hljs-comment">// rdx /* store_adr */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register new_val,        <span class="hljs-comment">// new_val /* new_val */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register thread,         <span class="hljs-comment">// r15_thread /* thread */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register tmp,            <span class="hljs-comment">// r8 /* tmp */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register tmp2)</span> </span>&#123;         <span class="hljs-comment">// rbx /* tmp2 */</span><br><br>  <span class="hljs-comment">//此处获取 dirty_card 的 _index 与 _buf</span><br>  <span class="hljs-function">Address <span class="hljs-title">queue_index</span><span class="hljs-params">(thread, in_bytes(JavaThread::dirty_card_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_index()))</span></span>;<br>  <span class="hljs-function">Address <span class="hljs-title">buffer</span><span class="hljs-params">(thread, in_bytes(JavaThread::dirty_card_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_buf()))</span></span>;<br><br>  BarrierSet* bs = Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">barrier_set</span>();<br>  CardTableModRefBS* ct = (CardTableModRefBS*)bs;<br><br>  Label done;<br>  Label runtime;<br><br>  <span class="hljs-comment">// Does store cross heap regions? 只有跨界引用需要被记录</span><br><br>  <span class="hljs-built_in">movptr</span>(tmp, store_addr);<br>  <span class="hljs-built_in">xorptr</span>(tmp, new_val);<br>  <span class="hljs-built_in">shrptr</span>(tmp, HeapRegion::LogOfHRGrainBytes);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// crosses regions, storing NULL? Null 对象不需要被记录 Null 时跳转到 done</span><br><br>  <span class="hljs-built_in">cmpptr</span>(new_val, (<span class="hljs-type">int32_t</span>) NULL_WORD);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// storing region crossing non-NULL, is card already dirty? 已经脏的话，卡片不需要重复置脏</span><br><br>  <span class="hljs-type">const</span> Register card_addr = tmp;<br>  <span class="hljs-type">const</span> Register cardtable = tmp2;<br><br>  <span class="hljs-built_in">movptr</span>(card_addr, store_addr);<br>  <span class="hljs-built_in">shrptr</span>(card_addr, CardTableModRefBS::card_shift); <span class="hljs-comment">//右移操作，找到当前对象对应的卡片</span><br>  <span class="hljs-built_in">movptr</span>(cardtable, (<span class="hljs-type">intptr_t</span>)ct-&gt;byte_map_base);<br>  <span class="hljs-built_in">addptr</span>(card_addr, cardtable);<br><br>  <span class="hljs-comment">//源码很清晰地说明了，G1 不维护从 young gen Region 出发的引用涉及到的 Rset 更新</span><br>  <span class="hljs-built_in">cmpb</span>(<span class="hljs-built_in">Address</span>(card_addr, <span class="hljs-number">0</span>), (<span class="hljs-type">int</span>)G1SATBCardTableModRefBS::<span class="hljs-built_in">g1_young_card_val</span>()); <br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-built_in">membar</span>(Assembler::<span class="hljs-built_in">Membar_mask_bits</span>(Assembler::StoreLoad));  <span class="hljs-comment">//写读屏障，相关知识指令乱序，内存序</span><br>  <span class="hljs-built_in">cmpb</span>(<span class="hljs-built_in">Address</span>(card_addr, <span class="hljs-number">0</span>), (<span class="hljs-type">int</span>)CardTableModRefBS::<span class="hljs-built_in">dirty_card_val</span>()); <span class="hljs-comment">//判断卡片是否脏 </span><br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br><br>  <span class="hljs-comment">// storing a region crossing, non-NULL oop, card is clean.</span><br>  <span class="hljs-comment">// dirty card and log.</span><br><br>  <span class="hljs-built_in">movb</span>(<span class="hljs-built_in">Address</span>(card_addr, <span class="hljs-number">0</span>), (<span class="hljs-type">int</span>)CardTableModRefBS::<span class="hljs-built_in">dirty_card_val</span>());  <span class="hljs-comment">//卡片置脏</span><br><br>  <span class="hljs-built_in">cmpl</span>(queue_index, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, runtime); <span class="hljs-comment">//当前线程队列是否已满，已满转运行时（同 pre_barrier）</span><br>  <span class="hljs-comment">//不满就入队</span><br>  <span class="hljs-built_in">subl</span>(queue_index, wordSize);<br>  <span class="hljs-built_in">movptr</span>(tmp2, buffer);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LP64</span><br>  <span class="hljs-built_in">movslq</span>(rscratch1, queue_index);<br>  <span class="hljs-built_in">addq</span>(tmp2, rscratch1);    <span class="hljs-comment">//将 _index 减去 oopSize</span><br>  <span class="hljs-built_in">movq</span>(<span class="hljs-built_in">Address</span>(tmp2, <span class="hljs-number">0</span>), card_addr);  <span class="hljs-comment">//入队</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-built_in">addl</span>(tmp2, queue_index);  <span class="hljs-comment">//将 _index 减去 oopSize</span><br>  <span class="hljs-built_in">movl</span>(<span class="hljs-built_in">Address</span>(tmp2, <span class="hljs-number">0</span>), card_addr);  <span class="hljs-comment">//入队</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-built_in">jmp</span>(done);<br><br>  <span class="hljs-built_in">bind</span>(runtime);<br>  <span class="hljs-comment">// save the live input values</span><br>  <span class="hljs-built_in">push</span>(store_addr);<br>  <span class="hljs-built_in">push</span>(new_val);<br>  <span class="hljs-comment">//调用运行时 SharedRuntime::g1_wb_post</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LP64</span><br>  <span class="hljs-built_in">call_VM_leaf</span>(<span class="hljs-built_in">CAST_FROM_FN_PTR</span>(address, SharedRuntime::g1_wb_post), card_addr, r15_thread);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-built_in">push</span>(thread);<br>  <span class="hljs-built_in">call_VM_leaf</span>(<span class="hljs-built_in">CAST_FROM_FN_PTR</span>(address, SharedRuntime::g1_wb_post), card_addr, thread);<br>  <span class="hljs-built_in">pop</span>(thread);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-built_in">pop</span>(new_val);<br>  <span class="hljs-built_in">pop</span>(store_addr);<br><br>  <span class="hljs-built_in">bind</span>(done);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体逻辑与伪代码类似， 源码的注释已经能够说明过程了，此处不作赘述。</p><h1 id="write-barrier-在C2编译的实现"><a href="#write-barrier-在C2编译的实现" class="headerlink" title="write-barrier 在C2编译的实现"></a>write-barrier 在C2编译的实现</h1><p>依旧是如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况 1 ：假设 G1 正在并发标记，对象 t 作为根对象已经被标记（灰色），但是 t 引用的对象还没被标记</span><br><span class="hljs-comment">//情况 2 ：假设对象 young 和 t 分别在不同的 Region 中</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">young</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<span class="hljs-comment">//步骤 1</span><br>t.next = young;<span class="hljs-comment">//步骤 2</span><br><span class="hljs-comment">//上述两种情况都需要在步骤 2 完成前记录下相关信息</span><br></code></pre></td></tr></table></figure><p>当触发 C2 编译时，首先根据字节码创建理想图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/parse2.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parse::do_one_bytecode</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">bc</span>()) &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">case</span> Bytecodes::_putfield:<br>      <span class="hljs-built_in">do_putfield</span>();<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/opto/parse.hpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_putfield</span> <span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">do_field_access</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>); &#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/opto/parse3.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parse::do_field_access</span><span class="hljs-params">(<span class="hljs-type">bool</span> is_get, <span class="hljs-type">bool</span> is_field)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (is_get) &#123;<br>      (<span class="hljs-type">void</span>) <span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// pop receiver before getting</span><br>      <span class="hljs-built_in">do_get_xxx</span>(obj, field, is_field);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">do_put_xxx</span>(obj, field, is_field);<br>      (<span class="hljs-type">void</span>) <span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// pop receiver after putting</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parse::do_put_xxx</span><span class="hljs-params">(Node* obj, ciField* field, <span class="hljs-type">bool</span> is_field)</span> </span>&#123;<br><br>  <span class="hljs-comment">// Store the value.</span><br>  Node* store;<br>  <span class="hljs-keyword">if</span> (bt == T_OBJECT) &#123;<br>    <span class="hljs-type">const</span> TypeOopPtr* field_type;<br>    <span class="hljs-keyword">if</span> (!field-&gt;<span class="hljs-built_in">type</span>()-&gt;<span class="hljs-built_in">is_loaded</span>()) &#123;<br>      field_type = TypeInstPtr::BOTTOM;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      field_type = TypeOopPtr::<span class="hljs-built_in">make_from_klass</span>(field-&gt;<span class="hljs-built_in">type</span>()-&gt;<span class="hljs-built_in">as_klass</span>());<br>    &#125;<br>    store = <span class="hljs-built_in">store_oop_to_object</span>(<span class="hljs-built_in">control</span>(), obj, adr, adr_type, val, field_type, bt, mo);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    store = <span class="hljs-built_in">store_to_memory</span>(<span class="hljs-built_in">control</span>(), adr, val, bt, adr_type, mo, is_vol);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.hpp</span><br>  <span class="hljs-function">Node* <span class="hljs-title">store_oop_to_object</span><span class="hljs-params">(Node* ctl,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* obj,   <span class="hljs-comment">// containing obj</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* adr,   <span class="hljs-comment">// actual adress to store val at</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> TypePtr* adr_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* val,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> TypeOopPtr* val_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                            BasicType bt,</span></span><br><span class="hljs-params"><span class="hljs-function">                            MemNode::MemOrd mo)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">store_oop</span>(ctl, obj, adr, adr_type, val, val_type, bt, <span class="hljs-literal">false</span>, mo);<br>  &#125;<br></code></pre></td></tr></table></figure><p>创建详细过程可以读者自行理解，此处只关注调用关系，最终调用到 store_oop </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.cpp</span><br><br><span class="hljs-function">Node* <span class="hljs-title">GraphKit::store_oop</span><span class="hljs-params">(<span class="hljs-comment">/* 参数 */</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">pre_barrier</span>(<span class="hljs-literal">true</span> <span class="hljs-comment">/* do_load */</span>, <span class="hljs-built_in">control</span>(), obj, adr, adr_idx, val, val_type, <span class="hljs-literal">NULL</span> <span class="hljs-comment">/* pre_val */</span>, bt);<br><br>  Node* store = <span class="hljs-built_in">store_to_memory</span>(<span class="hljs-built_in">control</span>(), adr, val, bt, adr_idx, mo, mismatched);<br><br>  <span class="hljs-built_in">post_barrier</span>(<span class="hljs-built_in">control</span>(), store, obj, adr, adr_idx, val, bt, use_precise);<br>  <span class="hljs-keyword">return</span> store;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 store_to_memory 函数的前后分别加入了 pre_barrier 和 post_barrier 当函数需要 C2 编译运行，同时 GC 选用的是 G1GC 时，会在解析字节码时就为 write_barrier 生成相关的结点。</p><h2 id="pre-barrier-在C2编译中的实现"><a href="#pre-barrier-在C2编译中的实现" class="headerlink" title="pre_barrier 在C2编译中的实现"></a>pre_barrier 在C2编译中的实现</h2><p>接下来追溯 pre_barrier 到底生成了哪些节点， </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::pre_barrier</span><span class="hljs-params">(<span class="hljs-comment">/*..*/</span>)</span> </span>&#123;<br><br>  BarrierSet* bs = Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">barrier_set</span>();<br>  <span class="hljs-built_in">set_control</span>(ctl);<br>  <span class="hljs-comment">//与模板解释器相同，需要根据选项选择 barrier 此处只关心 G1GC 部分</span><br>  <span class="hljs-keyword">switch</span> (bs-&gt;<span class="hljs-built_in">kind</span>()) &#123;<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCT:<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCTLogging:<br>      <span class="hljs-built_in">g1_write_barrier_pre</span>(do_load, obj, adr, adr_idx, val, val_type, pre_val, bt);<br>      <span class="hljs-keyword">break</span>;<br>  <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// G1 pre/post barriers</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::g1_write_barrier_pre</span><span class="hljs-params">(<span class="hljs-type">bool</span> do_load,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* obj,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    uint alias_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* val,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> TypeOopPtr* val_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* pre_val,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    BasicType bt)</span> </span>&#123;<br><br>  <span class="hljs-comment">// Some sanity checks</span><br>  <span class="hljs-comment">// Note: val is unused in this routine.</span><br><br>  <span class="hljs-function">IdealKit <span class="hljs-title">ideal</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>)</span></span>;<br><br>  Node* tls = __ <span class="hljs-built_in">thread</span>(); <span class="hljs-comment">// ThreadLocalStorage</span><br><br>  Node* no_ctrl = <span class="hljs-literal">NULL</span>;<br>  Node* no_base = __ <span class="hljs-built_in">top</span>();<br>  Node* zero  = __ <span class="hljs-built_in">ConI</span>(<span class="hljs-number">0</span>);<br>  Node* zeroX = __ <span class="hljs-built_in">ConX</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">float</span> likely  = <span class="hljs-built_in">PROB_LIKELY</span>(<span class="hljs-number">0.999</span>);<br>  <span class="hljs-type">float</span> unlikely  = <span class="hljs-built_in">PROB_UNLIKELY</span>(<span class="hljs-number">0.999</span>);<br><br>  BasicType active_type = <span class="hljs-built_in">in_bytes</span>(PtrQueue::<span class="hljs-built_in">byte_width_of_active</span>()) == <span class="hljs-number">4</span> ? T_INT : T_BYTE;<br> <br>  <span class="hljs-comment">// Offsets into the thread 根据 thread 得到需要值的偏移地址</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> marking_offset = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">satb_mark_queue_offset</span>() +  <span class="hljs-comment">// 648</span><br>                                          PtrQueue::<span class="hljs-built_in">byte_offset_of_active</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> index_offset   = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">satb_mark_queue_offset</span>() +  <span class="hljs-comment">// 656</span><br>                                          PtrQueue::<span class="hljs-built_in">byte_offset_of_index</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffer_offset  = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">satb_mark_queue_offset</span>() +  <span class="hljs-comment">// 652</span><br>                                          PtrQueue::<span class="hljs-built_in">byte_offset_of_buf</span>());<br><br>  <span class="hljs-comment">// Now the actual pointers into the thread 加法节点获取计算得到的地址</span><br>  Node* marking_adr = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(marking_offset));<br>  Node* buffer_adr  = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(buffer_offset));<br>  Node* index_adr   = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(index_offset));<br><br>  <span class="hljs-comment">// Now some of the values</span><br>  Node* marking = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), marking_adr, TypeInt::INT, active_type, Compile::AliasIdxRaw);<br><br>  <span class="hljs-comment">// if (!marking) 判断是否为并发标记阶段</span><br>  <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(marking, BoolTest::ne, zero, unlikely)</span></span>; &#123;<br>    BasicType index_bt = TypeX_X-&gt;<span class="hljs-built_in">basic_type</span>();<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>) == <span class="hljs-built_in">type2aelembytes</span>(index_bt), <span class="hljs-string">&quot;Loading G1 PtrQueue::_index with wrong size.&quot;</span>);<br>    Node* index   = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);<br><br>    <span class="hljs-keyword">if</span> (do_load) &#123;<br>      <span class="hljs-comment">// load original value</span><br>      <span class="hljs-comment">// alias_idx correct??</span><br>      pre_val = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), adr, val_type, bt, alias_idx);<br>    &#125;<br><br>    <span class="hljs-comment">// if (pre_val != NULL) 判断域之前的值是否为空</span><br>    <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(pre_val, BoolTest::ne, null())</span></span>; &#123;<br>      Node* buffer  = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);<br><br>      <span class="hljs-comment">// is the queue for this thread full? 当前线程的 satb 队列是否已满，已满会调用运行时的 g1_wb_pre</span><br>      <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(index, BoolTest::ne, zeroX, likely)</span></span>; &#123;<br><br>        <span class="hljs-comment">// decrement the index</span><br>        Node* next_index = _gvn.<span class="hljs-built_in">transform</span>(<span class="hljs-built_in">new</span> (C) <span class="hljs-built_in">SubXNode</span>(index, __ <span class="hljs-built_in">ConX</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">intptr_t</span>))));<br><br>        <span class="hljs-comment">// Now get the buffer location we will log the previous value into and store it 入队</span><br>        Node *log_addr = __ <span class="hljs-built_in">AddP</span>(no_base, buffer, next_index);<br>        <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br>        <span class="hljs-comment">// update the index</span><br>        <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br><br>      &#125; <span class="hljs-function">__ <span class="hljs-title">else_</span><span class="hljs-params">()</span></span>; &#123;<br><br>        <span class="hljs-comment">// logging buffer is full, call the runtime 运行时 g1_wb_pre 函数与模板解释器调用的是同一个</span><br>        <span class="hljs-type">const</span> TypeFunc *tf = OptoRuntime::<span class="hljs-built_in">g1_wb_pre_Type</span>();<br>        <span class="hljs-function">__ <span class="hljs-title">make_leaf_call</span><span class="hljs-params">(tf, CAST_FROM_FN_PTR(address, SharedRuntime::g1_wb_pre), <span class="hljs-string">&quot;g1_wb_pre&quot;</span>, pre_val, tls)</span></span>;<br>      &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// (!index)</span><br>    &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// (pre_val != NULL)</span><br>  &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// (!marking)</span><br><br>  <span class="hljs-comment">// Final sync IdealKit and GraphKit.</span><br>  <span class="hljs-built_in">final_sync</span>(ideal);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>整体逻辑类似，判断 pre_val 是否空，线程队列是否满，根据判断结果调用运行时或者生成将 pre_val 入栈的节点<br>在生成理想图节点后，C2编译器会对理想图做优化，最后生成机器代码，详细过程如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PhaseTraceId</span> &#123;<br>_t_parser, <span class="hljs-comment">// 1. 字节码解析与理想图生成</span><br>_t_optimizer, <span class="hljs-comment">// 2. 机器无关优化</span><br>...<br>_t_matcher, <span class="hljs-comment">// 3. 指令选择</span><br>_t_scheduler, <span class="hljs-comment">// 4. 指令调度和全局代码提出</span><br>_t_registerAllocation, <span class="hljs-comment">// 5. 寄存器分配</span><br>...<br>_t_blockOrdering, <span class="hljs-comment">// 6. 移除空基本块</span><br>_t_peephole, <span class="hljs-comment">// 7. 窥孔优化</span><br>_t_postalloc_expand,<br>_t_output, <span class="hljs-comment">// 8. 生成机器代码</span><br>...<br>_t_registerMethod, <span class="hljs-comment">// 9. 用编译生成的方法代替Java方法</span><br>_t_tec,<br>max_phase_timers<br>&#125;;<br></code></pre></td></tr></table></figure><p>这部分不是本文关注的重点，为了方便研究 C2 编译结果可以通过 slowdebug 版本的 hotspot ，在运行程序时添加参数 -XX:+PrintOptoAssembly 查看 Opto （也可以直接查看汇编，但是 Opto 更直观），仍以上文例子为例可以在x86平台得到如下两段 Opto 节选，分别是 G1GC 与其他不会产生 pre_barrier 的 GC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无 pre_barrier</span><br>movq    [R10 + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)], RBP# ptr ! Field: Node.next <span class="hljs-comment">//将寄存器RBP中的新值写入内存</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">B5: #B13 B6 &lt;- B4  Freq: <span class="hljs-number">0.999979</span><br># TLS is in R15<br>movsbl  R10, [R15 + #<span class="hljs-number">1424</span> (<span class="hljs-number">32</span>-bit)]# <span class="hljs-type">byte</span>                  <br>testl   R10, R10                                        <br>jne     B13  P=<span class="hljs-number">0.001000</span> C=-<span class="hljs-number">1.000000</span>   <span class="hljs-comment">//if (!marking) -&gt;B13</span><br><br>B13: #B6 B14 &lt;- B5  Freq: <span class="hljs-number">0.000999966</span><br>movq    RDI, [RBX + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)]# ptr ! Field: Node.next  <span class="hljs-comment">//pre_val</span><br>testq   RDI, RDI# ptr         <br>je     B6  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>   <span class="hljs-comment">//if (pre_val != NULL) -&gt;B14</span><br><br>B14: #B19 B15 &lt;- B13  Freq: <span class="hljs-number">0.000499983</span><br># TLS is in R15<br>movq    R10, [R15 + #<span class="hljs-number">1440</span> (<span class="hljs-number">32</span>-bit)]# <span class="hljs-type">long</span><br>testq   R10, R10<br>je,s   B19  P=<span class="hljs-number">0.001000</span> C=-<span class="hljs-number">1.000000</span>  <span class="hljs-comment">// is the queue for this thread full? full -&gt; B19 else -&gt; B15</span><br><br>B19: #B6 &lt;- B14  Freq: <span class="hljs-number">4.99977e-07</span><br># TLS is in R15<br>movq    RSI, R15# spill           <span class="hljs-comment">// logging buffer is full</span><br>call_leaf,runtime  g1_wb_pre        <span class="hljs-comment">// 调用运行时函数 g1_wb_pre</span><br>  No JVM State Info<br>  # <br>jmp     B6<br><br>B15: #B6 &lt;- B14  Freq: <span class="hljs-number">0.000499483</span><br># TLS is in R15<br>movq    R11, [R15 + #<span class="hljs-number">1432</span> (<span class="hljs-number">32</span>-bit)]# ptr<br>movq    [R11 + #-<span class="hljs-number">8</span> + R10], RDI# ptr   <span class="hljs-comment">// pre_val 入队</span><br>addq    R10, #-<span class="hljs-number">8</span># <span class="hljs-type">long</span>    <span class="hljs-comment">//将 _index 减去 oopSize</span><br># TLS is in R15<br>movq    [R15 + #<span class="hljs-number">1440</span> (<span class="hljs-number">32</span>-bit)], R10# <span class="hljs-type">long</span><br>jmp     B6<br><br>B6: #B12 B7 &lt;- B19 B15 B13 B5  Freq: <span class="hljs-number">0.999979</span><br>movq    [RBX + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)], RBP# ptr ! Field: Node.next  <span class="hljs-comment">//新值写入域</span><br><br></code></pre></td></tr></table></figure><p>整体过程与理想图阶段生成的节点，能一一对应。</p><h2 id="post-barrier-在C2编译中的实现"><a href="#post-barrier-在C2编译中的实现" class="headerlink" title="post_barrier 在C2编译中的实现"></a>post_barrier 在C2编译中的实现</h2><p>post_barrier 的逻辑大体与 pre_barrier 相同，如下会根据 barrier 类型 G1GC 匹配到 g1_write_barrier_post</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.cpp</span><br><span class="hljs-comment">//相同的逻辑，此处不作赘述</span><br>  <span class="hljs-keyword">switch</span> (bs-&gt;<span class="hljs-built_in">kind</span>()) &#123;<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCT:<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCTLogging:<br>      <span class="hljs-built_in">g1_write_barrier_post</span>(store, obj, adr, adr_idx, val, bt, use_precise);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::g1_write_barrier_post</span><span class="hljs-params">(Node* oop_store,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     Node* obj,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     Node* adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     uint alias_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     Node* val,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     BasicType bt,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">bool</span> use_precise)</span> </span>&#123;<br>  <span class="hljs-comment">// If we are writing a NULL then we need no post barrier</span><br><br>  <span class="hljs-keyword">if</span> (val != <span class="hljs-literal">NULL</span> &amp;&amp; val-&gt;<span class="hljs-built_in">is_Con</span>() &amp;&amp; val-&gt;<span class="hljs-built_in">bottom_type</span>() == TypePtr::NULL_PTR) &#123;<br>    <span class="hljs-comment">// Must be NULL</span><br>    <span class="hljs-type">const</span> Type* t = val-&gt;<span class="hljs-built_in">bottom_type</span>();<br>    <span class="hljs-built_in">assert</span>(t == Type::TOP || t == TypePtr::NULL_PTR, <span class="hljs-string">&quot;must be NULL&quot;</span>);<br>    <span class="hljs-comment">// No post barrier if writing NULLx</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!use_precise) &#123;<br>    <span class="hljs-comment">// All card marks for a (non-array) instance are in one place:</span><br>    adr = obj;<br>  &#125;<br>  <span class="hljs-comment">// (Else it&#x27;s an array (or unknown), and we want more precise card marks.)</span><br>  <span class="hljs-built_in">assert</span>(adr != <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>  <span class="hljs-function">IdealKit <span class="hljs-title">ideal</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>)</span></span>;<br><br>  Node* tls = __ <span class="hljs-built_in">thread</span>(); <span class="hljs-comment">// ThreadLocalStorage</span><br><br>  Node* no_base = __ <span class="hljs-built_in">top</span>();<br>  <span class="hljs-type">float</span> likely  = <span class="hljs-built_in">PROB_LIKELY</span>(<span class="hljs-number">0.999</span>);<br>  <span class="hljs-type">float</span> unlikely  = <span class="hljs-built_in">PROB_UNLIKELY</span>(<span class="hljs-number">0.999</span>);<br>  Node* young_card = __ <span class="hljs-built_in">ConI</span>((jint)G1SATBCardTableModRefBS::<span class="hljs-built_in">g1_young_card_val</span>());<br>  Node* dirty_card = __ <span class="hljs-built_in">ConI</span>((jint)CardTableModRefBS::<span class="hljs-built_in">dirty_card_val</span>());<br>  Node* zeroX = __ <span class="hljs-built_in">ConX</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Get the alias_index for raw card-mark memory</span><br>  <span class="hljs-type">const</span> TypePtr* card_type = TypeRawPtr::BOTTOM;<br><br>  <span class="hljs-type">const</span> TypeFunc *tf = OptoRuntime::<span class="hljs-built_in">g1_wb_post_Type</span>();<br><br>  <span class="hljs-comment">// Offsets into the thread 获取偏移</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> index_offset  = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">dirty_card_queue_offset</span>() +<br>                                     PtrQueue::<span class="hljs-built_in">byte_offset_of_index</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffer_offset = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">dirty_card_queue_offset</span>() +<br>                                     PtrQueue::<span class="hljs-built_in">byte_offset_of_buf</span>());<br><br>  <span class="hljs-comment">// Pointers into the thread 与 thread 值相加计算具体地址</span><br><br>  Node* buffer_adr = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(buffer_offset));<br>  Node* index_adr =  __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(index_offset));<br><br>  <span class="hljs-comment">// ... 部分优化 与 值获取</span><br><br>  <span class="hljs-comment">// If we know the value being stored does it cross regions? 判断是否产生跨区域</span><br><br>  <span class="hljs-keyword">if</span> (val != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// Does the store cause us to cross regions?</span><br><br>    <span class="hljs-comment">// Should be able to do an unsigned compare of region_size instead of</span><br>    <span class="hljs-comment">// and extra shift. Do we have an unsigned compare??</span><br>    <span class="hljs-comment">// Node* region_size = __ ConI(1 &lt;&lt; HeapRegion::LogOfHRGrainBytes); </span><br>    <br>    <span class="hljs-comment">// 判断方式为 check = obj ^ newobj</span><br>    Node* xor_res =  __ <span class="hljs-built_in">URShiftX</span> ( __ <span class="hljs-built_in">XorX</span>( cast,  __ <span class="hljs-built_in">CastPX</span>(__ <span class="hljs-built_in">ctrl</span>(), val)), __ <span class="hljs-built_in">ConI</span>(HeapRegion::LogOfHRGrainBytes));<br><br>    <span class="hljs-comment">// if (xor_res == 0) same region so skip </span><br>    <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(xor_res, BoolTest::ne, zeroX)</span></span>; &#123;<br><br>      <span class="hljs-comment">// No barrier if we are storing a NULL 如果是 NULL 也不需要 barrier</span><br>      <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(val, BoolTest::ne, null(), unlikely)</span></span>; &#123;<br><br>        <span class="hljs-comment">// Ok must mark the card if not already dirty</span><br><br>        <span class="hljs-comment">// load the original value of the card </span><br>        Node* card_val = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);<br><br>        <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(card_val, BoolTest::ne, young_card)</span></span>; &#123;   <span class="hljs-comment">// 判断是否是 young 区的跨界引用， young 区每次都会被收集，故不维护 Rset</span><br>          <span class="hljs-built_in">sync_kit</span>(ideal);<br>          <span class="hljs-comment">// Use Op_MemBarVolatile to achieve the effect of a StoreLoad barrier.</span><br>          <span class="hljs-built_in">insert_mem_bar</span>(Op_MemBarVolatile, oop_store);<br>          <span class="hljs-function">__ <span class="hljs-title">sync_kit</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br><br>          Node* card_val_reload = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);<br>          <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(card_val_reload, BoolTest::ne, dirty_card)</span></span>; &#123;<span class="hljs-comment">//判断卡片是否已经脏</span><br>            <span class="hljs-comment">// 调用 g1_mark_card 函数 ，该函数的作用为更新卡表，并将卡片地址入队</span><br>            <span class="hljs-built_in">g1_mark_card</span>(ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);<br>          &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>        &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>      &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>    &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Object.clone() instrinsic uses this path.</span><br>    <span class="hljs-built_in">g1_mark_card</span>(ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);<br>  &#125;<br><br>  <span class="hljs-comment">// Final sync IdealKit and GraphKit.</span><br>  <span class="hljs-built_in">final_sync</span>(ideal);<br>&#125;<br><br><span class="hljs-comment">// Update the card table and add card address to the queue</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::g1_mark_card</span><span class="hljs-params">(IdealKit&amp; ideal,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* card_adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* oop_store,</span></span><br><span class="hljs-params"><span class="hljs-function">                            uint oop_alias_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* index,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* index_adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> TypeFunc* tf)</span> </span>&#123;<br><br>  Node* zero  = __ <span class="hljs-built_in">ConI</span>(<span class="hljs-number">0</span>);<br>  Node* zeroX = __ <span class="hljs-built_in">ConX</span>(<span class="hljs-number">0</span>);<br>  Node* no_base = __ <span class="hljs-built_in">top</span>();<br>  BasicType card_bt = T_BYTE;<br>  <span class="hljs-comment">// Smash zero into card. MUST BE ORDERED WRT TO STORE</span><br>  <span class="hljs-function">__ <span class="hljs-title">storeCM</span><span class="hljs-params">(__ ctrl(), card_adr, zero, oop_store, oop_alias_idx, card_bt, Compile::AliasIdxRaw)</span></span>;<br><br>  <span class="hljs-comment">//  Now do the queue work</span><br>  <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(index, BoolTest::ne, zeroX)</span></span>; &#123;<span class="hljs-comment">//如果当前线程队列未满</span><br><br>    Node* next_index = _gvn.<span class="hljs-built_in">transform</span>(<span class="hljs-built_in">new</span> (C) <span class="hljs-built_in">SubXNode</span>(index, __ <span class="hljs-built_in">ConX</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">intptr_t</span>))));<br>    Node* log_addr = __ <span class="hljs-built_in">AddP</span>(no_base, buffer, next_index);<br><br>    <span class="hljs-comment">// Order, see storeCM.</span><br>    <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), log_addr, card_adr, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br>    <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), index_adr, next_index, TypeX_X-&gt;basic_type(), Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br><br>  &#125; <span class="hljs-function">__ <span class="hljs-title">else_</span><span class="hljs-params">()</span></span>; &#123;<span class="hljs-comment">//线程队列已满会调用运行时</span><br>    <span class="hljs-function">__ <span class="hljs-title">make_leaf_call</span><span class="hljs-params">(tf, CAST_FROM_FN_PTR(address, SharedRuntime::g1_wb_post), <span class="hljs-string">&quot;g1_wb_post&quot;</span>, card_adr, __ thread())</span></span>;<br>  &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>理想图部分代码与模板解释器体现的逻辑也是一致的，接下来看看最终生成的 Opto</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">B6: #B12 B7 &lt;- B19 B15 B13 B5  Freq: <span class="hljs-number">0.999979</span><br>movq    [RBX + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)], RBP# ptr ! Field: Node.next <span class="hljs-comment">//完成对象域新值的写入</span><br>movq    R10, RBP# ptr -&gt; <span class="hljs-type">long</span><br>movq    R11, RBX# ptr -&gt; <span class="hljs-type">long</span><br>xorq    R10, R11# <span class="hljs-type">long</span><br>shrq    R10, #<span class="hljs-number">20</span><br>testq   R10, R10<br>je,s   B12  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>    <span class="hljs-comment">//if (xor_res == 0) same region so skip -&gt; B12 ret else -&gt; B7</span><br><br>B7: #B12 B8 &lt;- B6  Freq: <span class="hljs-number">0.499989</span><br>shrq    R11, #<span class="hljs-number">9</span><br>movq    RDI, <span class="hljs-number">0x00007ecf56bf1000</span># ptr<br>addq    RDI, R11# ptr<br>movsbl  R10, [RDI]# <span class="hljs-type">byte</span><br>cmpl    R10, #<span class="hljs-number">32</span><br>je,s   B12  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>  <span class="hljs-comment">// if_then(card_val, BoolTest::ne, young_card) 不用维护 young 区域的 Rset</span><br> <br>B8: #B12 B9 &lt;- B7  Freq: <span class="hljs-number">0.249995</span><br># TLS is in R15<br>movq    R10, [R15 + #<span class="hljs-number">1504</span> (<span class="hljs-number">32</span>-bit)]# <span class="hljs-type">long</span><br># TLS is in R15<br>movq    R11, [R15 + #<span class="hljs-number">1496</span> (<span class="hljs-number">32</span>-bit)]# ptr<br>lock addl [rsp + #<span class="hljs-number">0</span>], <span class="hljs-number">0</span>! membar_volatile <span class="hljs-comment">// 内存序</span><br>movsbl  R9, [RDI]# <span class="hljs-type">byte</span><br>testl   R9, R9<br>je,s   B12  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>   <span class="hljs-comment">// if_then(card_val_reload, BoolTest::ne, dirty_card) 判断卡片是否已经脏</span><br><br>B9: #B11 B10 &lt;- B8  Freq: <span class="hljs-number">0.124997</span>   <br>movb    [RDI], #<span class="hljs-number">0</span># CMS card-mark <span class="hljs-type">byte</span> <span class="hljs-number">0</span>  <span class="hljs-comment">// Smash zero into card. MUST BE ORDERED WRT TO STORE 卡片置为脏</span><br>testq   R10, R10<br>jne,s   B11  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span> <span class="hljs-comment">// if_then(index, BoolTest::ne, zeroX) 判断当前线程队列是否已满</span><br><br>B10: #B12 &lt;- B9  Freq: <span class="hljs-number">0.0624987</span><br># TLS is in R15<br>movq    RSI, R15# spill<br>call_leaf,runtime  g1_wb_post <span class="hljs-comment">// queue full runtime</span><br>  No JVM State Info<br>  # <br>jmp,s   B12<br><br>B11: #B12 &lt;- B9  Freq: <span class="hljs-number">0.0624987</span>  <span class="hljs-comment">//  Now do the queue work 入队</span><br>movq    [R11 + #-<span class="hljs-number">8</span> + R10], RDI# ptr<br>addq    R10, #-<span class="hljs-number">8</span># <span class="hljs-type">long</span>  <span class="hljs-comment">//将 _index 减去 oopSize</span><br># TLS is in R15<br>movq    [R15 + #<span class="hljs-number">1504</span> (<span class="hljs-number">32</span>-bit)], R10# <span class="hljs-type">long</span><br><br>B12: #N1 &lt;- B10 B11 B8 B7 B6  Freq: <span class="hljs-number">0.999979</span><br>addq    rsp, <span class="hljs-number">32</span># Destroy frame<br>popq   rbp<br>testl  rax, [rip + #offset_to_poll_page]# Safepoint: poll <span class="hljs-keyword">for</span> GC<br><br>ret<br><br></code></pre></td></tr></table></figure><h1 id="write-barrier-在运行时的实现"><a href="#write-barrier-在运行时的实现" class="headerlink" title="write-barrier 在运行时的实现"></a>write-barrier 在运行时的实现</h1><p>运行时，不仅需要处理队列满后加入队列的对象，还需要将满的队列放入全局链表，并重置线程私有队列。上文频繁提及，当队列满了会调用运行时实现写屏障，接下来看一下运行时对写屏障的实现。</p><h2 id="g1-wb-pre-与-g1-wb-post-在运行时的实现"><a href="#g1-wb-pre-与-g1-wb-post-在运行时的实现" class="headerlink" title="g1_wb_pre 与 g1_wb_post 在运行时的实现"></a>g1_wb_pre 与 g1_wb_post 在运行时的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// G1 write-barrier pre: executed before a pointer store.</span><br><span class="hljs-built_in">JRT_LEAF</span>(<span class="hljs-type">void</span>, SharedRuntime::<span class="hljs-built_in">g1_wb_pre</span>(oopDesc* orig, JavaThread *thread))<br>  <span class="hljs-keyword">if</span> (orig == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;should be optimized out&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">assert</span>(orig-&gt;<span class="hljs-built_in">is_oop</span>(<span class="hljs-literal">true</span> <span class="hljs-comment">/* ignore mark word */</span>), <span class="hljs-string">&quot;Error&quot;</span>);<br>  <span class="hljs-comment">// store the original value that was in the field reference</span><br>  thread-&gt;<span class="hljs-built_in">satb_mark_queue</span>().<span class="hljs-built_in">enqueue</span>(orig);<br>JRT_END<br><br><span class="hljs-comment">// G1 write-barrier post: executed after a pointer store.</span><br><span class="hljs-built_in">JRT_LEAF</span>(<span class="hljs-type">void</span>, SharedRuntime::<span class="hljs-built_in">g1_wb_post</span>(<span class="hljs-type">void</span>* card_addr, JavaThread* thread))<br>  thread-&gt;<span class="hljs-built_in">dirty_card_queue</span>().<span class="hljs-built_in">enqueue</span>(card_addr);<br>JRT_END<br></code></pre></td></tr></table></figure><p>运行时的代码更直观，即将域前值&#x2F;卡片地址入队，其中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// SATB marking queue support</span><br><span class="hljs-function">ObjPtrQueue&amp; <span class="hljs-title">satb_mark_queue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _satb_mark_queue; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> SATBMarkQueueSet&amp; <span class="hljs-title">satb_mark_queue_set</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> _satb_mark_queue_set;<br>&#125;<br><br><span class="hljs-comment">// Dirty card queue support</span><br><span class="hljs-function">DirtyCardQueue&amp; <span class="hljs-title">dirty_card_queue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _dirty_card_queue; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> DirtyCardQueueSet&amp; <span class="hljs-title">dirty_card_queue_set</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> _dirty_card_queue_set;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些值在<a href="#g1_write_barrier_pre">上文</a>曾多次提及</p><p>根据上面对模板解释器和 C2 编译的分析，只有当当前线程队列满时才会调用到运行时，追溯 enqueue 的实现，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ObjPtrQueue _satb_mark_queue;          <span class="hljs-comment">// Thread-local log for SATB barrier.</span><br>DirtyCardQueue _dirty_card_queue;      <span class="hljs-comment">// Thread-local log for dirty cards.</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjPtrQueue</span>: <span class="hljs-keyword">public</span> PtrQueue&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirtyCardQueue</span>: <span class="hljs-keyword">public</span> PtrQueue&#123;&#125;<br><br></code></pre></td></tr></table></figure><p>enqueue 函数的实现在 ObjPtrQueue 与 DirtyCardQueue 类的共同父类 PtrQueue 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/gc_implementation/g1/ptrQueue.hpp</span><br>  <span class="hljs-comment">// Enqueues the given &quot;obj&quot;.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!_active) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">enqueue_known_active</span>(ptr);<br>  &#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/gc_implementation/g1/ptrQueue.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueue::enqueue_known_active</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br><br>  <span class="hljs-keyword">while</span> (_index == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//当前线程已满调用 handle_zero_index 函数</span><br>    <span class="hljs-built_in">handle_zero_index</span>();  <span class="hljs-comment">//handle_zero_index 函数会为线程私有队列置申请新空间，并重置 _index 为 size</span><br>  &#125;<br><br>  <span class="hljs-comment">// 将 _index 减去 oopSize，并将对象指针入队</span><br>  _index -= oopSize;<br>  _buf[<span class="hljs-built_in">byte_index_to_index</span>((<span class="hljs-type">int</span>)_index)] = ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueue::handle_zero_index</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(_index == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Precondition.&quot;</span>);<br><br>  <span class="hljs-comment">// This thread records the full buffer and allocates a new one (while</span><br>  <span class="hljs-comment">// holding the lock if there is one).</span><br>  <span class="hljs-keyword">if</span> (_buf != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">should_enqueue_buffer</span>()) &#123;<br>      <span class="hljs-built_in">assert</span>(_index &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;the buffer can only be re-used if it&#x27;s not full&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_lock) &#123;<br>      <span class="hljs-built_in">assert</span>(_lock-&gt;<span class="hljs-built_in">owned_by_self</span>(), <span class="hljs-string">&quot;Required.&quot;</span>);<br><br>      <span class="hljs-type">void</span>** buf = _buf;   <span class="hljs-comment">// local pointer to completed buffer</span><br>      _buf = <span class="hljs-literal">NULL</span>;         <span class="hljs-comment">// clear shared _buf field</span><br><br>      <span class="hljs-built_in">locking_enqueue_completed_buffer</span>(buf);  <span class="hljs-comment">// enqueue completed buffer 将线程私有的队列加入链表</span><br><br>      <span class="hljs-keyword">if</span> (_buf != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// Reallocate the buffer 重新为当前线程的队列申请新空间，再将 _index = _sz</span><br>  _buf = <span class="hljs-built_in">qset</span>()-&gt;<span class="hljs-built_in">allocate_buffer</span>();<br>  _sz = <span class="hljs-built_in">qset</span>()-&gt;<span class="hljs-built_in">buffer_size</span>();<br>  _index = _sz;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span> &lt;= _index &amp;&amp; _index &lt;= _sz, <span class="hljs-string">&quot;Invariant.&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueue::locking_enqueue_completed_buffer</span><span class="hljs-params">(<span class="hljs-type">void</span>** buf)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(_lock-&gt;<span class="hljs-built_in">owned_by_self</span>(), <span class="hljs-string">&quot;Required.&quot;</span>);<br><br>  <span class="hljs-comment">// We have to unlock _lock (which may be Shared_DirtyCardQ_lock) before</span><br>  <span class="hljs-comment">// we acquire DirtyCardQ_CBL_mon inside enqeue_complete_buffer as they</span><br>  <span class="hljs-comment">// have the same rank and we may get the &quot;possible deadlock&quot; message</span><br>  _lock-&gt;<span class="hljs-built_in">unlock</span>();<br><br>  <span class="hljs-built_in">qset</span>()-&gt;<span class="hljs-built_in">enqueue_complete_buffer</span>(buf); <span class="hljs-comment">//将线程私有的队列加入链表</span><br>  <span class="hljs-comment">// We must relock only because the caller will unlock, for the normal</span><br>  <span class="hljs-comment">// case.</span><br>  _lock-&gt;<span class="hljs-built_in">lock_without_safepoint_check</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueueSet::enqueue_complete_buffer</span><span class="hljs-params">(<span class="hljs-type">void</span>** buf, <span class="hljs-type">size_t</span> index)</span> </span>&#123;<br>  <span class="hljs-function">MutexLockerEx <span class="hljs-title">x</span><span class="hljs-params">(_cbl_mon, Mutex::_no_safepoint_check_flag)</span></span>;<br>  BufferNode* cbn = BufferNode::<span class="hljs-built_in">new_from_buffer</span>(buf);<br>  cbn-&gt;<span class="hljs-built_in">set_index</span>(index);<br>  <span class="hljs-keyword">if</span> (_completed_buffers_tail == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">//链表是否为空</span><br>    <span class="hljs-built_in">assert</span>(_completed_buffers_head == <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Well-formedness&quot;</span>);<br>    _completed_buffers_head = cbn;  <span class="hljs-comment">// 链表头为 buf </span><br>    _completed_buffers_tail = cbn;  <span class="hljs-comment">// 链表尾为 buf</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    _completed_buffers_tail-&gt;<span class="hljs-built_in">set_next</span>(cbn); <span class="hljs-comment">//非空时候 buf 加入链表末尾</span><br>    _completed_buffers_tail = cbn;<br>  &#125;<br>  _n_completed_buffers++; <span class="hljs-comment">//链表长度 +1</span><br>  <span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p id="references"></p>    <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>jdk8源代码</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>G1GC-write barrier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>G1GC算法篇</title>
    <link href="/2022/12/20/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    <url>/2022/12/20/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将通过对G1的整个回收周期的算法原理进行解读，如有偏差，请指正。<span id="more"></span></p><p>G1GC(Garbage First Garbage Collection)(简称G1) 自 JDK9 起，替代 Parallel Scavenge 和 Parallel Old 的组合，作为 Hotspot 在 Server 端的默认垃圾回收器，具有停顿时间可控、不产生内存碎片、返还未使用内存给堆等的特性，在 JDK9 之前可以通过 -XX:+UseG1G C的参数调用 G1 。</p><h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><p>在深入 G1GC 算法之前，先建立以下基本概念，如果读者已经掌握相关知识可以跳过这一部分，如果完全不了解这些概念，可以尝试简单了解一部分。</p><h2 id="自动内存管理系统"><a href="#自动内存管理系统" class="headerlink" title="自动内存管理系统"></a>自动内存管理系统</h2><p>在《 Java 虚拟机规范》中将 Java 堆描述为：“ The heap is the runtime data area form which memory for all class instances and arrays is allocated ” （随着 Java 语言的发展，“所有对象实例及数组都在堆上分配”这一点也不绝对）。Java 堆作为自动内存管理的内存区域，需要满足能在上面为新对象分配内存，并自动释放死亡对象所占据内存的功能，细分下就是需要回答下面三个问题：</p><ul><li>如何在堆上为新对象分配内存？</li><li>如何识别存活对象？</li><li>如何回收死亡对象占据的内存？</li></ul><p>对应到 G1GC 的算法，将从下面几点回答这三个问题：</p><ul><li>G1GC 堆结构（分配对象）</li><li>G1GC 并发标记（识别存活对象）</li><li>G1GC 跨界引用的标记（识别存活对象）</li><li>G1GC 转移对象过程（回收死亡对象）</li></ul><h2 id="软实时性"><a href="#软实时性" class="headerlink" title="软实时性"></a>软实时性</h2><p>G1GC 具有软实时性（ soft real-time ）。由于多数 GC 需要暂停应用程序，为了保证应用程序的软实时性（能保证大多数任务在最后期限之前完成，例如网络银行系统），我们要求 G1 ，在任意 1 秒的时间内，停顿不得超过 200ms 。G1 会尽量达成这个目标，它能够推算出本次要收集的大体区域，以增量的方式完成收集。</p><ul><li>设置<code>期望暂停时间</code>（ -XX:MaxGCPauseMillis ，默认 200）</li></ul><h2 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h2><p>GC 时判断哪些对象需要被回收有两种方法，引用计数法和可达性分析法。其中，G1 使用可达性分析算法通过一系列 <code>GC Roots</code> 作为起始点搜索所有通过引用可达的对象，搜索的路径称为引用链（ Reference Chain ），所有能被搜索到的对象被认为（标记为）存活对象。可作为 GC Roots 的对象包括但不限于下面几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>在方法区中类静态属性引用的对象</li><li>在方法区中常量引用的对象</li><li>本地方法栈中 JNI（ Native 方法）引用的对象</li></ul><p>下面是一段Java示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Obj</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<span class="hljs-comment">// a 为 root ，对象的引用</span><br>a.ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>(); <span class="hljs-comment">// a 的成员ref赋值变量的引用，当前可达</span><br><span class="hljs-comment">//System.gc();//如果此时发生 GC ，标记过程会从 a（ GC Root ）出发标记 a 指向的对象，再标记 a.ref 指向的对象</span><br>a = <span class="hljs-literal">null</span>;  <span class="hljs-comment">//a 指向的对象被回收，a.ref 指向的对象也需要被回收</span><br></code></pre></td></tr></table></figure><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>顾名思义，通过三种颜色完成标记，</p><ul><li>白色：表示对象尚未被垃圾收集器标记过。</li><li>黑色：表示对象已经被垃圾收集器标记过，且这个对象的所有引用都已经扫描标记过。</li><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过，可以理解为正在搜索的对象。</li></ul><p>简述三色标记法的遍历过程：</p><ol><li>初始时，全部对象都是白色的</li><li>GC Roots 直接引用的对象变成灰色</li><li>从灰色集合中获取元素：<ul><li>将本对象直接引用的对象标记为灰色</li><li>将本对象标记为黑色</li></ul></li><li>重复步骤3，直到灰色的对象集合变为空</li><li>结束后，仍然被标记为白色的对象就是不可达对象，视为垃圾对象</li></ol><p>对象在并发标记阶段会被漏标的充分必要条件是（同时满足以下两点）：</p><ul><li>Mutator 应用程序插入了一个从黑色对象到该白色对象的新引用</li><li>Mutator 应用程序删除了所有从灰色对象到该白色对象的直接或间接引用</li></ul><p id="Copying"></p>   <h2 id="Copying-——-Cheney"><a href="#Copying-——-Cheney" class="headerlink" title="Copying —— Cheney"></a>Copying —— Cheney</h2><p>当标记完成后需要将存活对象转移到特定区域中， G1 的转移逻辑都是基于 Copying 算法思想实现的，算法简略过程如下：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/copy.gif" alt="Copying 算法"></p><h1 id="G1GC-的堆结构"><a href="#G1GC-的堆结构" class="headerlink" title="G1GC 的堆结构"></a>G1GC 的堆结构</h1><p>G1GC 堆的内部被划分为大小相等的 <code>Region</code> ，G1GC 以 Region 为单位进行 GC ，Region 的大小 <code>RegionSize</code> 在 JVM 初始化时初始完毕且在当前 java 进程结束前不会改变。在 HotSpot 的源码中 <code>TARGET_REGION_NUMBER</code> 定义了 Region 的数量限制为 2048 个（实际上允许超过这个值）。一般 RegionSize 等于堆空间的总大小除以 2048 ，也可以用参数 -XX:G1HeapRegionSize 强制指定每个 Region 区的大小用户可以设置 Region 大小，但需要满足 RegionSize 是向上调整为 2 的指数幂，同时需要保证最小不小于 1MB ，最大不超过 32MB （集合 { 1MB , 2MB , 4MB , 8MB , 16MB , 32MB } 内）。</p><p>比如目前的堆空间总大小为 8.5GB ，RegionSize 就是 8704MB&#x2F;2048 &#x3D; 4.25MB ，那么最终每个 Region 的大小为 8MB 。当一个 region 剩余空间不足以满足下一个对象所需空间时， Hotspot 直接放弃 region 中剩余空间，在新分配的 region 中分配对象； OpenJ9 利用剩下的空间，让对象跨 region 存放。</p><h2 id="G1GC-分代分区"><a href="#G1GC-分代分区" class="headerlink" title="G1GC 分代分区"></a>G1GC 分代分区</h2><p>在 G1 收集器中逻辑依旧是分代的，依旧存在年轻代 <code>Eden</code> 区、幸存区 <code>Survivor</code> 、老年代 <code>Old</code> 区，但在物理内存上是不分代的。G1 的每个代区由物理内存不连续的 Region 集合构成，这样做的好处在于：G1 可以优先回收垃圾对象特别多的 Region 区，这样可以花费较少的时间来回收垃圾，这也就是 G1 名字的由来，即垃圾优先收集器。<br>在运行时，G1 会将堆空间变为如下结构：</p><center><img src="/img/G1GC算法篇/G1堆.png" style="zoom:35%" title="分代 G1GC 堆空间划分" ><br>    <div style="color:orange;     color: #999;    padding: 2px;">分代 G1GC 堆空间划分    </div></center><p>新创建的对象都会被分配到 Eden 区，对象经过第一次 YGC 后，仍然存活的会被移到 Survivor 区，多次GC后依然存活的对象会被移动到 Old 区。图中除了提到的三个分区还多了大对象区 <code>Humongous</code> 与 <code>未分配区</code> 。在 G1 中当对象大小超过单个普通 Region 区的 50% 时，认定对象为大对象，大对象会直接将其放入 Humongous 区存储，当一个 Humongous 区存不下时，可能会横跨多个 Region 区存储它。在大多数时 Humongous 区会被当做老年代看待。</p><h2 id="G1GC-新生代动态调整大小"><a href="#G1GC-新生代动态调整大小" class="headerlink" title="G1GC 新生代动态调整大小"></a>G1GC 新生代动态调整大小</h2><p>G1 的设计目标是软实时，应以响应时间优先。 G1 根据基于衰减平均值的停顿预测模型统计以前发生 GC 时记录的数据来预测本次收集需要选择的分区数量。以新生代收集为例（通过添加参数 -XX:+PrintGCDetails 查看）</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%A4%A7%E5%B0%8F.png" alt="新生代动态调整大小"></p><p>如上图彩色框图所示， G1 随着 GC 的发生，根据 GC 耗时动态调整新生代 Eden 区和 Survivor 区的个数，当Eden区满后触发下一次 GC 收集。通过这种方式来保证 GC 带来的最大停顿时间不超过期望暂停时间。当然上图展示的是比较理想的 YGC 过程，G1GC 的收集策略会在后续详细介绍。</p><h1 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h1><p>通常 GC 算法在标记存活对象时，为了避免在标记过程中发生引用关系改变的情况，都需要让应用程序在安全点处停下，也就是常说的<code>Stop The World</code>简称 STW 。G1 在对老年代的标记过程中引入了并发标记，并发指的是与应用程序<code>mutator</code>并发执行。并发标记并不是直接在对象上添加标记，而是在<code>标记位图</code>上添加标记。</p><h2 id="标记位图"><a href="#标记位图" class="headerlink" title="标记位图"></a>标记位图</h2><p>下图表示堆中的一个 region ，位图中黑色表示已标记存活，白色表示未标记为存活。</p><center><img src="/img/G1GC算法篇/标记位图.png" style="zoom:45%" title="标记位图" ><br>    <div style="color:orange;     color: #999;    padding: 2px;">标记位图    </div></center><p>需要强调下，图中为了展示对应关系，将标记位图画得同 region 相对应，实际上标记位图每一格只有 1bit ，而 region 上一块为单个对象，标记位图中的每个 bit 都对应关联 region 内的对象的开头部分。假设单个对象的大小都是 8 个字节（本文后续都如此假定），那么每 8 个字节就会对应标记位图中的 1个bit 。图中标记位图里黑色的地方表示比特值是 1 ，白色的地方表示比特值是 0 。相应地，region 内黑色的是存活对象，带有叉号的是死亡对象。</p><p>每个region有两个标记位图：</p><ul><li><code>next</code>：本次标记的标记位图。</li><li><code>prev</code>：上次标记的标记位图，保存了上次并发标记的结果。</li></ul><p>图中region部分：</p><ul><li><code>bottom</code>：region 内众多对象的末尾</li><li><code>top</code>：region 内众多对象的开头（包括在并发标记过程中新分配的对象）</li><li><code>nextTAMS</code>：本次标记开始时的 top（TAMS-Top At Marking Start）（本次标记从 bottom 到此处）</li><li><code>prevTAMS</code>：上次标记开始时的 top</li></ul><p>并发标记结束主要针对的是 G1 老年代中 region 部分的标记，根据 G1 的清理策略，并不会对所有 region 做垃圾收集（会选择垃圾最多的几个 region 作清理）。所以保存上次标记结果 prev ，用于确定上次标记的存活对象在本次标记后是否能存活，而不扫描上次已经确定死亡的对象。</p><p>下列图展示对同一块 region 两次并发标记始末状态，用来说明 prev 标记位图和 next 标记位图的作用</p><center class = half><img src="/img/G1GC算法篇/第一次并发标记开始.png" height="143" title="第一次并发标记开始状态" ><img src="/img/G1GC算法篇/第一次并发标记完成.png" height="143" title="第一次并发标记完成状态" ><br>    <div style="color:orange; color: #999;padding: 2px;">    第一次并发标记开始状态&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第一次并发标记完成状态    </div></center><p>如上图所见，到第一次并发标记完成，标记了所有 bottom 到 nextTAMS 内所有存活对象（标记完成后会在收尾阶段将标记位图 next 中的并发标记结果移动到标记位图 prev 中，再重置标记位图 next ）</p><center class = half><img src="/img/G1GC算法篇/第二次并发标记开始.png" height="153" title="第二次并发标记开始状态" ><img src="/img/G1GC算法篇/第二次并发标记完成.png" height="153" title="第二次并发标记完成状态" ><br>    <div style="color:orange; color: #999;padding: 2px;">    第二次并发标记开始状态&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第二次并发标记完成状态    </div></center><p>等到新一轮并发标记开始时时，</p><ol><li>对当前 Bottom 和 top 之间的对象创建空白的标记位图 next</li><li>对 Bottom 和 prevTAMS 之间的内存对象，根据 prev 标记的存活结果重新标记存活对象（ prev 中标记死亡的对象不扫描）</li><li>对 prevTAMS 和 NextTAMS 之间的内存对象进行存活标记</li><li>对 NextTAMS 和 top 之间的对象，都认为是存活对象，不在标记位图上作标记</li><li>完成并发标记后将标记位图 next 置为标记位图 prev ，并重置标记位图 next</li></ol><p>注：在下文展开并发标记算法逻辑时，为了简化理解，假定region上发生的是第一次并发标记，prev为空白（如上图）。</p><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><p>简单介绍单次并发标记的过程，具体标记细节，会在下文展开，参考<a href="#references">中村成洋书中内容</a>一共分下列五个步骤</p><ol><li><strong>初始标记阶段</strong>：暂停应用程序 STW ，标记可由根直接引用的对象。</li><li><strong>并发标记阶段</strong>：与 mutator 并发进行，扫描 1 中标记的对象所引用的对象。</li><li><strong>最终标记阶段</strong>：暂停应用程序 STW ，扫描 2 中没有标记的对象。本步骤结束后，堆内所有存活对象都会被标记。</li><li><strong>存活对象计数</strong>：对每个 region 中被标记的对象进行计数，并发执行。</li><li><strong>收尾工作</strong>：暂停应用程序 STW ，收尾工作，并为下次标记做准备。</li></ol><h2 id="步骤-1——初始标记阶段"><a href="#步骤-1——初始标记阶段" class="headerlink" title="步骤 1——初始标记阶段"></a>步骤 1——初始标记阶段</h2><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0.png" alt="初始标记"></p><p>在初始标记阶段，GC 线程首先创建空白的标记位图 next。其中 nextTAMS 是本次标记开始时 top 所在的位置。单个对象假定8字节，位图的大小是 (top-botton)&#x2F;(8字节)。创建过程与 mutator 应用程序并发进行。</p><p>等所有待回收 region 的标记位图都完成创建后，暂停 mutator（ STW ）标记由根直接引用的对象（根扫描），目的是防止扫描过程中根被修改。按照三色标记算法，此时根直接引用的对象的引用还没被扫描，应该将根直接引用的对象标记为灰色，需要注意的是标记位图只能通过 0&#x2F;1 的 bit 位来标记对象是否存活，并不能标记灰色，真实的位图在初始标记结束时会将存活对象在位图上标为1，而如果表现标灰的操作会在下文 SATB 部分展开。</p><p>上图状态可以用如下java代码粗略演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Obj</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<br>C.ref1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aobj</span>();<br>C.ref2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Eobj</span>();<br><br><span class="hljs-type">Obj</span> <span class="hljs-variable">H</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<br>H.ref1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iobj</span>();<br></code></pre></td></tr></table></figure><p>根对象 C 、 H 分别持有子对象，根对象被标记为灰色，因为持有的子对象都没被标记（白色）</p><h2 id="步骤-2——并发标记阶段"><a href="#步骤-2——并发标记阶段" class="headerlink" title="步骤 2——并发标记阶段"></a>步骤 2——并发标记阶段</h2><p>在并发标记阶段，GC 线程与 mutator 并发进行，扫描在 1 阶段标记过的对象，完成对大部分存活对象的标记。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5.png" alt="并发标记阶段"></p><p>上图展示了并发标记的始末状态，对象 C 的子对象 A 和 E ，对象 H 的子对象 I 都被标记了。虽然 E 对应了标记位图中多个位，但是只有起始的标记位会被标记为 1 。</p><p>因为并发标记是和 mutator 应用程序并发执行，所以可能会向 region 内分配新的对象，上图中 J 和 K 即在并发标记阶段新分配的对象，记录在初始标记阶段记录的 nextTAMS 与当前 top 之间（ top 会随着分配对象而移动，指针碰撞），并不需要专门为新生成的对象创建标记位图（ J 、K 没有标记位图），这些新分配的对象（nextTAMS到top间的对象）会被当做存活对象，不在此次标记收集中处理。</p><p>但是由于这一阶段是与应用程序 mutator 并发执行， mutator 可能会改变对象之间的引用关系，造成并发标记漏标。</p><h3 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h3><p>在三色标记算法的基本概念中给出了并发标记漏标的充分必要条件，此处通过例子展示漏标的情况：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E6%BC%8F%E6%A0%87.gif"></p><p>开始时，A 、C 、E 完成标记，H 由于是根直接引用的对象，在初始标记阶段标记为灰色，I 暂未被标记，然后 Mutator 执行下列代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//已知:H.ref1 = new Iobj();C.ref2 = new Eobj();</span><br>C.ref2.ref1 = H.ref1;<span class="hljs-comment">//添加引用E-&gt;I</span><br>H.ref1 = <span class="hljs-literal">null</span>;<span class="hljs-comment">//断开H-&gt;I </span><br></code></pre></td></tr></table></figure><p>如果不做任何处理，黑色对象 E 不会再次扫描 E 的引用，又由于断开了所有由灰色对象到对象 A 的引用，对象 A 无法被标记为存活，将在回收过程中被当作垃圾收集，造成漏标。</p><p>G1GC 使用<code>SATB（Snapshot At The Beginning）专用写屏障</code>算法，用于打破充要条件的第二点。即在断开由灰色对象到白色对象引用时，将白色对象变为灰色对象。具体的操作是在一个对象的 field 发生写操作时，这个对象 field 之前的值会被放入 SATB 本地队列。</p><p id="satb"></p> <p>SATB 专用写屏障的伪代码如下所示：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//对应JVM 在oop_store方法的赋值动作的前的pre-write barrier</span><br>def satb_write_barrier(field, newobj):<br>    <span class="hljs-keyword">if</span> <span class="hljs-symbol">$gc</span>_phase == GC_CONCURRENT_MARK:<br>        oldobj = *field<br>        <span class="hljs-keyword">if</span> oldobj != <span class="hljs-literal">Null</span>:<br>            enqueue(<span class="hljs-symbol">$curre</span>nt_thread.stab_local_queue, oldobj)<br><br>        *field = newobj<br></code></pre></td></tr></table></figure><p>参数 field 表示被写入对象的域，参数 newobj 表示被写入域的值。第 2 行的 GC_CONCURRENT_MARK 表示并发标记阶段的标志位（flag）用于检查当前是否处于并发标记阶段。第 4 行检查被写入之前field 域的值是不是 Null。如果检查通过，则在第 5 行将 oldobj 添加到 $current_thread.stab_local_queue 中。然后，在第 7 行进行实际的写入操作。</p><p>“初始标记阶段”一节中提到并不存在位图上将对象标记为灰色的操作，所谓的标记为灰色其实是，将对象对应的标记位图bit位设置为 1 的同时，将对象加入 SATB 队列。此处的队列是 mutator 各自持有的线程本地队列，SATB 本地队列在装满（默认大小为 1 KB）之后，会被添加到全局的 SATB 队列集合中，在并发标记阶段交给 GC 线程对队列中的全部对象进行扫描和标记。</p><p>回到刚刚的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//已知:H.ref1 = new Iobj();C.ref2 = new Eobj();</span><br>C.ref2.ref1 = H.ref1;<br><span class="hljs-comment">//C.ref2.ref1 在 region 图中为对象 E ，此处发生写操作会被写屏障函数感知</span><br><span class="hljs-comment">//首先判断 E.ref1 = null 所以可以直接将 H.ref1 即 对象 I 写入 E 的域</span><br>H.ref1 = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//H.ref1 在region图中为对象 I ，此处发生写操作会被写屏障函数感知</span><br><span class="hljs-comment">//由于 I 非空 需要先将对象 I 在位图上标记为存活，再将对象 I 加入待扫描的 SATB 队列</span><br></code></pre></td></tr></table></figure><p>不难发现，通过上述过程对象 I 并不会被漏标。</p><p>细心的读者会发现，如果不存在第一步将对象 I 写入 E 的域，单纯需要将对象 I 置为垃圾，那 SATB 写屏障的存在依旧会将对象 I 标记为存活造成错标，造成浮动垃圾，但是不影响程序的正确性。G1 使用的写屏障 + SATB 产生的浮动垃圾通常比 CMS 使用的写屏障 + 增量更新（ IU ）更多。</p><h2 id="步骤-3——最终标记阶段"><a href="#步骤-3——最终标记阶段" class="headerlink" title="步骤 3——最终标记阶段"></a>步骤 3——最终标记阶段</h2><p>在步骤 2 中介绍了被写屏障感知的对象会先加入 SATB 本地队列，只有当 SATB 本地队列装满之后才会被交给 GC 线程进行扫描和标记，而最终标记阶段则是暂停应用程序 mutator 扫描 SATB 本地队列存放的待扫描对象。本步骤结束后，所有的存活对象都已被标记，所有不带标记的对象都可以判定为死亡对象。</p><h2 id="步骤-4——存活对象计数"><a href="#步骤-4——存活对象计数" class="headerlink" title="步骤 4——存活对象计数"></a>步骤 4——存活对象计数</h2><p>存活对象计数阶段根据每个 region 的标记位图 next，统计当前 region 内存活对象的字节数，存到 region 内的 next_marked_bytes 中。下图中存活对象 A、C、E、H 和 I，一共 5 个对象，其中 E 真实大小是 16 个字节，另外 4 个对象都是 8 个字节，所以 next_marked_bytes 总共 48 个字节。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E8%AE%A1%E6%95%B0.png" alt="存活对象计数结束后 region 的状态"></p><p>同时存活对象计数阶段也是与应用程序并发出现的，如果又新创建了对象 L ，会将对象继续放在 nextTAMS 和 top 之间，被当做存活对象处理，同对象 J 、 K 都不会参与本次存活对象计数，留待下次并发标记处理。</p><h2 id="步骤-5——收尾工作"><a href="#步骤-5——收尾工作" class="headerlink" title="步骤 5——收尾工作"></a>步骤 5——收尾工作</h2><p>收尾工作也需要暂停应用程序（ STW ），主要完成两件事情：</p><ol><li>将标记位图 next 的并发标记结果移动到标记位图 prev 中，再重置标记位图 next 为空，同时移动  prevTAMS </li><li>计算每个 region 的转移效率，并按照转移效率对 region 进行降序排序</li></ol><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E6%94%B6%E5%B0%BE%E9%98%B6%E6%AE%B5.png" alt="收尾工作完成 region 的状态"></p><p>图中将标记位图 next 的并发标记结果移动到标记位图 prev 中，再重置标记位图 next 为空（会在下次并发标记第 1 步重新创建）。同时 prevTAMS 被移动到了原来 nextTAMS 的位置，表示下次并发标记会从 prevTAMS 开始， prevTAMS 之前的存活对象都被标记在标记位图 prev 中了。 nextTAMS 则会被移动到 bottom 的位置， nextTAMS 会在下次并发标记开始时，移动到 top 的最新位置。</p><h3 id="转移效率"><a href="#转移效率" class="headerlink" title="转移效率"></a>转移效率</h3><p>上文提到， prev 标记位图的作用是在本次标记中确定上一次标记过的活跃对象，用于优化内存管理。存在这种需求的原因是一次并发标记过后的 region 并不会马上被回收，而是选择垃圾最多（转移效率最高）的若干 region 做垃圾回收。</p><p>转移效率 &#x3D; region 内死亡对象的字节数 ÷ 转移所需时间</p><p>通俗理解就是， region 内死亡对象字节数越多，存活对象字节数就越少，而存活对象字节数越少，那么转移所需的时间就越少。用更少的时间清理出一块相同大小的 region 就具有更大的转移效率。</p><h1 id="跨界引用的标记"><a href="#跨界引用的标记" class="headerlink" title="跨界引用的标记"></a>跨界引用的标记</h1><p>垃圾收集器在 Partial GC 时（局部收集）都会面临跨代引用的问题（如下图， GC Roots 直接引用的新生代对象 D 存在对老年代对象 C 的引用，而GC Roots 直接引用的老年代对象 B 存在对新生代对象 A 的引用）。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png" alt="跨代引用示例"></p><p>G1 的问题更加复杂，由于被将堆分割为多个 region ，每个 region 与 region 之间都有可能存在跨界引用，而每次 GC 并不会对所有 region 都进行回收，但是为了准确找到所有需要回收的 region 内的存活对象，就不得不每次都扫描整个堆。为了减少扫描的代价，按照牺牲空间换时间的逻辑，引入了Remembered Set（记忆集，简称RSet）的概念，RSet是一种用于记录从非收集区域指向收集区域的指针集合的抽象结构。《深入理解 Java 虚拟机》一书将 G1 对 RSet 的实现称作“双向的卡表结构”，原始论文中更多的是直接用 Remembered Set（记忆集）来描述 RSet 。</p><h2 id="卡表（-card-table-）"><a href="#卡表（-card-table-）" class="headerlink" title="卡表（ card table ）"></a>卡表（ card table ）</h2><p>卡表（Card Table）通过卡精度的方式实现，是元素大小为 1B 的数组，HotSpot如下实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//share/vm/gc_implementation/g1/heapReagion.cpp</span><br>GrainBytes = (<span class="hljs-type">size_t</span>)region_size;<br>CardsPerRegion = GrainBytes &gt;&gt; CardTableModRefBS::card_shift;<br><br><span class="hljs-comment">//share/vm/memory/cardTableModRefBS.hpp</span><br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SomePublicConstants</span> &#123;<br>    card_shift                  = <span class="hljs-number">9</span>,<br>    card_size                   = <span class="hljs-number">1</span> &lt;&lt; card_shift,<br>    card_size_in_words          = card_size / <span class="hljs-built_in">sizeof</span>(HeapWord)<br>  &#125;;<br><br><span class="hljs-comment">//简化逻辑为</span><br>CARD_TABLE [<span class="hljs-keyword">this</span> address &gt;&gt; <span class="hljs-number">9</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>不难理解，每一块 region 内某个对象的首地址右移 9 位（除以 512 ）就是对应的卡表索引。换句话说，将 region 按照每 512 个字节作为一个卡页，只要这 512 个字节的卡页中存在一个及以上的对象有对其他区域的对象的引用，就将对应卡表元素变成 1（此处会将 1 写入某块地址占一个 byte ），也就是所谓的卡表元素变脏。在垃圾回收时，只要根据卡表中变脏的元素，找到对应的卡页，再从卡页对应内存地址包含的对象中找到跨界指针，最后将跨界指针加入 GC Roots 中一并扫描。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/card_table.png" alt="卡表结构"></p><p>如上图所示，每个 region 保存了一个 points-out （“我指向谁”）的卡表，当某个卡表元素为 1 时，认为卡片脏（例如卡片 3 脏），于是只需要去对应的0x0400~0x05FF中扫描对象找到跨界引用即可。</p><h2 id="RSet-的实现"><a href="#RSet-的实现" class="headerlink" title="RSet 的实现"></a>RSet 的实现</h2><p>卡表的结构减少了整体扫描的成本， G1 在此基础上为每个 region 构造了另一张表，用于记录下哪些别的region有指向自己指针，而这些指针又分别在那些 region 的哪些 card 的范围内。通过这种方式构造了一种类似双向链表的具有索引“我指向谁”和“谁指向我”的 RSet 结构。</p><p>RSet的结构是一种哈希表，</p><ul><li>key ：引用本 region 内对象的其他 region 的起始地址</li><li>value ：数组，数组元素是引用方的对象所对应的卡片索引</li></ul><p>借用知乎文章<a href="#references">《关于 G1 GC 的一些研究》</a>中的例子，如下图所示：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/RSet.png" alt="G1 RSet的引用关系"></p><p>上图中的 RSet 属于 region B ，RSet 中第一项的 key 指向了 region A 的首地址，value里有index为 1,2,3… 的 card ，意思是指 region A 的 card 对应的卡页里有对象引用了 region B 内的对象。</p><p>那么整合卡表就能看清整个 RSet 的全貌了，借用<a href="#references">中村成洋书中案例</a>如下：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/RSet%E4%BE%8B%E5%AD%90.png" alt="G1 RSet 使用例子"></p><p>如图在 region A 保存的 RSet 中，存在以 region B 的首地址为 Key ，索引 2048 为 value 的哈希表元素。当需要确定跨界引用时会通过 Key 中 region B 的首地址找到 region B，再通过 value 2048 找到 2048 号卡表对应的 512 Bytes 的地址段，扫描地址段内的对象，找到存在跨界引用向 A 中对象 a 的 B 中对象 b 。</p><p>不难发现 RSet 记录的是 points-into 的关系（谁指向我），而 card table 记录的是 points-out 的关系（我指向谁），所以在《深入java虚拟机》一书中用“双向的卡表结构”来形容这个特殊的 RSet 。</p><h2 id="维护-RSet"><a href="#维护-RSet" class="headerlink" title="维护 RSet"></a>维护 RSet</h2><p>那么如何来维护 RSet 呢，考虑如下情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//假设对象young和old分别在不同的Region中</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">young</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>old.p = young;<br></code></pre></td></tr></table></figure><p>java 层面给 old 对象的 p 字段赋值 young 对象之后，jvm 底层会执行 oop_store 方法,并在赋值动作<strong>后</strong>使用 post-write barrier 函数。</p><p>在介绍 <a href="#satb">SATB 伪代码</a>时提到过在同样的赋值动作<strong>前</strong>会插入 pre-write barrier 函数（ satb_write_barrier ）用于记录引用的修改，此处的 post-write barrier 函数与 pre-write barrier 函数实现方法类似，先看下方伪代码。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs smali">//对应JVM 在oop_store方法的赋值动作的前的post-write barrier<br>def evacuation_write_barrier(obj, field, newobj):<br>   <span class="hljs-built_in"> check </span>= obj ^ newobj<br>   <span class="hljs-built_in"> check </span>=<span class="hljs-built_in"> check </span>&gt;&gt; LOG_OF_HEAP_REGION_SIZE<br>   <span class="hljs-built_in"> if </span>newobj == Null:<br>       <span class="hljs-built_in"> check </span>= 0<br>   <span class="hljs-built_in"> if </span>check == 0:<br>       <span class="hljs-built_in"> return</span><br><span class="hljs-built_in"></span><br>   <span class="hljs-built_in"> if </span>not is_dirty_card(obj):<br>        to_dirty(obj)<br>        enqueue($current_thread.rs_log, obj)<br><br>    *field = newobj<br></code></pre></td></tr></table></figure><p>第 2 行到第 7 行的代码会在 obj 和 newobj 位于同一个区域，或者 newobj 为 Null 时，起到过滤的作用。第 9 行的函数 is_dirty_card() 用来检查参数 obj 所对应的卡片是否为脏卡片。该行的检查就是为了避免向转移专用记忆集合日志中添加重复的卡片。如果是净卡片，则该卡片将在第 10 行变成脏卡片，然后在第 11 行<br>被添加到队列 $current_thread.rs_log 中。</p><p>与 SATB 一样这里也有一个全局的队列， DirtyCardQueueSet 。更新RSet的动作则会交给多个 ConcurrentG1RefineThread 线程来并发完成，每当这个全局队列超过一定的阈值后， ConcurrentG1RefineThread 都会取出若干个队列，并且遍历队列中的记录的card并将它加到对应的 region 的 RSet 中。</p><h1 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h1><p>转移过程的算法原理可以参考基本概念的 <a href="#Copying">Copying</a> 算法，G1 转移过程与 Copying 算法大致相同。由于加入了 RSet 优化，所以在处理根对象时略有不同，转移根对象除了需要转移<code>由根直接引用的对象</code>，还需要转移<code>并发标记处理中的对象</code>以及<code>由其他区域对象直接引用的回收集合内的对象</code></p><h2 id="回收集确定"><a href="#回收集确定" class="headerlink" title="回收集确定"></a>回收集确定</h2><p>在介绍 G1 堆结构时提到 G1 新生代会动态调整大小以满足停顿预测模型，事实上在垃圾回收过程中，G1 会记录每个region 的回收耗时，根据用户的期望停顿时间来生成回收集 Collection Set（简称CSet），一次完整的回收过程，只会转移 CSet 内的存活对象。</p><p>G1 中存在两种选定 CSet 的子模式，分别为 Young GC 与 mixed GC </p><ul><li>Young GC ：选定所有的 young gen 里的 region 。通过控制 young gen 的个数来控制 young GC 的开销。</li><li>Mixed GC ：选定所有的 young gen region ，外加根据“衰减平均值”统计得出的收益较高的若干 old gen region 。在用户指定的最大停顿时间范围内尽可能的选择收益高的old gen Region</li></ul><p>其中第一种模式就是G1 新生代会动态调整大小的情况；第二种模式中，由于在并发标记的步骤 5 中对所有 old gen region 计算了转移效率并按照降序排列了，接下来只要依次计算各个 region 的预测暂停时间，再依次将 region 加入 CSet ，在当所有已选 region 的预测暂停时间的总和快要超过最大停顿时间时停止加入即可。</p><p>由于 young gen Region 总是在 CSet 内，因此 G1 不维护从 young gen Region 出发的引用涉及到的 Rset 更新。</p><h2 id="转移过程"><a href="#转移过程" class="headerlink" title="转移过程"></a>转移过程</h2><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/YGC%E8%BD%AC%E7%A7%BB.png" alt="YGC 的转移过程"></p><p>如上图，YGC 仅将所有新生代 region （包括 Eden 和 survivor ）都加入 CSet ，然后统一转移 CSet 内的对象。晋升的对象会被转移到老年代，其余的转移到 survivor 区。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/MixedGC%E8%BD%AC%E7%A7%BB.png" alt="Mixed GC 的转移过程"></p><p>如上图，Mixed GC 除了所有新生代区域外，还会选择一些老年代 region 加入 CSet。</p><h1 id="G1GC-过程"><a href="#G1GC-过程" class="headerlink" title="G1GC 过程"></a>G1GC 过程</h1><p>引用<a href="#references">《深入探索JVM垃圾回收》</a>书中对 G1 YGC 与 Mixed GC 状态转换图如下</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/GC%E6%89%A7%E8%A1%8C%E6%B4%BB%E5%8A%A8%E5%9B%BE.png" alt="GC执行活动图"></p><p>图中对 G1 的 Young GC 、并发标记 、Mixed GC 三种状态做了展示，结合并发标记的过程和 mutator 来看，可以得到下图活动图：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/G1%E6%B4%BB%E5%8A%A8%E5%9B%BE.png" alt="G1 垃圾回收活动图"></p><p id="references"></p>    <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入 Java 虚拟机-JVM G1GC 的算法与实现》中村成洋&#x2F;著 吴炎昌 杨文轩&#x2F;译 1-6章<br>《深入探索JVM垃圾回收》彭成寒 4-6章<br><a href="https://zhuanlan.zhihu.com/p/463179141">关于 G1 GC 的一些研究</a><br><a href="https://www.redhat.com/en/blog/part-1-introduction-g1-garbage-collector">Part 1: Introduction to the G1 Garbage Collector</a><br><a href="https://www.redhat.com/en/blog/collecting-and-reading-g1-garbage-collector-logs-part-2?source=author&term=22991">Collecting and reading G1 garbage collector logs - part 2</a><br><a href="https://blog.csdn.net/weixin_45101064/article/details/123478022">(八)JVM成神路之GC分区篇：G1、ZGC、ShenandoahGC高性能收集器深入剖析</a> G1部分</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
