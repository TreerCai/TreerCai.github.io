<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Specjbb测试集分析</title>
    <link href="/2023/01/25/Specjbb%E6%B5%8B%E8%AF%95%E9%9B%86%E5%88%86%E6%9E%90/"/>
    <url>/2023/01/25/Specjbb%E6%B5%8B%E8%AF%95%E9%9B%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>specjbb2015</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hotspot源码分析(G1)——write_barrier</title>
    <link href="/2023/01/15/Hotspot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-G1-%E2%80%94%E2%80%94write-barrier/"/>
    <url>/2023/01/15/Hotspot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-G1-%E2%80%94%E2%80%94write-barrier/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将针对<a href="/2022/12/20/G1GC%E7%AE%97%E6%B3%95%E7%AF%87"> G1GC 算法篇</a>中提到的 write barrier 技术基于源码进行分析，如有偏差，请指正。<span id="more"></span></p><p>G1 SATB 与 Rset维护都会调用到 write-barrier （ SATB 采用 pre write-barrier 完成，维护 RSet 采用 post write-barrier 完成） mutator 在 write-barrier 中仅仅将要做的事推送到队列中，然后通过另外的线程取出队列中的信息批量完成剩余的动作。</p><p>本文将分析 write-barrier 在OpenJDK8源码中解释器与C2编译中的实现。</p><h1 id="write-barrier-在模板解释器的实现"><a href="#write-barrier-在模板解释器的实现" class="headerlink" title="write-barrier 在模板解释器的实现"></a>write-barrier 在模板解释器的实现</h1><p>在 G1GC 算法篇介绍两种 write-barrier 时提过， SATB 写屏障的目的是当并发标记时避免<code>漏标</code>，而维护的 Rset 记录的则是<code>跨界引用</code>。<code>漏标的产生</code>和<code>跨界引用的修改</code>根本原因都与对象的域被修改有关。查看如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况 1 ：假设 G1 正在并发标记，对象 t 作为根对象已经被标记（灰色），但是 t 引用的对象还没被标记</span><br><span class="hljs-comment">//情况 2 ：假设对象 young 和 t 分别在不同的 Region 中</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">young</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<span class="hljs-comment">//步骤 1</span><br>t.next = young;<span class="hljs-comment">//步骤 2</span><br><span class="hljs-comment">//上述两种情况都需要在步骤 2 完成前记录下相关信息</span><br></code></pre></td></tr></table></figure><p>例子转换成字节码的核心部分如下，字节码的阅读不作详细解答，可查阅相关文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">26241</span>] <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> WriteBarrierShow.xxx(jobject, jint)<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769225</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">new</span> <span class="hljs-number">2</span> &lt;Node&gt;<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769226</span>     <span class="hljs-number">3</span>  dup<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769227</span>     <span class="hljs-number">4</span>  iload_1<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769228</span>     <span class="hljs-number">5</span>  invokespecial <span class="hljs-number">3</span> &lt;Node.&lt;init&gt;(I)V&gt; <br><br><span class="hljs-comment">//... virtual void Node.&lt;init&gt;(jint)</span><br><br>[<span class="hljs-number">26241</span>] <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> WriteBarrierShow.xxx(jobject, jint)<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769236</span>     <span class="hljs-number">8</span>  astore_2<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769237</span>     <span class="hljs-number">9</span>  aload_0<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769238</span>    <span class="hljs-number">10</span>  aload_2<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769239</span>    <span class="hljs-number">11</span>  putfield <span class="hljs-number">4</span> &lt;Node.p/LNode;&gt; <br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769240</span>    <span class="hljs-number">14</span>  <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure><p>当解释执行时，会通过字节码 putfield 实现步骤2 ，所以来看一下 putfield 在模板解释器中的实现： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TemplateTable::putfield</span><span class="hljs-params">(<span class="hljs-type">int</span> byte_no)</span> </span>&#123;<br>  <span class="hljs-built_in">putfield_or_static</span>(byte_no, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TemplateTable::putfield_or_static</span><span class="hljs-params">(<span class="hljs-type">int</span> byte_no, <span class="hljs-type">bool</span> is_static)</span> </span>&#123;<br>  <span class="hljs-built_in">transition</span>(vtos, vtos);<br>  <span class="hljs-comment">// ... 此处的 putfield 是将 object 放到域上，此处的 _tos_in（模板执行前的TosState）为 </span><br>  <span class="hljs-comment">// atos （object cached）相关知识栈顶缓存</span><br>  &#123;<br>    <span class="hljs-function">__ <span class="hljs-title">pop</span><span class="hljs-params">(atos)</span></span>;<br>    <span class="hljs-keyword">if</span> (!is_static) <span class="hljs-built_in">pop_and_check_object</span>(obj);<br>    <span class="hljs-comment">// Store into the field</span><br>    <span class="hljs-built_in">do_oop_store</span>(_masm, field, rax, _bs-&gt;<span class="hljs-built_in">kind</span>(), <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-function">__ <span class="hljs-title">jmp</span><span class="hljs-params">(Done)</span></span>;<br>  &#125;<br>  <span class="hljs-function">__ <span class="hljs-title">bind</span><span class="hljs-params">(notObj)</span></span>;<br>  <span class="hljs-function">__ <span class="hljs-title">cmpl</span><span class="hljs-params">(flags, itos)</span></span>;<br>  <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::notEqual, notInt)</span></span>;<br><span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>事实上字节码 aastore 字节码也会调用到 do_oop_store 函数，本文仅用 putfield 举例， do_oop_store 函数会将 oop （或 NULL ）存储在 obj 描述的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">do_oop_store</span><span class="hljs-params">(InterpreterMacroAssembler* _masm, Address obj, Register val, BarrierSet::Name barrier, <span class="hljs-type">bool</span> precise)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (barrier) &#123;<br>    <span class="hljs-comment">// -XX:+UseG1GC 此处只关心 G1GC 会调用到的部分</span><br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCT:<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCTLogging:<br>      &#123;<br>        <span class="hljs-function">__ <span class="hljs-title">g1_write_barrier_pre</span><span class="hljs-params">(rdx <span class="hljs-comment">/* obj */</span>, rbx <span class="hljs-comment">/* pre_val */</span>, r15_thread <span class="hljs-comment">/* thread */</span>,  r8  <span class="hljs-comment">/* tmp */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                val != noreg <span class="hljs-comment">/* tosca_live */</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">/* expand_call */</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (val == noreg) &#123;<br>          <span class="hljs-function">__ <span class="hljs-title">store_heap_oop_null</span><span class="hljs-params">(Address(rdx, <span class="hljs-number">0</span>))</span></span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// G1 barrier needs uncompressed oop for region cross check.</span><br>          Register new_val = val;<br>          <span class="hljs-keyword">if</span> (UseCompressedOops) &#123;<br>            new_val = rbx;<br>            <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(new_val, val)</span></span>;<br>          &#125;<br>          <span class="hljs-function">__ <span class="hljs-title">store_heap_oop</span><span class="hljs-params">(Address(rdx, <span class="hljs-number">0</span>), val)</span></span>;<br>          <span class="hljs-function">__ <span class="hljs-title">g1_write_barrier_post</span><span class="hljs-params">(rdx <span class="hljs-comment">/* store_adr */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   new_val <span class="hljs-comment">/* new_val */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   r15_thread <span class="hljs-comment">/* thread */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   r8 <span class="hljs-comment">/* tmp */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   rbx <span class="hljs-comment">/* tmp2 */</span>)</span></span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>排除压缩指针与其他选项匹配的 barrier 代码，不难看出，当开启 G1GC 时，会在 store_heap_oop(_null) 之前调用 g1_write_barrier_pre ，之后调用 g1_write_barrier_post 函数。</p><p id="g1_write_barrier_pre"></p>    <h2 id="g1-write-barrier-pre-在解释运行中的实现"><a href="#g1-write-barrier-pre-在解释运行中的实现" class="headerlink" title="g1_write_barrier_pre 在解释运行中的实现"></a>g1_write_barrier_pre 在解释运行中的实现</h2><p>回顾 G1GC 算法实现，SATB 专用写屏障的伪代码如下所示：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//对应JVM 在oop_store方法的赋值动作的前的pre-write barrier</span><br>def satb_write_barrier(field, newobj):<br>    <span class="hljs-keyword">if</span> <span class="hljs-symbol">$gc</span>_phase == GC_CONCURRENT_MARK:<br>        oldobj = *field<br>        <span class="hljs-keyword">if</span> oldobj != <span class="hljs-literal">Null</span>:<br>            enqueue(<span class="hljs-symbol">$curre</span>nt_thread.stab_local_queue, oldobj)<br><br>        *field = newobj<br></code></pre></td></tr></table></figure><p>在伪代码中不难看出 SATB 专用写屏障，通过在将新对象写入域之前记录原来域对象,并滞后标记的方式来避免漏标。<br>在 G1GC 算法篇介绍 SATB 时提过，首先会将 old 对象放到本地线程的 SATB 队列中，所以首先来看一下 JavaThread 类的以下两个属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/runtime/thread.hpp</span><br><br>  <span class="hljs-comment">// Support for G1 barriers</span><br><br>  ObjPtrQueue _satb_mark_queue;          <span class="hljs-comment">// Thread-local log for SATB barrier.</span><br>  <span class="hljs-comment">// Set of all such queues.</span><br>  <span class="hljs-type">static</span> SATBMarkQueueSet _satb_mark_queue_set;<br><br>  DirtyCardQueue _dirty_card_queue;      <span class="hljs-comment">// Thread-local log for dirty cards.</span><br>  <span class="hljs-comment">// Set of all such queues.</span><br>  <span class="hljs-type">static</span> DirtyCardQueueSet _dirty_card_queue_set;<br></code></pre></td></tr></table></figure><p>_satb_mark_queue 与 _dirty_card_queue 属于线程私有，当线程本地队列满了之后，会分别提交到全局的 _satb_mark_queue_set 与 _dirty_card_queue_set 交给 G1 线程批量处理。</p><p> ObjPtrQueue 的父类 class PtrQueue 具有如下属性与函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/gc_implementation/g1/ptrQueue.hpp</span><br>  <span class="hljs-comment">// Whether updates should be logged.</span><br>  <span class="hljs-type">bool</span> _active;<br><br>  <span class="hljs-comment">// The buffer.</span><br>  <span class="hljs-type">void</span>** _buf;<br>  <span class="hljs-comment">// The index at which an object was last enqueued.  Starts at &quot;_sz&quot;</span><br>  <span class="hljs-comment">// (indicating an empty buffer) and goes towards zero.</span><br>  <span class="hljs-type">size_t</span> _index;<br><br>    <span class="hljs-comment">// Enqueues the given &quot;obj&quot;.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!_active) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">enqueue_known_active</span>(ptr);<br>  &#125;<br></code></pre></td></tr></table></figure><p>注释很好理解，三个属性分别是是否活跃、buffer 地址与最后一个对象的末尾索引。其中 _index 属性为 0 时代表队列满了，具体处理在后文分析。<br>接下来看一下 g1_write_barrier_pre 的核心实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/cpu/x86/vm/macroAssembler_x86.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MacroAssembler::g1_write_barrier_pre</span><span class="hljs-params">(Register obj,         <span class="hljs-comment">//rdx /* obj */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          Register pre_val,     <span class="hljs-comment">//rbx /* pre_val */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          Register thread,      <span class="hljs-comment">//r15_thread /* thread */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          Register tmp,         <span class="hljs-comment">//r8  /* tmp */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">bool</span> tosca_live,      <span class="hljs-comment">//val != noreg /* tosca_live */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">bool</span> expand_call)</span> </span>&#123;   <span class="hljs-comment">//false /* expand_call */</span><br><br>  Label done;   <span class="hljs-comment">//跳转标签 done 完成</span><br>  Label runtime;  <span class="hljs-comment">//跳转标签 runtime</span><br><br>  <span class="hljs-comment">//static ByteSize satb_mark_queue_offset()  &#123; return byte_offset_of(JavaThread, _satb_mark_queue); &#125;</span><br>  <span class="hljs-comment">//通过类的函数获取 JavaThread 的 satb 相关信息</span><br>  <span class="hljs-function">Address <span class="hljs-title">in_progress</span><span class="hljs-params">(thread, in_bytes(JavaThread::satb_mark_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_active()))</span></span>;<br>  <span class="hljs-function">Address <span class="hljs-title">index</span><span class="hljs-params">(thread, in_bytes(JavaThread::satb_mark_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_index()))</span></span>;<br>  <span class="hljs-function">Address <span class="hljs-title">buffer</span><span class="hljs-params">(thread, in_bytes(JavaThread::satb_mark_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_buf()))</span></span>;<br><br><br>  <span class="hljs-comment">// Is marking active? 是否处于并发标记阶段？</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_bytes</span>(PtrQueue::<span class="hljs-built_in">byte_width_of_active</span>()) == <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-built_in">cmpl</span>(in_progress, <span class="hljs-number">0</span>);       <span class="hljs-comment">//比较 _active 是否为 0，0需要跳转到 done ，即不需要写屏障</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">cmpb</span>(in_progress, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// Do we need to load the previous value? 空对象不需要写屏障</span><br>  <span class="hljs-keyword">if</span> (obj != noreg) &#123;<br>    <span class="hljs-built_in">load_heap_oop</span>(pre_val, <span class="hljs-built_in">Address</span>(obj, <span class="hljs-number">0</span>));<br>  &#125;<br><br>  <span class="hljs-comment">// Is the previous value null?    比较 pre_val 是否为空，空也不需要写屏障，直接跳转到 done</span><br>  <span class="hljs-built_in">cmpptr</span>(pre_val, (<span class="hljs-type">int32_t</span>) NULL_WORD);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// Can we store original value in the thread&#x27;s buffer?</span><br>  <span class="hljs-comment">// Is index == 0?</span><br>  <span class="hljs-comment">// (The index field is typed as size_t.)</span><br><br>  <span class="hljs-built_in">movptr</span>(tmp, index);                   <span class="hljs-comment">// tmp := *index_adr</span><br>  <span class="hljs-built_in">cmpptr</span>(tmp, <span class="hljs-number">0</span>);                       <span class="hljs-comment">// tmp == 0?</span><br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, runtime);       <span class="hljs-comment">// If yes, goto runtime 比较 _index是否 0 。为 0 意味着当前线程的 </span><br>                                        <span class="hljs-comment">// satb 队列满了，此时需要通过运行时调用，交给其他线程处理，具体为跳转到 bind(runtime) 处 </span><br><br>  <span class="hljs-comment">// 计算 pre_val 的入队位置</span><br>  <span class="hljs-built_in">subptr</span>(tmp, wordSize);                <span class="hljs-comment">// tmp := tmp - wordSize  将 _index 减去 oopSize</span><br>  <span class="hljs-built_in">movptr</span>(index, tmp);                   <span class="hljs-comment">// *index_adr := tmp</span><br>  <span class="hljs-built_in">addptr</span>(tmp, buffer);                  <span class="hljs-comment">// tmp := tmp + *buffer_adr</span><br><br>  <span class="hljs-comment">// Record the previous value 将 pre_val 入队</span><br>  <span class="hljs-built_in">movptr</span>(<span class="hljs-built_in">Address</span>(tmp, <span class="hljs-number">0</span>), pre_val);<br>  <span class="hljs-built_in">jmp</span>(done);<br><br>  <span class="hljs-built_in">bind</span>(runtime);<br>  <span class="hljs-comment">// 运行时，最终会调用 SharedRuntime::g1_wb_pre ，这里会在运行时章节展开</span><br>  <span class="hljs-built_in">bind</span>(done);<br>&#125;<br></code></pre></td></tr></table></figure><p>不难发现，整体实现与伪代码类似，完成了对前值的入队。</p><h2 id="g1-write-barrier-post-在解释运行中的实现"><a href="#g1-write-barrier-post-在解释运行中的实现" class="headerlink" title="g1_write_barrier_post 在解释运行中的实现"></a>g1_write_barrier_post 在解释运行中的实现</h2><p>g1_write_barrier_post 的伪代码如下</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs smali">def evacuation_write_barrier(obj, field, newobj):<br> <span class="hljs-built_in"> check </span>= obj ^ newobj<br> <span class="hljs-built_in"> check </span>=<span class="hljs-built_in"> check </span>&gt;&gt; LOG_OF_HEAP_REGION_SIZE<br> <span class="hljs-built_in"> if </span>newobj == Null:<br>   <span class="hljs-built_in"> check </span>= 0<br> <span class="hljs-built_in"> if </span>check == 0:<br>   <span class="hljs-built_in"> return</span><br><span class="hljs-built_in"></span><br> <span class="hljs-built_in"> if </span>not is_dirty_card(obj):<br>    to_dirty(obj)<br>    enqueue($current_thread.rs_log, obj)<br><br>  *field = newobj<br></code></pre></td></tr></table></figure><p>过滤 obj 和 newobj 位于同一个区域，或者 newobj 为 Null 的时候， is_dirty_card() 用来检查参数 obj 所对应的卡片是否<br>为脏卡片。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MacroAssembler::g1_write_barrier_post</span><span class="hljs-params">(Register store_addr,     <span class="hljs-comment">// rdx /* store_adr */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register new_val,        <span class="hljs-comment">// new_val /* new_val */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register thread,         <span class="hljs-comment">// r15_thread /* thread */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register tmp,            <span class="hljs-comment">// r8 /* tmp */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register tmp2)</span> </span>&#123;         <span class="hljs-comment">// rbx /* tmp2 */</span><br><br>  <span class="hljs-comment">//此处获取 dirty_card 的 _index 与 _buf</span><br>  <span class="hljs-function">Address <span class="hljs-title">queue_index</span><span class="hljs-params">(thread, in_bytes(JavaThread::dirty_card_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_index()))</span></span>;<br>  <span class="hljs-function">Address <span class="hljs-title">buffer</span><span class="hljs-params">(thread, in_bytes(JavaThread::dirty_card_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_buf()))</span></span>;<br><br>  BarrierSet* bs = Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">barrier_set</span>();<br>  CardTableModRefBS* ct = (CardTableModRefBS*)bs;<br><br>  Label done;<br>  Label runtime;<br><br>  <span class="hljs-comment">// Does store cross heap regions? 只有跨界引用需要被记录</span><br><br>  <span class="hljs-built_in">movptr</span>(tmp, store_addr);<br>  <span class="hljs-built_in">xorptr</span>(tmp, new_val);<br>  <span class="hljs-built_in">shrptr</span>(tmp, HeapRegion::LogOfHRGrainBytes);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// crosses regions, storing NULL? Null 对象不需要被记录 Null 时跳转到 done</span><br><br>  <span class="hljs-built_in">cmpptr</span>(new_val, (<span class="hljs-type">int32_t</span>) NULL_WORD);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// storing region crossing non-NULL, is card already dirty? 已经脏的话，卡片不需要重复置脏</span><br><br>  <span class="hljs-type">const</span> Register card_addr = tmp;<br>  <span class="hljs-type">const</span> Register cardtable = tmp2;<br><br>  <span class="hljs-built_in">movptr</span>(card_addr, store_addr);<br>  <span class="hljs-built_in">shrptr</span>(card_addr, CardTableModRefBS::card_shift); <span class="hljs-comment">//右移操作，找到当前对象对应的卡片</span><br>  <span class="hljs-built_in">movptr</span>(cardtable, (<span class="hljs-type">intptr_t</span>)ct-&gt;byte_map_base);<br>  <span class="hljs-built_in">addptr</span>(card_addr, cardtable);<br><br>  <span class="hljs-comment">//源码很清晰地说明了，G1 不维护从 young gen Region 出发的引用涉及到的 Rset 更新</span><br>  <span class="hljs-built_in">cmpb</span>(<span class="hljs-built_in">Address</span>(card_addr, <span class="hljs-number">0</span>), (<span class="hljs-type">int</span>)G1SATBCardTableModRefBS::<span class="hljs-built_in">g1_young_card_val</span>()); <br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-built_in">membar</span>(Assembler::<span class="hljs-built_in">Membar_mask_bits</span>(Assembler::StoreLoad));  <span class="hljs-comment">//写读屏障，相关知识指令乱序，内存序</span><br>  <span class="hljs-built_in">cmpb</span>(<span class="hljs-built_in">Address</span>(card_addr, <span class="hljs-number">0</span>), (<span class="hljs-type">int</span>)CardTableModRefBS::<span class="hljs-built_in">dirty_card_val</span>()); <span class="hljs-comment">//判断卡片是否脏 </span><br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br><br>  <span class="hljs-comment">// storing a region crossing, non-NULL oop, card is clean.</span><br>  <span class="hljs-comment">// dirty card and log.</span><br><br>  <span class="hljs-built_in">movb</span>(<span class="hljs-built_in">Address</span>(card_addr, <span class="hljs-number">0</span>), (<span class="hljs-type">int</span>)CardTableModRefBS::<span class="hljs-built_in">dirty_card_val</span>());  <span class="hljs-comment">//卡片置脏</span><br><br>  <span class="hljs-built_in">cmpl</span>(queue_index, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, runtime); <span class="hljs-comment">//当前线程队列是否已满，已满转运行时（同 pre_barrier）</span><br>  <span class="hljs-comment">//不满就入队</span><br>  <span class="hljs-built_in">subl</span>(queue_index, wordSize);<br>  <span class="hljs-built_in">movptr</span>(tmp2, buffer);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LP64</span><br>  <span class="hljs-built_in">movslq</span>(rscratch1, queue_index);<br>  <span class="hljs-built_in">addq</span>(tmp2, rscratch1);    <span class="hljs-comment">//将 _index 减去 oopSize</span><br>  <span class="hljs-built_in">movq</span>(<span class="hljs-built_in">Address</span>(tmp2, <span class="hljs-number">0</span>), card_addr);  <span class="hljs-comment">//入队</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-built_in">addl</span>(tmp2, queue_index);  <span class="hljs-comment">//将 _index 减去 oopSize</span><br>  <span class="hljs-built_in">movl</span>(<span class="hljs-built_in">Address</span>(tmp2, <span class="hljs-number">0</span>), card_addr);  <span class="hljs-comment">//入队</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-built_in">jmp</span>(done);<br><br>  <span class="hljs-built_in">bind</span>(runtime);<br>  <span class="hljs-comment">// save the live input values</span><br>  <span class="hljs-built_in">push</span>(store_addr);<br>  <span class="hljs-built_in">push</span>(new_val);<br>  <span class="hljs-comment">//调用运行时 SharedRuntime::g1_wb_post</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LP64</span><br>  <span class="hljs-built_in">call_VM_leaf</span>(<span class="hljs-built_in">CAST_FROM_FN_PTR</span>(address, SharedRuntime::g1_wb_post), card_addr, r15_thread);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-built_in">push</span>(thread);<br>  <span class="hljs-built_in">call_VM_leaf</span>(<span class="hljs-built_in">CAST_FROM_FN_PTR</span>(address, SharedRuntime::g1_wb_post), card_addr, thread);<br>  <span class="hljs-built_in">pop</span>(thread);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-built_in">pop</span>(new_val);<br>  <span class="hljs-built_in">pop</span>(store_addr);<br><br>  <span class="hljs-built_in">bind</span>(done);<br>&#125;<br></code></pre></td></tr></table></figure><p>整体逻辑与伪代码类似， 源码的注释已经能够说明过程了，此处不作赘述。</p><h1 id="write-barrier-在C2编译的实现"><a href="#write-barrier-在C2编译的实现" class="headerlink" title="write-barrier 在C2编译的实现"></a>write-barrier 在C2编译的实现</h1><p>依旧是如下例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况 1 ：假设 G1 正在并发标记，对象 t 作为根对象已经被标记（灰色），但是 t 引用的对象还没被标记</span><br><span class="hljs-comment">//情况 2 ：假设对象 young 和 t 分别在不同的 Region 中</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">young</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<span class="hljs-comment">//步骤 1</span><br>t.next = young;<span class="hljs-comment">//步骤 2</span><br><span class="hljs-comment">//上述两种情况都需要在步骤 2 完成前记录下相关信息</span><br></code></pre></td></tr></table></figure><p>当触发 C2 编译时，首先根据字节码创建理想图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/parse2.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parse::do_one_bytecode</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">bc</span>()) &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">case</span> Bytecodes::_putfield:<br>      <span class="hljs-built_in">do_putfield</span>();<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/opto/parse.hpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_putfield</span> <span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">do_field_access</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>); &#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/opto/parse3.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parse::do_field_access</span><span class="hljs-params">(<span class="hljs-type">bool</span> is_get, <span class="hljs-type">bool</span> is_field)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (is_get) &#123;<br>      (<span class="hljs-type">void</span>) <span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// pop receiver before getting</span><br>      <span class="hljs-built_in">do_get_xxx</span>(obj, field, is_field);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">do_put_xxx</span>(obj, field, is_field);<br>      (<span class="hljs-type">void</span>) <span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// pop receiver after putting</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parse::do_put_xxx</span><span class="hljs-params">(Node* obj, ciField* field, <span class="hljs-type">bool</span> is_field)</span> </span>&#123;<br><br>  <span class="hljs-comment">// Store the value.</span><br>  Node* store;<br>  <span class="hljs-keyword">if</span> (bt == T_OBJECT) &#123;<br>    <span class="hljs-type">const</span> TypeOopPtr* field_type;<br>    <span class="hljs-keyword">if</span> (!field-&gt;<span class="hljs-built_in">type</span>()-&gt;<span class="hljs-built_in">is_loaded</span>()) &#123;<br>      field_type = TypeInstPtr::BOTTOM;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      field_type = TypeOopPtr::<span class="hljs-built_in">make_from_klass</span>(field-&gt;<span class="hljs-built_in">type</span>()-&gt;<span class="hljs-built_in">as_klass</span>());<br>    &#125;<br>    store = <span class="hljs-built_in">store_oop_to_object</span>(<span class="hljs-built_in">control</span>(), obj, adr, adr_type, val, field_type, bt, mo);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    store = <span class="hljs-built_in">store_to_memory</span>(<span class="hljs-built_in">control</span>(), adr, val, bt, adr_type, mo, is_vol);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.hpp</span><br>  <span class="hljs-function">Node* <span class="hljs-title">store_oop_to_object</span><span class="hljs-params">(Node* ctl,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* obj,   <span class="hljs-comment">// containing obj</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* adr,   <span class="hljs-comment">// actual adress to store val at</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> TypePtr* adr_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* val,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> TypeOopPtr* val_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                            BasicType bt,</span></span><br><span class="hljs-params"><span class="hljs-function">                            MemNode::MemOrd mo)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">store_oop</span>(ctl, obj, adr, adr_type, val, val_type, bt, <span class="hljs-literal">false</span>, mo);<br>  &#125;<br></code></pre></td></tr></table></figure><p>创建详细过程可以读者自行理解，此处只关注调用关系，最终调用到 store_oop </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.cpp</span><br><br><span class="hljs-function">Node* <span class="hljs-title">GraphKit::store_oop</span><span class="hljs-params">(<span class="hljs-comment">/* 参数 */</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">pre_barrier</span>(<span class="hljs-literal">true</span> <span class="hljs-comment">/* do_load */</span>, <span class="hljs-built_in">control</span>(), obj, adr, adr_idx, val, val_type, <span class="hljs-literal">NULL</span> <span class="hljs-comment">/* pre_val */</span>, bt);<br><br>  Node* store = <span class="hljs-built_in">store_to_memory</span>(<span class="hljs-built_in">control</span>(), adr, val, bt, adr_idx, mo, mismatched);<br><br>  <span class="hljs-built_in">post_barrier</span>(<span class="hljs-built_in">control</span>(), store, obj, adr, adr_idx, val, bt, use_precise);<br>  <span class="hljs-keyword">return</span> store;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 store_to_memory 函数的前后分别加入了 pre_barrier 和 post_barrier 当函数需要 C2 编译运行，同时 GC 选用的是 G1GC 时，会在解析字节码时就为 write_barrier 生成相关的结点。</p><h2 id="pre-barrier-在C2编译中的实现"><a href="#pre-barrier-在C2编译中的实现" class="headerlink" title="pre_barrier 在C2编译中的实现"></a>pre_barrier 在C2编译中的实现</h2><p>接下来追溯 pre_barrier 到底生成了哪些节点， </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::pre_barrier</span><span class="hljs-params">(<span class="hljs-comment">/*..*/</span>)</span> </span>&#123;<br><br>  BarrierSet* bs = Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">barrier_set</span>();<br>  <span class="hljs-built_in">set_control</span>(ctl);<br>  <span class="hljs-comment">//与模板解释器相同，需要根据选项选择 barrier 此处只关心 G1GC 部分</span><br>  <span class="hljs-keyword">switch</span> (bs-&gt;<span class="hljs-built_in">kind</span>()) &#123;<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCT:<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCTLogging:<br>      <span class="hljs-built_in">g1_write_barrier_pre</span>(do_load, obj, adr, adr_idx, val, val_type, pre_val, bt);<br>      <span class="hljs-keyword">break</span>;<br>  <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// G1 pre/post barriers</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::g1_write_barrier_pre</span><span class="hljs-params">(<span class="hljs-type">bool</span> do_load,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* obj,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    uint alias_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* val,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> TypeOopPtr* val_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* pre_val,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    BasicType bt)</span> </span>&#123;<br><br>  <span class="hljs-comment">// Some sanity checks</span><br>  <span class="hljs-comment">// Note: val is unused in this routine.</span><br><br>  <span class="hljs-function">IdealKit <span class="hljs-title">ideal</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>)</span></span>;<br><br>  Node* tls = __ <span class="hljs-built_in">thread</span>(); <span class="hljs-comment">// ThreadLocalStorage</span><br><br>  Node* no_ctrl = <span class="hljs-literal">NULL</span>;<br>  Node* no_base = __ <span class="hljs-built_in">top</span>();<br>  Node* zero  = __ <span class="hljs-built_in">ConI</span>(<span class="hljs-number">0</span>);<br>  Node* zeroX = __ <span class="hljs-built_in">ConX</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">float</span> likely  = <span class="hljs-built_in">PROB_LIKELY</span>(<span class="hljs-number">0.999</span>);<br>  <span class="hljs-type">float</span> unlikely  = <span class="hljs-built_in">PROB_UNLIKELY</span>(<span class="hljs-number">0.999</span>);<br><br>  BasicType active_type = <span class="hljs-built_in">in_bytes</span>(PtrQueue::<span class="hljs-built_in">byte_width_of_active</span>()) == <span class="hljs-number">4</span> ? T_INT : T_BYTE;<br> <br>  <span class="hljs-comment">// Offsets into the thread 根据 thread 得到需要值的偏移地址</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> marking_offset = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">satb_mark_queue_offset</span>() +  <span class="hljs-comment">// 648</span><br>                                          PtrQueue::<span class="hljs-built_in">byte_offset_of_active</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> index_offset   = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">satb_mark_queue_offset</span>() +  <span class="hljs-comment">// 656</span><br>                                          PtrQueue::<span class="hljs-built_in">byte_offset_of_index</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffer_offset  = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">satb_mark_queue_offset</span>() +  <span class="hljs-comment">// 652</span><br>                                          PtrQueue::<span class="hljs-built_in">byte_offset_of_buf</span>());<br><br>  <span class="hljs-comment">// Now the actual pointers into the thread 加法节点获取计算得到的地址</span><br>  Node* marking_adr = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(marking_offset));<br>  Node* buffer_adr  = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(buffer_offset));<br>  Node* index_adr   = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(index_offset));<br><br>  <span class="hljs-comment">// Now some of the values</span><br>  Node* marking = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), marking_adr, TypeInt::INT, active_type, Compile::AliasIdxRaw);<br><br>  <span class="hljs-comment">// if (!marking) 判断是否为并发标记阶段</span><br>  <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(marking, BoolTest::ne, zero, unlikely)</span></span>; &#123;<br>    BasicType index_bt = TypeX_X-&gt;<span class="hljs-built_in">basic_type</span>();<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>) == <span class="hljs-built_in">type2aelembytes</span>(index_bt), <span class="hljs-string">&quot;Loading G1 PtrQueue::_index with wrong size.&quot;</span>);<br>    Node* index   = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);<br><br>    <span class="hljs-keyword">if</span> (do_load) &#123;<br>      <span class="hljs-comment">// load original value</span><br>      <span class="hljs-comment">// alias_idx correct??</span><br>      pre_val = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), adr, val_type, bt, alias_idx);<br>    &#125;<br><br>    <span class="hljs-comment">// if (pre_val != NULL) 判断域之前的值是否为空</span><br>    <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(pre_val, BoolTest::ne, null())</span></span>; &#123;<br>      Node* buffer  = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);<br><br>      <span class="hljs-comment">// is the queue for this thread full? 当前线程的 satb 队列是否已满，已满会调用运行时的 g1_wb_pre</span><br>      <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(index, BoolTest::ne, zeroX, likely)</span></span>; &#123;<br><br>        <span class="hljs-comment">// decrement the index</span><br>        Node* next_index = _gvn.<span class="hljs-built_in">transform</span>(<span class="hljs-built_in">new</span> (C) <span class="hljs-built_in">SubXNode</span>(index, __ <span class="hljs-built_in">ConX</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">intptr_t</span>))));<br><br>        <span class="hljs-comment">// Now get the buffer location we will log the previous value into and store it 入队</span><br>        Node *log_addr = __ <span class="hljs-built_in">AddP</span>(no_base, buffer, next_index);<br>        <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br>        <span class="hljs-comment">// update the index</span><br>        <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br><br>      &#125; <span class="hljs-function">__ <span class="hljs-title">else_</span><span class="hljs-params">()</span></span>; &#123;<br><br>        <span class="hljs-comment">// logging buffer is full, call the runtime 运行时 g1_wb_pre 函数与模板解释器调用的是同一个</span><br>        <span class="hljs-type">const</span> TypeFunc *tf = OptoRuntime::<span class="hljs-built_in">g1_wb_pre_Type</span>();<br>        <span class="hljs-function">__ <span class="hljs-title">make_leaf_call</span><span class="hljs-params">(tf, CAST_FROM_FN_PTR(address, SharedRuntime::g1_wb_pre), <span class="hljs-string">&quot;g1_wb_pre&quot;</span>, pre_val, tls)</span></span>;<br>      &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// (!index)</span><br>    &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// (pre_val != NULL)</span><br>  &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// (!marking)</span><br><br>  <span class="hljs-comment">// Final sync IdealKit and GraphKit.</span><br>  <span class="hljs-built_in">final_sync</span>(ideal);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>整体逻辑类似，判断 pre_val 是否空，线程队列是否满，根据判断结果调用运行时或者生成将 pre_val 入栈的节点<br>在生成理想图节点后，C2编译器会对理想图做优化，最后生成机器代码，详细过程如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PhaseTraceId</span> &#123;<br>_t_parser, <span class="hljs-comment">// 1. 字节码解析与理想图生成</span><br>_t_optimizer, <span class="hljs-comment">// 2. 机器无关优化</span><br>...<br>_t_matcher, <span class="hljs-comment">// 3. 指令选择</span><br>_t_scheduler, <span class="hljs-comment">// 4. 指令调度和全局代码提出</span><br>_t_registerAllocation, <span class="hljs-comment">// 5. 寄存器分配</span><br>...<br>_t_blockOrdering, <span class="hljs-comment">// 6. 移除空基本块</span><br>_t_peephole, <span class="hljs-comment">// 7. 窥孔优化</span><br>_t_postalloc_expand,<br>_t_output, <span class="hljs-comment">// 8. 生成机器代码</span><br>...<br>_t_registerMethod, <span class="hljs-comment">// 9. 用编译生成的方法代替Java方法</span><br>_t_tec,<br>max_phase_timers<br>&#125;;<br></code></pre></td></tr></table></figure><p>这部分不是本文关注的重点，为了方便研究 C2 编译结果可以通过 slowdebug 版本的 hotspot ，在运行程序时添加参数 -XX:+PrintOptoAssembly 查看 Opto （也可以直接查看汇编，但是 Opto 更直观），仍以上文例子为例可以在x86平台得到如下两段 Opto 节选，分别是 G1GC 与其他不会产生 pre_barrier 的 GC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无 pre_barrier</span><br>movq    [R10 + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)], RBP# ptr ! Field: Node.next <span class="hljs-comment">//将寄存器RBP中的新值写入内存</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">B5: #B13 B6 &lt;- B4  Freq: <span class="hljs-number">0.999979</span><br># TLS is in R15<br>movsbl  R10, [R15 + #<span class="hljs-number">1424</span> (<span class="hljs-number">32</span>-bit)]# <span class="hljs-type">byte</span>                  <br>testl   R10, R10                                        <br>jne     B13  P=<span class="hljs-number">0.001000</span> C=-<span class="hljs-number">1.000000</span>   <span class="hljs-comment">//if (!marking) -&gt;B13</span><br><br>B13: #B6 B14 &lt;- B5  Freq: <span class="hljs-number">0.000999966</span><br>movq    RDI, [RBX + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)]# ptr ! Field: Node.next  <span class="hljs-comment">//pre_val</span><br>testq   RDI, RDI# ptr         <br>je     B6  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>   <span class="hljs-comment">//if (pre_val != NULL) -&gt;B14</span><br><br>B14: #B19 B15 &lt;- B13  Freq: <span class="hljs-number">0.000499983</span><br># TLS is in R15<br>movq    R10, [R15 + #<span class="hljs-number">1440</span> (<span class="hljs-number">32</span>-bit)]# <span class="hljs-type">long</span><br>testq   R10, R10<br>je,s   B19  P=<span class="hljs-number">0.001000</span> C=-<span class="hljs-number">1.000000</span>  <span class="hljs-comment">// is the queue for this thread full? full -&gt; B19 else -&gt; B15</span><br><br>B19: #B6 &lt;- B14  Freq: <span class="hljs-number">4.99977e-07</span><br># TLS is in R15<br>movq    RSI, R15# spill           <span class="hljs-comment">// logging buffer is full</span><br>call_leaf,runtime  g1_wb_pre        <span class="hljs-comment">// 调用运行时函数 g1_wb_pre</span><br>  No JVM State Info<br>  # <br>jmp     B6<br><br>B15: #B6 &lt;- B14  Freq: <span class="hljs-number">0.000499483</span><br># TLS is in R15<br>movq    R11, [R15 + #<span class="hljs-number">1432</span> (<span class="hljs-number">32</span>-bit)]# ptr<br>movq    [R11 + #-<span class="hljs-number">8</span> + R10], RDI# ptr   <span class="hljs-comment">// pre_val 入队</span><br>addq    R10, #-<span class="hljs-number">8</span># <span class="hljs-type">long</span>    <span class="hljs-comment">//将 _index 减去 oopSize</span><br># TLS is in R15<br>movq    [R15 + #<span class="hljs-number">1440</span> (<span class="hljs-number">32</span>-bit)], R10# <span class="hljs-type">long</span><br>jmp     B6<br><br>B6: #B12 B7 &lt;- B19 B15 B13 B5  Freq: <span class="hljs-number">0.999979</span><br>movq    [RBX + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)], RBP# ptr ! Field: Node.next  <span class="hljs-comment">//新值写入域</span><br><br></code></pre></td></tr></table></figure><p>整体过程与理想图阶段生成的节点，能一一对应。</p><h2 id="post-barrier-在C2编译中的实现"><a href="#post-barrier-在C2编译中的实现" class="headerlink" title="post_barrier 在C2编译中的实现"></a>post_barrier 在C2编译中的实现</h2><p>post_barrier 的逻辑大体与 pre_barrier 相同，如下会根据 barrier 类型 G1GC 匹配到 g1_write_barrier_post</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.cpp</span><br><span class="hljs-comment">//相同的逻辑，此处不作赘述</span><br>  <span class="hljs-keyword">switch</span> (bs-&gt;<span class="hljs-built_in">kind</span>()) &#123;<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCT:<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCTLogging:<br>      <span class="hljs-built_in">g1_write_barrier_post</span>(store, obj, adr, adr_idx, val, bt, use_precise);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::g1_write_barrier_post</span><span class="hljs-params">(Node* oop_store,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     Node* obj,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     Node* adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     uint alias_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     Node* val,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     BasicType bt,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">bool</span> use_precise)</span> </span>&#123;<br>  <span class="hljs-comment">// If we are writing a NULL then we need no post barrier</span><br><br>  <span class="hljs-keyword">if</span> (val != <span class="hljs-literal">NULL</span> &amp;&amp; val-&gt;<span class="hljs-built_in">is_Con</span>() &amp;&amp; val-&gt;<span class="hljs-built_in">bottom_type</span>() == TypePtr::NULL_PTR) &#123;<br>    <span class="hljs-comment">// Must be NULL</span><br>    <span class="hljs-type">const</span> Type* t = val-&gt;<span class="hljs-built_in">bottom_type</span>();<br>    <span class="hljs-built_in">assert</span>(t == Type::TOP || t == TypePtr::NULL_PTR, <span class="hljs-string">&quot;must be NULL&quot;</span>);<br>    <span class="hljs-comment">// No post barrier if writing NULLx</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!use_precise) &#123;<br>    <span class="hljs-comment">// All card marks for a (non-array) instance are in one place:</span><br>    adr = obj;<br>  &#125;<br>  <span class="hljs-comment">// (Else it&#x27;s an array (or unknown), and we want more precise card marks.)</span><br>  <span class="hljs-built_in">assert</span>(adr != <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>  <span class="hljs-function">IdealKit <span class="hljs-title">ideal</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>)</span></span>;<br><br>  Node* tls = __ <span class="hljs-built_in">thread</span>(); <span class="hljs-comment">// ThreadLocalStorage</span><br><br>  Node* no_base = __ <span class="hljs-built_in">top</span>();<br>  <span class="hljs-type">float</span> likely  = <span class="hljs-built_in">PROB_LIKELY</span>(<span class="hljs-number">0.999</span>);<br>  <span class="hljs-type">float</span> unlikely  = <span class="hljs-built_in">PROB_UNLIKELY</span>(<span class="hljs-number">0.999</span>);<br>  Node* young_card = __ <span class="hljs-built_in">ConI</span>((jint)G1SATBCardTableModRefBS::<span class="hljs-built_in">g1_young_card_val</span>());<br>  Node* dirty_card = __ <span class="hljs-built_in">ConI</span>((jint)CardTableModRefBS::<span class="hljs-built_in">dirty_card_val</span>());<br>  Node* zeroX = __ <span class="hljs-built_in">ConX</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Get the alias_index for raw card-mark memory</span><br>  <span class="hljs-type">const</span> TypePtr* card_type = TypeRawPtr::BOTTOM;<br><br>  <span class="hljs-type">const</span> TypeFunc *tf = OptoRuntime::<span class="hljs-built_in">g1_wb_post_Type</span>();<br><br>  <span class="hljs-comment">// Offsets into the thread 获取偏移</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> index_offset  = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">dirty_card_queue_offset</span>() +<br>                                     PtrQueue::<span class="hljs-built_in">byte_offset_of_index</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffer_offset = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">dirty_card_queue_offset</span>() +<br>                                     PtrQueue::<span class="hljs-built_in">byte_offset_of_buf</span>());<br><br>  <span class="hljs-comment">// Pointers into the thread 与 thread 值相加计算具体地址</span><br><br>  Node* buffer_adr = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(buffer_offset));<br>  Node* index_adr =  __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(index_offset));<br><br>  <span class="hljs-comment">// ... 部分优化 与 值获取</span><br><br>  <span class="hljs-comment">// If we know the value being stored does it cross regions? 判断是否产生跨区域</span><br><br>  <span class="hljs-keyword">if</span> (val != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// Does the store cause us to cross regions?</span><br><br>    <span class="hljs-comment">// Should be able to do an unsigned compare of region_size instead of</span><br>    <span class="hljs-comment">// and extra shift. Do we have an unsigned compare??</span><br>    <span class="hljs-comment">// Node* region_size = __ ConI(1 &lt;&lt; HeapRegion::LogOfHRGrainBytes); </span><br>    <br>    <span class="hljs-comment">// 判断方式为 check = obj ^ newobj</span><br>    Node* xor_res =  __ <span class="hljs-built_in">URShiftX</span> ( __ <span class="hljs-built_in">XorX</span>( cast,  __ <span class="hljs-built_in">CastPX</span>(__ <span class="hljs-built_in">ctrl</span>(), val)), __ <span class="hljs-built_in">ConI</span>(HeapRegion::LogOfHRGrainBytes));<br><br>    <span class="hljs-comment">// if (xor_res == 0) same region so skip </span><br>    <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(xor_res, BoolTest::ne, zeroX)</span></span>; &#123;<br><br>      <span class="hljs-comment">// No barrier if we are storing a NULL 如果是 NULL 也不需要 barrier</span><br>      <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(val, BoolTest::ne, null(), unlikely)</span></span>; &#123;<br><br>        <span class="hljs-comment">// Ok must mark the card if not already dirty</span><br><br>        <span class="hljs-comment">// load the original value of the card </span><br>        Node* card_val = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);<br><br>        <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(card_val, BoolTest::ne, young_card)</span></span>; &#123;   <span class="hljs-comment">// 判断是否是 young 区的跨界引用， young 区每次都会被收集，故不维护 Rset</span><br>          <span class="hljs-built_in">sync_kit</span>(ideal);<br>          <span class="hljs-comment">// Use Op_MemBarVolatile to achieve the effect of a StoreLoad barrier.</span><br>          <span class="hljs-built_in">insert_mem_bar</span>(Op_MemBarVolatile, oop_store);<br>          <span class="hljs-function">__ <span class="hljs-title">sync_kit</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br><br>          Node* card_val_reload = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);<br>          <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(card_val_reload, BoolTest::ne, dirty_card)</span></span>; &#123;<span class="hljs-comment">//判断卡片是否已经脏</span><br>            <span class="hljs-comment">// 调用 g1_mark_card 函数 ，该函数的作用为更新卡表，并将卡片地址入队</span><br>            <span class="hljs-built_in">g1_mark_card</span>(ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);<br>          &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>        &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>      &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>    &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Object.clone() instrinsic uses this path.</span><br>    <span class="hljs-built_in">g1_mark_card</span>(ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);<br>  &#125;<br><br>  <span class="hljs-comment">// Final sync IdealKit and GraphKit.</span><br>  <span class="hljs-built_in">final_sync</span>(ideal);<br>&#125;<br><br><span class="hljs-comment">// Update the card table and add card address to the queue</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::g1_mark_card</span><span class="hljs-params">(IdealKit&amp; ideal,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* card_adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* oop_store,</span></span><br><span class="hljs-params"><span class="hljs-function">                            uint oop_alias_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* index,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* index_adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> TypeFunc* tf)</span> </span>&#123;<br><br>  Node* zero  = __ <span class="hljs-built_in">ConI</span>(<span class="hljs-number">0</span>);<br>  Node* zeroX = __ <span class="hljs-built_in">ConX</span>(<span class="hljs-number">0</span>);<br>  Node* no_base = __ <span class="hljs-built_in">top</span>();<br>  BasicType card_bt = T_BYTE;<br>  <span class="hljs-comment">// Smash zero into card. MUST BE ORDERED WRT TO STORE</span><br>  <span class="hljs-function">__ <span class="hljs-title">storeCM</span><span class="hljs-params">(__ ctrl(), card_adr, zero, oop_store, oop_alias_idx, card_bt, Compile::AliasIdxRaw)</span></span>;<br><br>  <span class="hljs-comment">//  Now do the queue work</span><br>  <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(index, BoolTest::ne, zeroX)</span></span>; &#123;<span class="hljs-comment">//如果当前线程队列未满</span><br><br>    Node* next_index = _gvn.<span class="hljs-built_in">transform</span>(<span class="hljs-built_in">new</span> (C) <span class="hljs-built_in">SubXNode</span>(index, __ <span class="hljs-built_in">ConX</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">intptr_t</span>))));<br>    Node* log_addr = __ <span class="hljs-built_in">AddP</span>(no_base, buffer, next_index);<br><br>    <span class="hljs-comment">// Order, see storeCM.</span><br>    <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), log_addr, card_adr, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br>    <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), index_adr, next_index, TypeX_X-&gt;basic_type(), Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br><br>  &#125; <span class="hljs-function">__ <span class="hljs-title">else_</span><span class="hljs-params">()</span></span>; &#123;<span class="hljs-comment">//线程队列已满会调用运行时</span><br>    <span class="hljs-function">__ <span class="hljs-title">make_leaf_call</span><span class="hljs-params">(tf, CAST_FROM_FN_PTR(address, SharedRuntime::g1_wb_post), <span class="hljs-string">&quot;g1_wb_post&quot;</span>, card_adr, __ thread())</span></span>;<br>  &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>理想图部分代码与模板解释器体现的逻辑也是一致的，接下来看看最终生成的 Opto</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">B6: #B12 B7 &lt;- B19 B15 B13 B5  Freq: <span class="hljs-number">0.999979</span><br>movq    [RBX + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)], RBP# ptr ! Field: Node.next <span class="hljs-comment">//完成对象域新值的写入</span><br>movq    R10, RBP# ptr -&gt; <span class="hljs-type">long</span><br>movq    R11, RBX# ptr -&gt; <span class="hljs-type">long</span><br>xorq    R10, R11# <span class="hljs-type">long</span><br>shrq    R10, #<span class="hljs-number">20</span><br>testq   R10, R10<br>je,s   B12  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>    <span class="hljs-comment">//if (xor_res == 0) same region so skip -&gt; B12 ret else -&gt; B7</span><br><br>B7: #B12 B8 &lt;- B6  Freq: <span class="hljs-number">0.499989</span><br>shrq    R11, #<span class="hljs-number">9</span><br>movq    RDI, <span class="hljs-number">0x00007ecf56bf1000</span># ptr<br>addq    RDI, R11# ptr<br>movsbl  R10, [RDI]# <span class="hljs-type">byte</span><br>cmpl    R10, #<span class="hljs-number">32</span><br>je,s   B12  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>  <span class="hljs-comment">// if_then(card_val, BoolTest::ne, young_card) 不用维护 young 区域的 Rset</span><br> <br>B8: #B12 B9 &lt;- B7  Freq: <span class="hljs-number">0.249995</span><br># TLS is in R15<br>movq    R10, [R15 + #<span class="hljs-number">1504</span> (<span class="hljs-number">32</span>-bit)]# <span class="hljs-type">long</span><br># TLS is in R15<br>movq    R11, [R15 + #<span class="hljs-number">1496</span> (<span class="hljs-number">32</span>-bit)]# ptr<br>lock addl [rsp + #<span class="hljs-number">0</span>], <span class="hljs-number">0</span>! membar_volatile <span class="hljs-comment">// 内存序</span><br>movsbl  R9, [RDI]# <span class="hljs-type">byte</span><br>testl   R9, R9<br>je,s   B12  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>   <span class="hljs-comment">// if_then(card_val_reload, BoolTest::ne, dirty_card) 判断卡片是否已经脏</span><br><br>B9: #B11 B10 &lt;- B8  Freq: <span class="hljs-number">0.124997</span>   <br>movb    [RDI], #<span class="hljs-number">0</span># CMS card-mark <span class="hljs-type">byte</span> <span class="hljs-number">0</span>  <span class="hljs-comment">// Smash zero into card. MUST BE ORDERED WRT TO STORE 卡片置为脏</span><br>testq   R10, R10<br>jne,s   B11  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span> <span class="hljs-comment">// if_then(index, BoolTest::ne, zeroX) 判断当前线程队列是否已满</span><br><br>B10: #B12 &lt;- B9  Freq: <span class="hljs-number">0.0624987</span><br># TLS is in R15<br>movq    RSI, R15# spill<br>call_leaf,runtime  g1_wb_post <span class="hljs-comment">// queue full runtime</span><br>  No JVM State Info<br>  # <br>jmp,s   B12<br><br>B11: #B12 &lt;- B9  Freq: <span class="hljs-number">0.0624987</span>  <span class="hljs-comment">//  Now do the queue work 入队</span><br>movq    [R11 + #-<span class="hljs-number">8</span> + R10], RDI# ptr<br>addq    R10, #-<span class="hljs-number">8</span># <span class="hljs-type">long</span>  <span class="hljs-comment">//将 _index 减去 oopSize</span><br># TLS is in R15<br>movq    [R15 + #<span class="hljs-number">1504</span> (<span class="hljs-number">32</span>-bit)], R10# <span class="hljs-type">long</span><br><br>B12: #N1 &lt;- B10 B11 B8 B7 B6  Freq: <span class="hljs-number">0.999979</span><br>addq    rsp, <span class="hljs-number">32</span># Destroy frame<br>popq   rbp<br>testl  rax, [rip + #offset_to_poll_page]# Safepoint: poll <span class="hljs-keyword">for</span> GC<br><br>ret<br><br></code></pre></td></tr></table></figure><h1 id="write-barrier-在运行时的实现"><a href="#write-barrier-在运行时的实现" class="headerlink" title="write-barrier 在运行时的实现"></a>write-barrier 在运行时的实现</h1><p>上文频繁提及，当队列满了会调用运行时实现写屏障，接下来看一下运行时对写屏障的实现</p><h2 id="g1-wb-pre-与-g1-wb-post-在运行时的实现"><a href="#g1-wb-pre-与-g1-wb-post-在运行时的实现" class="headerlink" title="g1_wb_pre 与 g1_wb_post 在运行时的实现"></a>g1_wb_pre 与 g1_wb_post 在运行时的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// G1 write-barrier pre: executed before a pointer store.</span><br><span class="hljs-built_in">JRT_LEAF</span>(<span class="hljs-type">void</span>, SharedRuntime::<span class="hljs-built_in">g1_wb_pre</span>(oopDesc* orig, JavaThread *thread))<br>  <span class="hljs-keyword">if</span> (orig == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;should be optimized out&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">assert</span>(orig-&gt;<span class="hljs-built_in">is_oop</span>(<span class="hljs-literal">true</span> <span class="hljs-comment">/* ignore mark word */</span>), <span class="hljs-string">&quot;Error&quot;</span>);<br>  <span class="hljs-comment">// store the original value that was in the field reference</span><br>  thread-&gt;<span class="hljs-built_in">satb_mark_queue</span>().<span class="hljs-built_in">enqueue</span>(orig);<br>JRT_END<br><br><span class="hljs-comment">// G1 write-barrier post: executed after a pointer store.</span><br><span class="hljs-built_in">JRT_LEAF</span>(<span class="hljs-type">void</span>, SharedRuntime::<span class="hljs-built_in">g1_wb_post</span>(<span class="hljs-type">void</span>* card_addr, JavaThread* thread))<br>  thread-&gt;<span class="hljs-built_in">dirty_card_queue</span>().<span class="hljs-built_in">enqueue</span>(card_addr);<br>JRT_END<br></code></pre></td></tr></table></figure><p>运行时的代码更直观，即将域前值&#x2F;卡片地址入队，其中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// SATB marking queue support</span><br><span class="hljs-function">ObjPtrQueue&amp; <span class="hljs-title">satb_mark_queue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _satb_mark_queue; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> SATBMarkQueueSet&amp; <span class="hljs-title">satb_mark_queue_set</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> _satb_mark_queue_set;<br>&#125;<br><br><span class="hljs-comment">// Dirty card queue support</span><br><span class="hljs-function">DirtyCardQueue&amp; <span class="hljs-title">dirty_card_queue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _dirty_card_queue; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> DirtyCardQueueSet&amp; <span class="hljs-title">dirty_card_queue_set</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> _dirty_card_queue_set;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些值在<a href="#g1_write_barrier_pre">上文</a>曾多次提及</p><p>根据上面对模板解释器和 C2 编译的分析，只有当当前线程队列满时才会调用到运行时，追溯 enqueue 的实现，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ObjPtrQueue _satb_mark_queue;          <span class="hljs-comment">// Thread-local log for SATB barrier.</span><br>DirtyCardQueue _dirty_card_queue;      <span class="hljs-comment">// Thread-local log for dirty cards.</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjPtrQueue</span>: <span class="hljs-keyword">public</span> PtrQueue&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirtyCardQueue</span>: <span class="hljs-keyword">public</span> PtrQueue&#123;&#125;<br><br></code></pre></td></tr></table></figure><p>enqueue 函数的实现在 ObjPtrQueue 与 DirtyCardQueue 类的共同父类 PtrQueue 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/gc_implementation/g1/ptrQueue.hpp</span><br>  <span class="hljs-comment">// Enqueues the given &quot;obj&quot;.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!_active) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">enqueue_known_active</span>(ptr);<br>  &#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/gc_implementation/g1/ptrQueue.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueue::enqueue_known_active</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br><br>  <span class="hljs-keyword">while</span> (_index == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//当前线程已满调用 handle_zero_index 函数</span><br>    <span class="hljs-built_in">handle_zero_index</span>();  <span class="hljs-comment">//handle_zero_index 函数会为线程私有队列置申请新空间，并重置 _index 为 size</span><br>  &#125;<br><br>  <span class="hljs-comment">// 将 _index 减去 oopSize，并将对象指针入队</span><br>  _index -= oopSize;<br>  _buf[<span class="hljs-built_in">byte_index_to_index</span>((<span class="hljs-type">int</span>)_index)] = ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueue::handle_zero_index</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(_index == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Precondition.&quot;</span>);<br><br>  <span class="hljs-comment">// This thread records the full buffer and allocates a new one (while</span><br>  <span class="hljs-comment">// holding the lock if there is one).</span><br>  <span class="hljs-keyword">if</span> (_buf != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">should_enqueue_buffer</span>()) &#123;<br>      <span class="hljs-built_in">assert</span>(_index &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;the buffer can only be re-used if it&#x27;s not full&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_lock) &#123;<br>      <span class="hljs-built_in">assert</span>(_lock-&gt;<span class="hljs-built_in">owned_by_self</span>(), <span class="hljs-string">&quot;Required.&quot;</span>);<br><br>      <span class="hljs-type">void</span>** buf = _buf;   <span class="hljs-comment">// local pointer to completed buffer</span><br>      _buf = <span class="hljs-literal">NULL</span>;         <span class="hljs-comment">// clear shared _buf field</span><br><br>      <span class="hljs-built_in">locking_enqueue_completed_buffer</span>(buf);  <span class="hljs-comment">// enqueue completed buffer 将线程私有的队列加入链表</span><br><br>      <span class="hljs-keyword">if</span> (_buf != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// Reallocate the buffer 重新为当前线程的队列申请新空间，再将 _index = _sz</span><br>  _buf = <span class="hljs-built_in">qset</span>()-&gt;<span class="hljs-built_in">allocate_buffer</span>();<br>  _sz = <span class="hljs-built_in">qset</span>()-&gt;<span class="hljs-built_in">buffer_size</span>();<br>  _index = _sz;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span> &lt;= _index &amp;&amp; _index &lt;= _sz, <span class="hljs-string">&quot;Invariant.&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueue::locking_enqueue_completed_buffer</span><span class="hljs-params">(<span class="hljs-type">void</span>** buf)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(_lock-&gt;<span class="hljs-built_in">owned_by_self</span>(), <span class="hljs-string">&quot;Required.&quot;</span>);<br><br>  <span class="hljs-comment">// We have to unlock _lock (which may be Shared_DirtyCardQ_lock) before</span><br>  <span class="hljs-comment">// we acquire DirtyCardQ_CBL_mon inside enqeue_complete_buffer as they</span><br>  <span class="hljs-comment">// have the same rank and we may get the &quot;possible deadlock&quot; message</span><br>  _lock-&gt;<span class="hljs-built_in">unlock</span>();<br><br>  <span class="hljs-built_in">qset</span>()-&gt;<span class="hljs-built_in">enqueue_complete_buffer</span>(buf); <span class="hljs-comment">//将线程私有的队列加入链表</span><br>  <span class="hljs-comment">// We must relock only because the caller will unlock, for the normal</span><br>  <span class="hljs-comment">// case.</span><br>  _lock-&gt;<span class="hljs-built_in">lock_without_safepoint_check</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueueSet::enqueue_complete_buffer</span><span class="hljs-params">(<span class="hljs-type">void</span>** buf, <span class="hljs-type">size_t</span> index)</span> </span>&#123;<br>  <span class="hljs-function">MutexLockerEx <span class="hljs-title">x</span><span class="hljs-params">(_cbl_mon, Mutex::_no_safepoint_check_flag)</span></span>;<br>  BufferNode* cbn = BufferNode::<span class="hljs-built_in">new_from_buffer</span>(buf);<br>  cbn-&gt;<span class="hljs-built_in">set_index</span>(index);<br>  <span class="hljs-keyword">if</span> (_completed_buffers_tail == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">//链表是否为空</span><br>    <span class="hljs-built_in">assert</span>(_completed_buffers_head == <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Well-formedness&quot;</span>);<br>    _completed_buffers_head = cbn;  <span class="hljs-comment">// 链表头为 buf </span><br>    _completed_buffers_tail = cbn;  <span class="hljs-comment">// 链表尾为 buf</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    _completed_buffers_tail-&gt;<span class="hljs-built_in">set_next</span>(cbn); <span class="hljs-comment">//非空时候 buf 加入链表末尾</span><br>    _completed_buffers_tail = cbn;<br>  &#125;<br>  _n_completed_buffers++; <span class="hljs-comment">//链表长度 +1</span><br>  <span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p id="references"></p>    <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>jdk8源代码</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>G1GC-write barrier</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>G1GC算法篇</title>
    <link href="/2022/12/20/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    <url>/2022/12/20/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将通过对G1的整个回收周期的算法原理进行解读，如有偏差，请指正。<span id="more"></span></p><p>G1GC(Garbage First Garbage Collection)(简称G1) 自 JDK9 起，替代 Parallel Scavenge 和 Parallel Old 的组合，作为 Hotspot 在 Server 端的默认垃圾回收器，具有停顿时间可控、不产生内存碎片、返还未使用内存给堆等的特性，在 JDK9 之前可以通过 -XX:+UseG1G C的参数调用 G1 。</p><h1 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h1><p>在深入 G1GC 算法之前，先建立以下基本概念，如果读者已经掌握相关知识可以跳过这一部分，如果完全不了解这些概念，可以尝试简单了解一部分。</p><h2 id="自动内存管理系统"><a href="#自动内存管理系统" class="headerlink" title="自动内存管理系统"></a>自动内存管理系统</h2><p>在《 Java 虚拟机规范》中将 Java 堆描述为：“ The heap is the runtime data area form which memory for all class instances and arrays is allocated ” （随着 Java 语言的发展，“所有对象实例及数组都在堆上分配”这一点也不绝对）。Java 堆作为自动内存管理的内存区域，需要满足能在上面为新对象分配内存，并自动释放死亡对象所占据内存的功能，细分下就是需要回答下面三个问题：</p><ul><li>如何在堆上为新对象分配内存？</li><li>如何识别存活对象？</li><li>如何回收死亡对象占据的内存？</li></ul><p>对应到 G1GC 的算法，将从下面几点回答这三个问题：</p><ul><li>G1GC 堆结构（分配对象）</li><li>G1GC 并发标记（识别存活对象）</li><li>G1GC 跨界引用的标记（识别存活对象）</li><li>G1GC 转移对象过程（回收死亡对象）</li></ul><h2 id="软实时性"><a href="#软实时性" class="headerlink" title="软实时性"></a>软实时性</h2><p>G1GC 具有软实时性（ soft real-time ）。由于多数 GC 需要暂停应用程序，为了保证应用程序的软实时性（能保证大多数任务在最后期限之前完成，例如网络银行系统），我们要求 G1 ，在任意 1 秒的时间内，停顿不得超过 200ms 。G1 会尽量达成这个目标，它能够推算出本次要收集的大体区域，以增量的方式完成收集。</p><ul><li>设置<code>期望暂停时间</code>（ -XX:MaxGCPauseMillis ，默认 200）</li></ul><h2 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h2><p>GC 时判断哪些对象需要被回收有两种方法，引用计数法和可达性分析法。其中，G1 使用可达性分析算法通过一系列 <code>GC Roots</code> 作为起始点搜索所有通过引用可达的对象，搜索的路径称为引用链（ Reference Chain ），所有能被搜索到的对象被认为（标记为）存活对象。可作为 GC Roots 的对象包括但不限于下面几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>在方法区中类静态属性引用的对象</li><li>在方法区中常量引用的对象</li><li>本地方法栈中 JNI（ Native 方法）引用的对象</li></ul><p>下面是一段Java示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Obj</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<span class="hljs-comment">// a 为 root ，对象的引用</span><br>a.ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>(); <span class="hljs-comment">// a 的成员ref赋值变量的引用，当前可达</span><br><span class="hljs-comment">//System.gc();//如果此时发生 GC ，标记过程会从 a（ GC Root ）出发标记 a 指向的对象，再标记 a.ref 指向的对象</span><br>a = <span class="hljs-literal">null</span>;  <span class="hljs-comment">//a 指向的对象被回收，a.ref 指向的对象也需要被回收</span><br></code></pre></td></tr></table></figure><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>顾名思义，通过三种颜色完成标记，</p><ul><li>白色：表示对象尚未被垃圾收集器标记过。</li><li>黑色：表示对象已经被垃圾收集器标记过，且这个对象的所有引用都已经扫描标记过。</li><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过，可以理解为正在搜索的对象。</li></ul><p>简述三色标记法的遍历过程：</p><ol><li>初始时，全部对象都是白色的</li><li>GC Roots 直接引用的对象变成灰色</li><li>从灰色集合中获取元素：<ul><li>将本对象直接引用的对象标记为灰色</li><li>将本对象标记为黑色</li></ul></li><li>重复步骤3，直到灰色的对象集合变为空</li><li>结束后，仍然被标记为白色的对象就是不可达对象，视为垃圾对象</li></ol><p>对象在并发标记阶段会被漏标的充分必要条件是（同时满足以下两点）：</p><ul><li>Mutator 应用程序插入了一个从黑色对象到该白色对象的新引用</li><li>Mutator 应用程序删除了所有从灰色对象到该白色对象的直接或间接引用</li></ul><p id="Copying"></p>   <h2 id="Copying-——-Cheney"><a href="#Copying-——-Cheney" class="headerlink" title="Copying —— Cheney"></a>Copying —— Cheney</h2><p>当标记完成后需要将存活对象转移到特定区域中， G1 的转移逻辑都是基于 Copying 算法思想实现的，算法简略过程如下：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/copy.gif" alt="Copying 算法"></p><h1 id="G1GC-的堆结构"><a href="#G1GC-的堆结构" class="headerlink" title="G1GC 的堆结构"></a>G1GC 的堆结构</h1><p>G1GC 堆的内部被划分为大小相等的 <code>Region</code> ，G1GC 以 Region 为单位进行 GC ，Region 的大小 <code>RegionSize</code> 在 JVM 初始化时初始完毕且在当前 java 进程结束前不会改变。在 HotSpot 的源码中 <code>TARGET_REGION_NUMBER</code> 定义了 Region 的数量限制为 2048 个（实际上允许超过这个值）。一般 RegionSize 等于堆空间的总大小除以 2048 ，也可以用参数 -XX:G1HeapRegionSize 强制指定每个 Region 区的大小用户可以设置 Region 大小，但需要满足 RegionSize 是向上调整为 2 的指数幂，同时需要保证最小不小于 1MB ，最大不超过 32MB （集合 { 1MB , 2MB , 4MB , 8MB , 16MB , 32MB } 内）。</p><p>比如目前的堆空间总大小为 8.5GB ，RegionSize 就是 8704MB&#x2F;2048 &#x3D; 4.25MB ，那么最终每个 Region 的大小为 8MB 。当一个 region 剩余空间不足以满足下一个对象所需空间时， Hotspot 直接放弃 region 中剩余空间，在新分配的 region 中分配对象； OpenJ9 利用剩下的空间，让对象跨 region 存放。</p><h2 id="G1GC-分代分区"><a href="#G1GC-分代分区" class="headerlink" title="G1GC 分代分区"></a>G1GC 分代分区</h2><p>在 G1 收集器中逻辑依旧是分代的，依旧存在年轻代 <code>Eden</code> 区、幸存区 <code>Survivor</code> 、老年代 <code>Old</code> 区，但在物理内存上是不分代的。G1 的每个代区由物理内存不连续的 Region 集合构成，这样做的好处在于：G1 可以优先回收垃圾对象特别多的 Region 区，这样可以花费较少的时间来回收垃圾，这也就是 G1 名字的由来，即垃圾优先收集器。<br>在运行时，G1 会将堆空间变为如下结构：</p><center><img src="/img/G1GC算法篇/G1堆.png" style="zoom:35%" title="分代 G1GC 堆空间划分" ><br>    <div style="color:orange;     color: #999;    padding: 2px;">分代 G1GC 堆空间划分    </div></center><p>新创建的对象都会被分配到 Eden 区，对象经过第一次 YGC 后，仍然存活的会被移到 Survivor 区，多次GC后依然存活的对象会被移动到 Old 区。图中除了提到的三个分区还多了大对象区 <code>Humongous</code> 与 <code>未分配区</code> 。在 G1 中当对象大小超过单个普通 Region 区的 50% 时，认定对象为大对象，大对象会直接将其放入 Humongous 区存储，当一个 Humongous 区存不下时，可能会横跨多个 Region 区存储它。在大多数时 Humongous 区会被当做老年代看待。</p><h2 id="G1GC-新生代动态调整大小"><a href="#G1GC-新生代动态调整大小" class="headerlink" title="G1GC 新生代动态调整大小"></a>G1GC 新生代动态调整大小</h2><p>G1 的设计目标是软实时，应以响应时间优先。 G1 根据基于衰减平均值的停顿预测模型统计以前发生 GC 时记录的数据来预测本次收集需要选择的分区数量。以新生代收集为例（通过添加参数 -XX:+PrintGCDetails 查看）</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%A4%A7%E5%B0%8F.png" alt="新生代动态调整大小"></p><p>如上图彩色框图所示， G1 随着 GC 的发生，根据 GC 耗时动态调整新生代 Eden 区和 Survivor 区的个数，当Eden区满后触发下一次 GC 收集。通过这种方式来保证 GC 带来的最大停顿时间不超过期望暂停时间。当然上图展示的是比较理想的 YGC 过程，G1GC 的收集策略会在后续详细介绍。</p><h1 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h1><p>通常 GC 算法在标记存活对象时，为了避免在标记过程中发生引用关系改变的情况，都需要让应用程序在安全点处停下，也就是常说的<code>Stop The World</code>简称 STW 。G1 在对老年代的标记过程中引入了并发标记，并发指的是与应用程序<code>mutator</code>并发执行。并发标记并不是直接在对象上添加标记，而是在<code>标记位图</code>上添加标记。</p><h2 id="标记位图"><a href="#标记位图" class="headerlink" title="标记位图"></a>标记位图</h2><p>下图表示堆中的一个 region ，位图中黑色表示已标记存活，白色表示未标记为存活。</p><center><img src="/img/G1GC算法篇/标记位图.png" style="zoom:45%" title="标记位图" ><br>    <div style="color:orange;     color: #999;    padding: 2px;">标记位图    </div></center><p>需要强调下，图中为了展示对应关系，将标记位图画得同 region 相对应，实际上标记位图每一格只有 1bit ，而 region 上一块为单个对象，标记位图中的每个 bit 都对应关联 region 内的对象的开头部分。假设单个对象的大小都是 8 个字节（本文后续都如此假定），那么每 8 个字节就会对应标记位图中的 1个bit 。图中标记位图里黑色的地方表示比特值是 1 ，白色的地方表示比特值是 0 。相应地，region 内黑色的是存活对象，带有叉号的是死亡对象。</p><p>每个region有两个标记位图：</p><ul><li><code>next</code>：本次标记的标记位图。</li><li><code>prev</code>：上次标记的标记位图，保存了上次并发标记的结果。</li></ul><p>图中region部分：</p><ul><li><code>bottom</code>：region 内众多对象的末尾</li><li><code>top</code>：region 内众多对象的开头（包括在并发标记过程中新分配的对象）</li><li><code>nextTAMS</code>：本次标记开始时的 top（TAMS-Top At Marking Start）（本次标记从 bottom 到此处）</li><li><code>prevTAMS</code>：上次标记开始时的 top</li></ul><p>并发标记结束主要针对的是 G1 老年代中 region 部分的标记，根据 G1 的清理策略，并不会对所有 region 做垃圾收集（会选择垃圾最多的几个 region 作清理）。所以保存上次标记结果 prev ，用于确定上次标记的存活对象在本次标记后是否能存活，而不扫描上次已经确定死亡的对象。</p><p>下列图展示对同一块 region 两次并发标记始末状态，用来说明 prev 标记位图和 next 标记位图的作用</p><center class = half><img src="/img/G1GC算法篇/第一次并发标记开始.png" height="143" title="第一次并发标记开始状态" ><img src="/img/G1GC算法篇/第一次并发标记完成.png" height="143" title="第一次并发标记完成状态" ><br>    <div style="color:orange; color: #999;padding: 2px;">    第一次并发标记开始状态&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第一次并发标记完成状态    </div></center><p>如上图所见，到第一次并发标记完成，标记了所有 bottom 到 nextTAMS 内所有存活对象（标记完成后会在收尾阶段将标记位图 next 中的并发标记结果移动到标记位图 prev 中，再重置标记位图 next ）</p><center class = half><img src="/img/G1GC算法篇/第二次并发标记开始.png" height="153" title="第二次并发标记开始状态" ><img src="/img/G1GC算法篇/第二次并发标记完成.png" height="153" title="第二次并发标记完成状态" ><br>    <div style="color:orange; color: #999;padding: 2px;">    第二次并发标记开始状态&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第二次并发标记完成状态    </div></center><p>等到新一轮并发标记开始时时，</p><ol><li>对当前 Bottom 和 top 之间的对象创建空白的标记位图 next</li><li>对 Bottom 和 prevTAMS 之间的内存对象，根据 prev 标记的存活结果重新标记存活对象（ prev 中标记死亡的对象不扫描）</li><li>对 prevTAMS 和 NextTAMS 之间的内存对象进行存活标记</li><li>对 NextTAMS 和 top 之间的对象，都认为是存活对象，不在标记位图上作标记</li><li>完成并发标记后将标记位图 next 置为标记位图 prev ，并重置标记位图 next</li></ol><p>注：在下文展开并发标记算法逻辑时，为了简化理解，假定region上发生的是第一次并发标记，prev为空白（如上图）。</p><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><p>简单介绍单次并发标记的过程，具体标记细节，会在下文展开，参考<a href="#references">中村成洋书中内容</a>一共分下列五个步骤</p><ol><li><strong>初始标记阶段</strong>：暂停应用程序 STW ，标记可由根直接引用的对象。</li><li><strong>并发标记阶段</strong>：与 mutator 并发进行，扫描 1 中标记的对象所引用的对象。</li><li><strong>最终标记阶段</strong>：暂停应用程序 STW ，扫描 2 中没有标记的对象。本步骤结束后，堆内所有存活对象都会被标记。</li><li><strong>存活对象计数</strong>：对每个 region 中被标记的对象进行计数，并发执行。</li><li><strong>收尾工作</strong>：暂停应用程序 STW ，收尾工作，并为下次标记做准备。</li></ol><h2 id="步骤-1——初始标记阶段"><a href="#步骤-1——初始标记阶段" class="headerlink" title="步骤 1——初始标记阶段"></a>步骤 1——初始标记阶段</h2><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0.png" alt="初始标记"></p><p>在初始标记阶段，GC 线程首先创建空白的标记位图 next。其中 nextTAMS 是本次标记开始时 top 所在的位置。单个对象假定8字节，位图的大小是 (top-botton)&#x2F;(8字节)。创建过程与 mutator 应用程序并发进行。</p><p>等所有待回收 region 的标记位图都完成创建后，暂停 mutator（ STW ）标记由根直接引用的对象（根扫描），目的是防止扫描过程中根被修改。按照三色标记算法，此时根直接引用的对象的引用还没被扫描，应该将根直接引用的对象标记为灰色，需要注意的是标记位图只能通过 0&#x2F;1 的 bit 位来标记对象是否存活，并不能标记灰色，真实的位图在初始标记结束时会将存活对象在位图上标为1，而如果表现标灰的操作会在下文 SATB 部分展开。</p><p>上图状态可以用如下java代码粗略演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Obj</span> <span class="hljs-variable">C</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<br>C.ref1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Aobj</span>();<br>C.ref2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Eobj</span>();<br><br><span class="hljs-type">Obj</span> <span class="hljs-variable">H</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Obj</span>();<br>H.ref1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iobj</span>();<br></code></pre></td></tr></table></figure><p>根对象 C 、 H 分别持有子对象，根对象被标记为灰色，因为持有的子对象都没被标记（白色）</p><h2 id="步骤-2——并发标记阶段"><a href="#步骤-2——并发标记阶段" class="headerlink" title="步骤 2——并发标记阶段"></a>步骤 2——并发标记阶段</h2><p>在并发标记阶段，GC 线程与 mutator 并发进行，扫描在 1 阶段标记过的对象，完成对大部分存活对象的标记。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5.png" alt="并发标记阶段"></p><p>上图展示了并发标记的始末状态，对象 C 的子对象 A 和 E ，对象 H 的子对象 I 都被标记了。虽然 E 对应了标记位图中多个位，但是只有起始的标记位会被标记为 1 。</p><p>因为并发标记是和 mutator 应用程序并发执行，所以可能会向 region 内分配新的对象，上图中 J 和 K 即在并发标记阶段新分配的对象，记录在初始标记阶段记录的 nextTAMS 与当前 top 之间（ top 会随着分配对象而移动，指针碰撞），并不需要专门为新生成的对象创建标记位图（ J 、K 没有标记位图），这些新分配的对象（nextTAMS到top间的对象）会被当做存活对象，不在此次标记收集中处理。</p><p>但是由于这一阶段是与应用程序 mutator 并发执行， mutator 可能会改变对象之间的引用关系，造成并发标记漏标。</p><h3 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h3><p>在三色标记算法的基本概念中给出了并发标记漏标的充分必要条件，此处通过例子展示漏标的情况：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E6%BC%8F%E6%A0%87.gif"></p><p>开始时，A 、C 、E 完成标记，H 由于是根直接引用的对象，在初始标记阶段标记为灰色，I 暂未被标记，然后 Mutator 执行下列代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//已知:H.ref1 = new Iobj();C.ref2 = new Eobj();</span><br>C.ref2.ref1 = H.ref1;<span class="hljs-comment">//添加引用E-&gt;I</span><br>H.ref1 = <span class="hljs-literal">null</span>;<span class="hljs-comment">//断开H-&gt;I </span><br></code></pre></td></tr></table></figure><p>如果不做任何处理，黑色对象 E 不会再次扫描 E 的引用，又由于断开了所有由灰色对象到对象 A 的引用，对象 A 无法被标记为存活，将在回收过程中被当作垃圾收集，造成漏标。</p><p>G1GC 使用<code>SATB（Snapshot At The Beginning）专用写屏障</code>算法，用于打破充要条件的第二点。即在断开由灰色对象到白色对象引用时，将白色对象变为灰色对象。具体的操作是在一个对象的 field 发生写操作时，这个对象 field 之前的值会被放入 SATB 本地队列。</p><p id="satb"></p> <p>SATB 专用写屏障的伪代码如下所示：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//对应JVM 在oop_store方法的赋值动作的前的pre-write barrier</span><br>def satb_write_barrier(field, newobj):<br>    <span class="hljs-keyword">if</span> <span class="hljs-symbol">$gc</span>_phase == GC_CONCURRENT_MARK:<br>        oldobj = *field<br>        <span class="hljs-keyword">if</span> oldobj != <span class="hljs-literal">Null</span>:<br>            enqueue(<span class="hljs-symbol">$curre</span>nt_thread.stab_local_queue, oldobj)<br><br>        *field = newobj<br></code></pre></td></tr></table></figure><p>参数 field 表示被写入对象的域，参数 newobj 表示被写入域的值。第 2 行的 GC_CONCURRENT_MARK 表示并发标记阶段的标志位（flag）用于检查当前是否处于并发标记阶段。第 4 行检查被写入之前field 域的值是不是 Null。如果检查通过，则在第 5 行将 oldobj 添加到 $current_thread.stab_local_queue 中。然后，在第 7 行进行实际的写入操作。</p><p>“初始标记阶段”一节中提到并不存在位图上将对象标记为灰色的操作，所谓的标记为灰色其实是，将对象对应的标记位图bit位设置为 1 的同时，将对象加入 SATB 队列。此处的队列是 mutator 各自持有的线程本地队列，SATB 本地队列在装满（默认大小为 1 KB）之后，会被添加到全局的 SATB 队列集合中，在并发标记阶段交给 GC 线程对队列中的全部对象进行扫描和标记。</p><p>回到刚刚的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//已知:H.ref1 = new Iobj();C.ref2 = new Eobj();</span><br>C.ref2.ref1 = H.ref1;<br><span class="hljs-comment">//C.ref2.ref1 在 region 图中为对象 E ，此处发生写操作会被写屏障函数感知</span><br><span class="hljs-comment">//首先判断 E.ref1 = null 所以可以直接将 H.ref1 即 对象 I 写入 E 的域</span><br>H.ref1 = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//H.ref1 在region图中为对象 I ，此处发生写操作会被写屏障函数感知</span><br><span class="hljs-comment">//由于 I 非空 需要先将对象 I 在位图上标记为存活，再将对象 I 加入待扫描的 SATB 队列</span><br></code></pre></td></tr></table></figure><p>不难发现，通过上述过程对象 I 并不会被漏标。</p><p>细心的读者会发现，如果不存在第一步将对象 I 写入 E 的域，单纯需要将对象 I 置为垃圾，那 SATB 写屏障的存在依旧会将对象 I 标记为存活造成错标，造成浮动垃圾，但是不影响程序的正确性。G1 使用的写屏障 + SATB 产生的浮动垃圾通常比 CMS 使用的写屏障 + 增量更新（ IU ）更多。</p><h2 id="步骤-3——最终标记阶段"><a href="#步骤-3——最终标记阶段" class="headerlink" title="步骤 3——最终标记阶段"></a>步骤 3——最终标记阶段</h2><p>在步骤 2 中介绍了被写屏障感知的对象会先加入 SATB 本地队列，只有当 SATB 本地队列装满之后才会被交给 GC 线程进行扫描和标记，而最终标记阶段则是暂停应用程序 mutator 扫描 SATB 本地队列存放的待扫描对象。本步骤结束后，所有的存活对象都已被标记，所有不带标记的对象都可以判定为死亡对象。</p><h2 id="步骤-4——存活对象计数"><a href="#步骤-4——存活对象计数" class="headerlink" title="步骤 4——存活对象计数"></a>步骤 4——存活对象计数</h2><p>存活对象计数阶段根据每个 region 的标记位图 next，统计当前 region 内存活对象的字节数，存到 region 内的 next_marked_bytes 中。下图中存活对象 A、C、E、H 和 I，一共 5 个对象，其中 E 真实大小是 16 个字节，另外 4 个对象都是 8 个字节，所以 next_marked_bytes 总共 48 个字节。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E5%AD%98%E6%B4%BB%E5%AF%B9%E8%B1%A1%E8%AE%A1%E6%95%B0.png" alt="存活对象计数结束后 region 的状态"></p><p>同时存活对象计数阶段也是与应用程序并发出现的，如果又新创建了对象 L ，会将对象继续放在 nextTAMS 和 top 之间，被当做存活对象处理，同对象 J 、 K 都不会参与本次存活对象计数，留待下次并发标记处理。</p><h2 id="步骤-5——收尾工作"><a href="#步骤-5——收尾工作" class="headerlink" title="步骤 5——收尾工作"></a>步骤 5——收尾工作</h2><p>收尾工作也需要暂停应用程序（ STW ），主要完成两件事情：</p><ol><li>将标记位图 next 的并发标记结果移动到标记位图 prev 中，再重置标记位图 next 为空，同时移动  prevTAMS </li><li>计算每个 region 的转移效率，并按照转移效率对 region 进行降序排序</li></ol><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E6%94%B6%E5%B0%BE%E9%98%B6%E6%AE%B5.png" alt="收尾工作完成 region 的状态"></p><p>图中将标记位图 next 的并发标记结果移动到标记位图 prev 中，再重置标记位图 next 为空（会在下次并发标记第 1 步重新创建）。同时 prevTAMS 被移动到了原来 nextTAMS 的位置，表示下次并发标记会从 prevTAMS 开始， prevTAMS 之前的存活对象都被标记在标记位图 prev 中了。 nextTAMS 则会被移动到 bottom 的位置， nextTAMS 会在下次并发标记开始时，移动到 top 的最新位置。</p><h3 id="转移效率"><a href="#转移效率" class="headerlink" title="转移效率"></a>转移效率</h3><p>上文提到， prev 标记位图的作用是在本次标记中确定上一次标记过的活跃对象，用于优化内存管理。存在这种需求的原因是一次并发标记过后的 region 并不会马上被回收，而是选择垃圾最多（转移效率最高）的若干 region 做垃圾回收。</p><p>转移效率 &#x3D; region 内死亡对象的字节数 ÷ 转移所需时间</p><p>通俗理解就是， region 内死亡对象字节数越多，存活对象字节数就越少，而存活对象字节数越少，那么转移所需的时间就越少。用更少的时间清理出一块相同大小的 region 就具有更大的转移效率。</p><h1 id="跨界引用的标记"><a href="#跨界引用的标记" class="headerlink" title="跨界引用的标记"></a>跨界引用的标记</h1><p>垃圾收集器在 Partial GC 时（局部收集）都会面临跨代引用的问题（如下图， GC Roots 直接引用的新生代对象 D 存在对老年代对象 C 的引用，而GC Roots 直接引用的老年代对象 B 存在对新生代对象 A 的引用）。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8.png" alt="跨代引用示例"></p><p>G1 的问题更加复杂，由于被将堆分割为多个 region ，每个 region 与 region 之间都有可能存在跨界引用，而每次 GC 并不会对所有 region 都进行回收，但是为了准确找到所有需要回收的 region 内的存活对象，就不得不每次都扫描整个堆。为了减少扫描的代价，按照牺牲空间换时间的逻辑，引入了Remembered Set（记忆集，简称RSet）的概念，RSet是一种用于记录从非收集区域指向收集区域的指针集合的抽象结构。《深入理解 Java 虚拟机》一书将 G1 对 RSet 的实现称作“双向的卡表结构”，原始论文中更多的是直接用 Remembered Set（记忆集）来描述 RSet 。</p><h2 id="卡表（-card-table-）"><a href="#卡表（-card-table-）" class="headerlink" title="卡表（ card table ）"></a>卡表（ card table ）</h2><p>卡表（Card Table）通过卡精度的方式实现，是元素大小为 1B 的数组，HotSpot如下实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//share/vm/gc_implementation/g1/heapReagion.cpp</span><br>GrainBytes = (<span class="hljs-type">size_t</span>)region_size;<br>CardsPerRegion = GrainBytes &gt;&gt; CardTableModRefBS::card_shift;<br><br><span class="hljs-comment">//share/vm/memory/cardTableModRefBS.hpp</span><br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SomePublicConstants</span> &#123;<br>    card_shift                  = <span class="hljs-number">9</span>,<br>    card_size                   = <span class="hljs-number">1</span> &lt;&lt; card_shift,<br>    card_size_in_words          = card_size / <span class="hljs-built_in">sizeof</span>(HeapWord)<br>  &#125;;<br><br><span class="hljs-comment">//简化逻辑为</span><br>CARD_TABLE [<span class="hljs-keyword">this</span> address &gt;&gt; <span class="hljs-number">9</span>] = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>不难理解，每一块 region 内某个对象的首地址右移 9 位（除以 512 ）就是对应的卡表索引。换句话说，将 region 按照每 512 个字节作为一个卡页，只要这 512 个字节的卡页中存在一个及以上的对象有对其他区域的对象的引用，就将对应卡表元素变成 1（此处会将 1 写入某块地址占一个 byte ），也就是所谓的卡表元素变脏。在垃圾回收时，只要根据卡表中变脏的元素，找到对应的卡页，再从卡页对应内存地址包含的对象中找到跨界指针，最后将跨界指针加入 GC Roots 中一并扫描。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/card_table.png" alt="卡表结构"></p><p>如上图所示，每个 region 保存了一个 points-out （“我指向谁”）的卡表，当某个卡表元素为 1 时，认为卡片脏（例如卡片 3 脏），于是只需要去对应的0x0400~0x05FF中扫描对象找到跨界引用即可。</p><h2 id="RSet-的实现"><a href="#RSet-的实现" class="headerlink" title="RSet 的实现"></a>RSet 的实现</h2><p>卡表的结构减少了整体扫描的成本， G1 在此基础上为每个 region 构造了另一张表，用于记录下哪些别的region有指向自己指针，而这些指针又分别在那些 region 的哪些 card 的范围内。通过这种方式构造了一种类似双向链表的具有索引“我指向谁”和“谁指向我”的 RSet 结构。</p><p>RSet的结构是一种哈希表，</p><ul><li>key ：引用本 region 内对象的其他 region 的起始地址</li><li>value ：数组，数组元素是引用方的对象所对应的卡片索引</li></ul><p>借用知乎文章<a href="#references">《关于 G1 GC 的一些研究》</a>中的例子，如下图所示：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/RSet.png" alt="G1 RSet的引用关系"></p><p>上图中的 RSet 属于 region B ，RSet 中第一项的 key 指向了 region A 的首地址，value里有index为 1,2,3… 的 card ，意思是指 region A 的 card 对应的卡页里有对象引用了 region B 内的对象。</p><p>那么整合卡表就能看清整个 RSet 的全貌了，借用<a href="#references">中村成洋书中案例</a>如下：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/RSet%E4%BE%8B%E5%AD%90.png" alt="G1 RSet 使用例子"></p><p>如图在 region A 保存的 RSet 中，存在以 region B 的首地址为 Key ，索引 2048 为 value 的哈希表元素。当需要确定跨界引用时会通过 Key 中 region B 的首地址找到 region B，再通过 value 2048 找到 2048 号卡表对应的 512 Bytes 的地址段，扫描地址段内的对象，找到存在跨界引用向 A 中对象 a 的 B 中对象 b 。</p><p>不难发现 RSet 记录的是 points-into 的关系（谁指向我），而 card table 记录的是 points-out 的关系（我指向谁），所以在《深入java虚拟机》一书中用“双向的卡表结构”来形容这个特殊的 RSet 。</p><h2 id="维护-RSet"><a href="#维护-RSet" class="headerlink" title="维护 RSet"></a>维护 RSet</h2><p>那么如何来维护 RSet 呢，考虑如下情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//假设对象young和old分别在不同的Region中</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">young</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>old.p = young;<br></code></pre></td></tr></table></figure><p>java 层面给 old 对象的 p 字段赋值 young 对象之后，jvm 底层会执行 oop_store 方法,并在赋值动作<strong>后</strong>使用 post-write barrier 函数。</p><p>在介绍 <a href="#satb">SATB 伪代码</a>时提到过在同样的赋值动作<strong>前</strong>会插入 pre-write barrier 函数（ satb_write_barrier ）用于记录引用的修改，此处的 post-write barrier 函数与 pre-write barrier 函数实现方法类似，先看下方伪代码。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs smali">//对应JVM 在oop_store方法的赋值动作的前的post-write barrier<br>def evacuation_write_barrier(obj, field, newobj):<br>   <span class="hljs-built_in"> check </span>= obj ^ newobj<br>   <span class="hljs-built_in"> check </span>=<span class="hljs-built_in"> check </span>&gt;&gt; LOG_OF_HEAP_REGION_SIZE<br>   <span class="hljs-built_in"> if </span>newobj == Null:<br>       <span class="hljs-built_in"> check </span>= 0<br>   <span class="hljs-built_in"> if </span>check == 0:<br>       <span class="hljs-built_in"> return</span><br><span class="hljs-built_in"></span><br>   <span class="hljs-built_in"> if </span>not is_dirty_card(obj):<br>        to_dirty(obj)<br>        enqueue($current_thread.rs_log, obj)<br><br>    *field = newobj<br></code></pre></td></tr></table></figure><p>第 2 行到第 7 行的代码会在 obj 和 newobj 位于同一个区域，或者 newobj 为 Null 时，起到过滤的作用。第 9 行的函数 is_dirty_card() 用来检查参数 obj 所对应的卡片是否为脏卡片。该行的检查就是为了避免向转移专用记忆集合日志中添加重复的卡片。如果是净卡片，则该卡片将在第 10 行变成脏卡片，然后在第 11 行<br>被添加到队列 $current_thread.rs_log 中。</p><p>与 SATB 一样这里也有一个全局的队列， DirtyCardQueueSet 。更新RSet的动作则会交给多个 ConcurrentG1RefineThread 线程来并发完成，每当这个全局队列超过一定的阈值后， ConcurrentG1RefineThread 都会取出若干个队列，并且遍历队列中的记录的card并将它加到对应的 region 的 RSet 中。</p><h1 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h1><p>转移过程的算法原理可以参考基本概念的 <a href="#Copying">Copying</a> 算法，G1 转移过程与 Copying 算法大致相同。由于加入了 RSet 优化，所以在处理根对象时略有不同，转移根对象除了需要转移<code>由根直接引用的对象</code>，还需要转移<code>并发标记处理中的对象</code>以及<code>由其他区域对象直接引用的回收集合内的对象</code></p><h2 id="回收集确定"><a href="#回收集确定" class="headerlink" title="回收集确定"></a>回收集确定</h2><p>在介绍 G1 堆结构时提到 G1 新生代会动态调整大小以满足停顿预测模型，事实上在垃圾回收过程中，G1 会记录每个region 的回收耗时，根据用户的期望停顿时间来生成回收集 Collection Set（简称CSet），一次完整的回收过程，只会转移 CSet 内的存活对象。</p><p>G1 中存在两种选定 CSet 的子模式，分别为 Young GC 与 mixed GC </p><ul><li>Young GC ：选定所有的 young gen 里的 region 。通过控制 young gen 的个数来控制 young GC 的开销。</li><li>Mixed GC ：选定所有的 young gen region ，外加根据“衰减平均值”统计得出的收益较高的若干 old gen region 。在用户指定的最大停顿时间范围内尽可能的选择收益高的old gen Region</li></ul><p>其中第一种模式就是G1 新生代会动态调整大小的情况；第二种模式中，由于在并发标记的步骤 5 中对所有 old gen region 计算了转移效率并按照降序排列了，接下来只要依次计算各个 region 的预测暂停时间，再依次将 region 加入 CSet ，在当所有已选 region 的预测暂停时间的总和快要超过最大停顿时间时停止加入即可。</p><p>由于 young gen Region 总是在 CSet 内，因此 G1 不维护从 young gen Region 出发的引用涉及到的 Rset 更新。</p><h2 id="转移过程"><a href="#转移过程" class="headerlink" title="转移过程"></a>转移过程</h2><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/YGC%E8%BD%AC%E7%A7%BB.png" alt="YGC 的转移过程"></p><p>如上图，YGC 仅将所有新生代 region （包括 Eden 和 survivor ）都加入 CSet ，然后统一转移 CSet 内的对象。晋升的对象会被转移到老年代，其余的转移到 survivor 区。</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/MixedGC%E8%BD%AC%E7%A7%BB.png" alt="Mixed GC 的转移过程"></p><p>如上图，Mixed GC 除了所有新生代区域外，还会选择一些老年代 region 加入 CSet。</p><h1 id="G1GC-过程"><a href="#G1GC-过程" class="headerlink" title="G1GC 过程"></a>G1GC 过程</h1><p>引用<a href="#references">《深入探索JVM垃圾回收》</a>书中对 G1 YGC 与 Mixed GC 状态转换图如下</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/GC%E6%89%A7%E8%A1%8C%E6%B4%BB%E5%8A%A8%E5%9B%BE.png" alt="GC执行活动图"></p><p>图中对 G1 的 Young GC 、并发标记 、Mixed GC 三种状态做了展示，结合并发标记的过程和 mutator 来看，可以得到下图活动图：</p><p><img src="/img/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/G1%E6%B4%BB%E5%8A%A8%E5%9B%BE.png" alt="G1 垃圾回收活动图"></p><p id="references"></p>    <h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入 Java 虚拟机-JVM G1GC 的算法与实现》中村成洋&#x2F;著 吴炎昌 杨文轩&#x2F;译 1-6章<br>《深入探索JVM垃圾回收》彭成寒 4-6章<br><a href="https://zhuanlan.zhihu.com/p/463179141">关于 G1 GC 的一些研究</a><br><a href="https://www.redhat.com/en/blog/part-1-introduction-g1-garbage-collector">Part 1: Introduction to the G1 Garbage Collector</a><br><a href="https://www.redhat.com/en/blog/collecting-and-reading-g1-garbage-collector-logs-part-2?source=author&term=22991">Collecting and reading G1 garbage collector logs - part 2</a><br><a href="https://blog.csdn.net/weixin_45101064/article/details/123478022">(八)JVM成神路之GC分区篇：G1、ZGC、ShenandoahGC高性能收集器深入剖析</a> G1部分</p>]]></content>
    
    
    
    <tags>
      
      <tag>GC</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
