

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/bg/tubiao.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Treer Cai">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言本文将针对 G1GC 算法篇中提到的 write barrier 技术基于源码进行分析，如有偏差，请指正。">
<meta property="og:type" content="article">
<meta property="og:title" content="Hotspot源码分析(G1)——write_barrier">
<meta property="og:url" content="https://treercai.github.io/2023/01/15/Hotspot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-G1-%E2%80%94%E2%80%94write-barrier/index.html">
<meta property="og:site_name" content="TreerCai&#39;s blog">
<meta property="og:description" content="前言本文将针对 G1GC 算法篇中提到的 write barrier 技术基于源码进行分析，如有偏差，请指正。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-01-15T08:56:08.000Z">
<meta property="article:modified_time" content="2023-01-11T09:27:39.311Z">
<meta property="article:author" content="Treer Cai">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="G1GC-write barrier">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Hotspot源码分析(G1)——write_barrier - TreerCai&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"treercai.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":60,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TreerCai</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/bg1.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Hotspot源码分析(G1)——write_barrier"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-15 16:56" pubdate>
          January 15, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          214 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Hotspot源码分析(G1)——write_barrier</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文将针对<a href="/2022/12/20/G1GC%E7%AE%97%E6%B3%95%E7%AF%87"> G1GC 算法篇</a>中提到的 write barrier 技术基于源码进行分析，如有偏差，请指正。<span id="more"></span></p>
<p>G1 SATB 与 Rset维护都会调用到 write-barrier （ SATB 采用 pre write-barrier 完成，维护 RSet 采用 post write-barrier 完成） mutator 在 write-barrier 中仅仅将要做的事推送到队列中，然后通过另外的线程取出队列中的信息批量完成剩余的动作。</p>
<p>本文将分析 write-barrier 在OpenJDK8源码中解释器与C2编译中的实现。</p>
<h1 id="write-barrier-在模板解释器的实现"><a href="#write-barrier-在模板解释器的实现" class="headerlink" title="write-barrier 在模板解释器的实现"></a>write-barrier 在模板解释器的实现</h1><p>在 G1GC 算法篇介绍两种 write-barrier 时提过， SATB 写屏障的目的是当并发标记时避免<code>漏标</code>，而维护的 Rset 记录的则是<code>跨界引用</code>。<code>漏标的产生</code>和<code>跨界引用的修改</code>根本原因都与对象的域被修改有关。查看如下例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况 1 ：假设 G1 正在并发标记，对象 t 作为根对象已经被标记（灰色），但是 t 引用的对象还没被标记</span><br><span class="hljs-comment">//情况 2 ：假设对象 young 和 t 分别在不同的 Region 中</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">young</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<span class="hljs-comment">//步骤 1</span><br>t.next = young;<span class="hljs-comment">//步骤 2</span><br><span class="hljs-comment">//上述两种情况都需要在步骤 2 完成前记录下相关信息</span><br></code></pre></td></tr></table></figure>

<p>例子转换成字节码的核心部分如下，字节码的阅读不作详细解答，可查阅相关文档</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">[<span class="hljs-number">26241</span>] <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> WriteBarrierShow.xxx(jobject, jint)<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769225</span>     <span class="hljs-number">0</span>  <span class="hljs-keyword">new</span> <span class="hljs-number">2</span> &lt;Node&gt;<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769226</span>     <span class="hljs-number">3</span>  dup<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769227</span>     <span class="hljs-number">4</span>  iload_1<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769228</span>     <span class="hljs-number">5</span>  invokespecial <span class="hljs-number">3</span> &lt;Node.&lt;init&gt;(I)V&gt; <br><br><span class="hljs-comment">//... virtual void Node.&lt;init&gt;(jint)</span><br><br>[<span class="hljs-number">26241</span>] <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> WriteBarrierShow.xxx(jobject, jint)<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769236</span>     <span class="hljs-number">8</span>  astore_2<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769237</span>     <span class="hljs-number">9</span>  aload_0<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769238</span>    <span class="hljs-number">10</span>  aload_2<br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769239</span>    <span class="hljs-number">11</span>  putfield <span class="hljs-number">4</span> &lt;Node.p/LNode;&gt; <br>[<span class="hljs-number">26241</span>]   <span class="hljs-number">769240</span>    <span class="hljs-number">14</span>  <span class="hljs-keyword">return</span><br><br></code></pre></td></tr></table></figure>

<p>当解释执行时，会通过字节码 putfield 实现步骤2 ，所以来看一下 putfield 在模板解释器中的实现： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TemplateTable::putfield</span><span class="hljs-params">(<span class="hljs-type">int</span> byte_no)</span> </span>&#123;<br>  <span class="hljs-built_in">putfield_or_static</span>(byte_no, <span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TemplateTable::putfield_or_static</span><span class="hljs-params">(<span class="hljs-type">int</span> byte_no, <span class="hljs-type">bool</span> is_static)</span> </span>&#123;<br>  <span class="hljs-built_in">transition</span>(vtos, vtos);<br>  <span class="hljs-comment">// ... 此处的 putfield 是将 object 放到域上，此处的 _tos_in（模板执行前的TosState）为 </span><br>  <span class="hljs-comment">// atos （object cached）相关知识栈顶缓存</span><br>  &#123;<br>    <span class="hljs-function">__ <span class="hljs-title">pop</span><span class="hljs-params">(atos)</span></span>;<br>    <span class="hljs-keyword">if</span> (!is_static) <span class="hljs-built_in">pop_and_check_object</span>(obj);<br>    <span class="hljs-comment">// Store into the field</span><br>    <span class="hljs-built_in">do_oop_store</span>(_masm, field, rax, _bs-&gt;<span class="hljs-built_in">kind</span>(), <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-function">__ <span class="hljs-title">jmp</span><span class="hljs-params">(Done)</span></span>;<br>  &#125;<br>  <span class="hljs-function">__ <span class="hljs-title">bind</span><span class="hljs-params">(notObj)</span></span>;<br>  <span class="hljs-function">__ <span class="hljs-title">cmpl</span><span class="hljs-params">(flags, itos)</span></span>;<br>  <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::notEqual, notInt)</span></span>;<br><span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>事实上字节码 aastore 字节码也会调用到 do_oop_store 函数，本文仅用 putfield 举例， do_oop_store 函数会将 oop （或 NULL ）存储在 obj 描述的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">do_oop_store</span><span class="hljs-params">(InterpreterMacroAssembler* _masm, Address obj, Register val, BarrierSet::Name barrier, <span class="hljs-type">bool</span> precise)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (barrier) &#123;<br>    <span class="hljs-comment">// -XX:+UseG1GC 此处只关心 G1GC 会调用到的部分</span><br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCT:<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCTLogging:<br>      &#123;<br>        <span class="hljs-function">__ <span class="hljs-title">g1_write_barrier_pre</span><span class="hljs-params">(rdx <span class="hljs-comment">/* obj */</span>, rbx <span class="hljs-comment">/* pre_val */</span>, r15_thread <span class="hljs-comment">/* thread */</span>,  r8  <span class="hljs-comment">/* tmp */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                val != noreg <span class="hljs-comment">/* tosca_live */</span>, <span class="hljs-literal">false</span> <span class="hljs-comment">/* expand_call */</span>)</span></span>;<br>        <span class="hljs-keyword">if</span> (val == noreg) &#123;<br>          <span class="hljs-function">__ <span class="hljs-title">store_heap_oop_null</span><span class="hljs-params">(Address(rdx, <span class="hljs-number">0</span>))</span></span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// G1 barrier needs uncompressed oop for region cross check.</span><br>          Register new_val = val;<br>          <span class="hljs-keyword">if</span> (UseCompressedOops) &#123;<br>            new_val = rbx;<br>            <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(new_val, val)</span></span>;<br>          &#125;<br>          <span class="hljs-function">__ <span class="hljs-title">store_heap_oop</span><span class="hljs-params">(Address(rdx, <span class="hljs-number">0</span>), val)</span></span>;<br>          <span class="hljs-function">__ <span class="hljs-title">g1_write_barrier_post</span><span class="hljs-params">(rdx <span class="hljs-comment">/* store_adr */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   new_val <span class="hljs-comment">/* new_val */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   r15_thread <span class="hljs-comment">/* thread */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   r8 <span class="hljs-comment">/* tmp */</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                                   rbx <span class="hljs-comment">/* tmp2 */</span>)</span></span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>排除压缩指针与其他选项匹配的 barrier 代码，不难看出，当开启 G1GC 时，会在 store_heap_oop(_null) 之前调用 g1_write_barrier_pre ，之后调用 g1_write_barrier_post 函数。</p>
<p id="g1_write_barrier_pre"></p>    

<h2 id="g1-write-barrier-pre-在解释运行中的实现"><a href="#g1-write-barrier-pre-在解释运行中的实现" class="headerlink" title="g1_write_barrier_pre 在解释运行中的实现"></a>g1_write_barrier_pre 在解释运行中的实现</h2><p>回顾 G1GC 算法实现，SATB 专用写屏障的伪代码如下所示：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//对应JVM 在oop_store方法的赋值动作的前的pre-write barrier</span><br>def satb_write_barrier(field, newobj):<br>    <span class="hljs-keyword">if</span> <span class="hljs-symbol">$gc</span>_phase == GC_CONCURRENT_MARK:<br>        oldobj = *field<br>        <span class="hljs-keyword">if</span> oldobj != <span class="hljs-literal">Null</span>:<br>            enqueue(<span class="hljs-symbol">$curre</span>nt_thread.stab_local_queue, oldobj)<br><br>        *field = newobj<br></code></pre></td></tr></table></figure>

<p>在伪代码中不难看出 SATB 专用写屏障，通过在将新对象写入域之前记录原来域对象,并滞后标记的方式来避免漏标。<br>在 G1GC 算法篇介绍 SATB 时提过，首先会将 old 对象放到本地线程的 SATB 队列中，所以首先来看一下 JavaThread 类的以下两个属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/runtime/thread.hpp</span><br><br>  <span class="hljs-comment">// Support for G1 barriers</span><br><br>  ObjPtrQueue _satb_mark_queue;          <span class="hljs-comment">// Thread-local log for SATB barrier.</span><br>  <span class="hljs-comment">// Set of all such queues.</span><br>  <span class="hljs-type">static</span> SATBMarkQueueSet _satb_mark_queue_set;<br><br>  DirtyCardQueue _dirty_card_queue;      <span class="hljs-comment">// Thread-local log for dirty cards.</span><br>  <span class="hljs-comment">// Set of all such queues.</span><br>  <span class="hljs-type">static</span> DirtyCardQueueSet _dirty_card_queue_set;<br></code></pre></td></tr></table></figure>

<p>_satb_mark_queue 与 _dirty_card_queue 属于线程私有，当线程本地队列满了之后，会分别提交到全局的 _satb_mark_queue_set 与 _dirty_card_queue_set 交给 G1 线程批量处理。</p>
<p> ObjPtrQueue 的父类 class PtrQueue 具有如下属性与函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/gc_implementation/g1/ptrQueue.hpp</span><br>  <span class="hljs-comment">// Whether updates should be logged.</span><br>  <span class="hljs-type">bool</span> _active;<br><br>  <span class="hljs-comment">// The buffer.</span><br>  <span class="hljs-type">void</span>** _buf;<br>  <span class="hljs-comment">// The index at which an object was last enqueued.  Starts at &quot;_sz&quot;</span><br>  <span class="hljs-comment">// (indicating an empty buffer) and goes towards zero.</span><br>  <span class="hljs-type">size_t</span> _index;<br><br>    <span class="hljs-comment">// Enqueues the given &quot;obj&quot;.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!_active) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">enqueue_known_active</span>(ptr);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>注释很好理解，三个属性分别是是否活跃、buffer 地址与最后一个对象的末尾索引。其中 _index 属性为 0 时代表队列满了，具体处理在后文分析。<br>接下来看一下 g1_write_barrier_pre 的核心实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/cpu/x86/vm/macroAssembler_x86.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MacroAssembler::g1_write_barrier_pre</span><span class="hljs-params">(Register obj,         <span class="hljs-comment">//rdx /* obj */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          Register pre_val,     <span class="hljs-comment">//rbx /* pre_val */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          Register thread,      <span class="hljs-comment">//r15_thread /* thread */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          Register tmp,         <span class="hljs-comment">//r8  /* tmp */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">bool</span> tosca_live,      <span class="hljs-comment">//val != noreg /* tosca_live */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                          <span class="hljs-type">bool</span> expand_call)</span> </span>&#123;   <span class="hljs-comment">//false /* expand_call */</span><br><br>  Label done;   <span class="hljs-comment">//跳转标签 done 完成</span><br>  Label runtime;  <span class="hljs-comment">//跳转标签 runtime</span><br><br>  <span class="hljs-comment">//static ByteSize satb_mark_queue_offset()  &#123; return byte_offset_of(JavaThread, _satb_mark_queue); &#125;</span><br>  <span class="hljs-comment">//通过类的函数获取 JavaThread 的 satb 相关信息</span><br>  <span class="hljs-function">Address <span class="hljs-title">in_progress</span><span class="hljs-params">(thread, in_bytes(JavaThread::satb_mark_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_active()))</span></span>;<br>  <span class="hljs-function">Address <span class="hljs-title">index</span><span class="hljs-params">(thread, in_bytes(JavaThread::satb_mark_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_index()))</span></span>;<br>  <span class="hljs-function">Address <span class="hljs-title">buffer</span><span class="hljs-params">(thread, in_bytes(JavaThread::satb_mark_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_buf()))</span></span>;<br><br><br>  <span class="hljs-comment">// Is marking active? 是否处于并发标记阶段？</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">in_bytes</span>(PtrQueue::<span class="hljs-built_in">byte_width_of_active</span>()) == <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-built_in">cmpl</span>(in_progress, <span class="hljs-number">0</span>);       <span class="hljs-comment">//比较 _active 是否为 0，0需要跳转到 done ，即不需要写屏障</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">cmpb</span>(in_progress, <span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// Do we need to load the previous value? 空对象不需要写屏障</span><br>  <span class="hljs-keyword">if</span> (obj != noreg) &#123;<br>    <span class="hljs-built_in">load_heap_oop</span>(pre_val, <span class="hljs-built_in">Address</span>(obj, <span class="hljs-number">0</span>));<br>  &#125;<br><br>  <span class="hljs-comment">// Is the previous value null?    比较 pre_val 是否为空，空也不需要写屏障，直接跳转到 done</span><br>  <span class="hljs-built_in">cmpptr</span>(pre_val, (<span class="hljs-type">int32_t</span>) NULL_WORD);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// Can we store original value in the thread&#x27;s buffer?</span><br>  <span class="hljs-comment">// Is index == 0?</span><br>  <span class="hljs-comment">// (The index field is typed as size_t.)</span><br><br>  <span class="hljs-built_in">movptr</span>(tmp, index);                   <span class="hljs-comment">// tmp := *index_adr</span><br>  <span class="hljs-built_in">cmpptr</span>(tmp, <span class="hljs-number">0</span>);                       <span class="hljs-comment">// tmp == 0?</span><br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, runtime);       <span class="hljs-comment">// If yes, goto runtime 比较 _index是否 0 。为 0 意味着当前线程的 </span><br>                                        <span class="hljs-comment">// satb 队列满了，此时需要通过运行时调用，交给其他线程处理，具体为跳转到 bind(runtime) 处 </span><br><br>  <span class="hljs-comment">// 计算 pre_val 的入队位置</span><br>  <span class="hljs-built_in">subptr</span>(tmp, wordSize);                <span class="hljs-comment">// tmp := tmp - wordSize  将 _index 减去 oopSize</span><br>  <span class="hljs-built_in">movptr</span>(index, tmp);                   <span class="hljs-comment">// *index_adr := tmp</span><br>  <span class="hljs-built_in">addptr</span>(tmp, buffer);                  <span class="hljs-comment">// tmp := tmp + *buffer_adr</span><br><br>  <span class="hljs-comment">// Record the previous value 将 pre_val 入队</span><br>  <span class="hljs-built_in">movptr</span>(<span class="hljs-built_in">Address</span>(tmp, <span class="hljs-number">0</span>), pre_val);<br>  <span class="hljs-built_in">jmp</span>(done);<br><br>  <span class="hljs-built_in">bind</span>(runtime);<br>  <span class="hljs-comment">// 运行时，最终会调用 SharedRuntime::g1_wb_pre ，这里会在运行时章节展开</span><br>  <span class="hljs-built_in">bind</span>(done);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不难发现，整体实现与伪代码类似，完成了对前值的入队。</p>
<h2 id="g1-write-barrier-post-在解释运行中的实现"><a href="#g1-write-barrier-post-在解释运行中的实现" class="headerlink" title="g1_write_barrier_post 在解释运行中的实现"></a>g1_write_barrier_post 在解释运行中的实现</h2><p>g1_write_barrier_post 的伪代码如下</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs smali">def evacuation_write_barrier(obj, field, newobj):<br> <span class="hljs-built_in"> check </span>= obj ^ newobj<br> <span class="hljs-built_in"> check </span>=<span class="hljs-built_in"> check </span>&gt;&gt; LOG_OF_HEAP_REGION_SIZE<br> <span class="hljs-built_in"> if </span>newobj == Null:<br>   <span class="hljs-built_in"> check </span>= 0<br> <span class="hljs-built_in"> if </span>check == 0:<br>   <span class="hljs-built_in"> return</span><br><span class="hljs-built_in"></span><br> <span class="hljs-built_in"> if </span>not is_dirty_card(obj):<br>    to_dirty(obj)<br>    enqueue($current_thread.rs_log, obj)<br><br>  *field = newobj<br></code></pre></td></tr></table></figure>

<p>过滤 obj 和 newobj 位于同一个区域，或者 newobj 为 Null 的时候， is_dirty_card() 用来检查参数 obj 所对应的卡片是否<br>为脏卡片。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MacroAssembler::g1_write_barrier_post</span><span class="hljs-params">(Register store_addr,     <span class="hljs-comment">// rdx /* store_adr */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register new_val,        <span class="hljs-comment">// new_val /* new_val */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register thread,         <span class="hljs-comment">// r15_thread /* thread */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register tmp,            <span class="hljs-comment">// r8 /* tmp */</span></span></span><br><span class="hljs-params"><span class="hljs-function">                                           Register tmp2)</span> </span>&#123;         <span class="hljs-comment">// rbx /* tmp2 */</span><br><br>  <span class="hljs-comment">//此处获取 dirty_card 的 _index 与 _buf</span><br>  <span class="hljs-function">Address <span class="hljs-title">queue_index</span><span class="hljs-params">(thread, in_bytes(JavaThread::dirty_card_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_index()))</span></span>;<br>  <span class="hljs-function">Address <span class="hljs-title">buffer</span><span class="hljs-params">(thread, in_bytes(JavaThread::dirty_card_queue_offset() +</span></span><br><span class="hljs-params"><span class="hljs-function">                                       PtrQueue::byte_offset_of_buf()))</span></span>;<br><br>  BarrierSet* bs = Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">barrier_set</span>();<br>  CardTableModRefBS* ct = (CardTableModRefBS*)bs;<br><br>  Label done;<br>  Label runtime;<br><br>  <span class="hljs-comment">// Does store cross heap regions? 只有跨界引用需要被记录</span><br><br>  <span class="hljs-built_in">movptr</span>(tmp, store_addr);<br>  <span class="hljs-built_in">xorptr</span>(tmp, new_val);<br>  <span class="hljs-built_in">shrptr</span>(tmp, HeapRegion::LogOfHRGrainBytes);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// crosses regions, storing NULL? Null 对象不需要被记录 Null 时跳转到 done</span><br><br>  <span class="hljs-built_in">cmpptr</span>(new_val, (<span class="hljs-type">int32_t</span>) NULL_WORD);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-comment">// storing region crossing non-NULL, is card already dirty? 已经脏的话，卡片不需要重复置脏</span><br><br>  <span class="hljs-type">const</span> Register card_addr = tmp;<br>  <span class="hljs-type">const</span> Register cardtable = tmp2;<br><br>  <span class="hljs-built_in">movptr</span>(card_addr, store_addr);<br>  <span class="hljs-built_in">shrptr</span>(card_addr, CardTableModRefBS::card_shift); <span class="hljs-comment">//右移操作，找到当前对象对应的卡片</span><br>  <span class="hljs-built_in">movptr</span>(cardtable, (<span class="hljs-type">intptr_t</span>)ct-&gt;byte_map_base);<br>  <span class="hljs-built_in">addptr</span>(card_addr, cardtable);<br><br>  <span class="hljs-comment">//源码很清晰地说明了，G1 不维护从 young gen Region 出发的引用涉及到的 Rset 更新</span><br>  <span class="hljs-built_in">cmpb</span>(<span class="hljs-built_in">Address</span>(card_addr, <span class="hljs-number">0</span>), (<span class="hljs-type">int</span>)G1SATBCardTableModRefBS::<span class="hljs-built_in">g1_young_card_val</span>()); <br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br>  <span class="hljs-built_in">membar</span>(Assembler::<span class="hljs-built_in">Membar_mask_bits</span>(Assembler::StoreLoad));  <span class="hljs-comment">//写读屏障，相关知识指令乱序，内存序</span><br>  <span class="hljs-built_in">cmpb</span>(<span class="hljs-built_in">Address</span>(card_addr, <span class="hljs-number">0</span>), (<span class="hljs-type">int</span>)CardTableModRefBS::<span class="hljs-built_in">dirty_card_val</span>()); <span class="hljs-comment">//判断卡片是否脏 </span><br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, done);<br><br><br>  <span class="hljs-comment">// storing a region crossing, non-NULL oop, card is clean.</span><br>  <span class="hljs-comment">// dirty card and log.</span><br><br>  <span class="hljs-built_in">movb</span>(<span class="hljs-built_in">Address</span>(card_addr, <span class="hljs-number">0</span>), (<span class="hljs-type">int</span>)CardTableModRefBS::<span class="hljs-built_in">dirty_card_val</span>());  <span class="hljs-comment">//卡片置脏</span><br><br>  <span class="hljs-built_in">cmpl</span>(queue_index, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">jcc</span>(Assembler::equal, runtime); <span class="hljs-comment">//当前线程队列是否已满，已满转运行时（同 pre_barrier）</span><br>  <span class="hljs-comment">//不满就入队</span><br>  <span class="hljs-built_in">subl</span>(queue_index, wordSize);<br>  <span class="hljs-built_in">movptr</span>(tmp2, buffer);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LP64</span><br>  <span class="hljs-built_in">movslq</span>(rscratch1, queue_index);<br>  <span class="hljs-built_in">addq</span>(tmp2, rscratch1);    <span class="hljs-comment">//将 _index 减去 oopSize</span><br>  <span class="hljs-built_in">movq</span>(<span class="hljs-built_in">Address</span>(tmp2, <span class="hljs-number">0</span>), card_addr);  <span class="hljs-comment">//入队</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-built_in">addl</span>(tmp2, queue_index);  <span class="hljs-comment">//将 _index 减去 oopSize</span><br>  <span class="hljs-built_in">movl</span>(<span class="hljs-built_in">Address</span>(tmp2, <span class="hljs-number">0</span>), card_addr);  <span class="hljs-comment">//入队</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-built_in">jmp</span>(done);<br><br>  <span class="hljs-built_in">bind</span>(runtime);<br>  <span class="hljs-comment">// save the live input values</span><br>  <span class="hljs-built_in">push</span>(store_addr);<br>  <span class="hljs-built_in">push</span>(new_val);<br>  <span class="hljs-comment">//调用运行时 SharedRuntime::g1_wb_post</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _LP64</span><br>  <span class="hljs-built_in">call_VM_leaf</span>(<span class="hljs-built_in">CAST_FROM_FN_PTR</span>(address, SharedRuntime::g1_wb_post), card_addr, r15_thread);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-built_in">push</span>(thread);<br>  <span class="hljs-built_in">call_VM_leaf</span>(<span class="hljs-built_in">CAST_FROM_FN_PTR</span>(address, SharedRuntime::g1_wb_post), card_addr, thread);<br>  <span class="hljs-built_in">pop</span>(thread);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-built_in">pop</span>(new_val);<br>  <span class="hljs-built_in">pop</span>(store_addr);<br><br>  <span class="hljs-built_in">bind</span>(done);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>整体逻辑与伪代码类似， 源码的注释已经能够说明过程了，此处不作赘述。</p>
<h1 id="write-barrier-在C2编译的实现"><a href="#write-barrier-在C2编译的实现" class="headerlink" title="write-barrier 在C2编译的实现"></a>write-barrier 在C2编译的实现</h1><p>依旧是如下例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//情况 1 ：假设 G1 正在并发标记，对象 t 作为根对象已经被标记（灰色），但是 t 引用的对象还没被标记</span><br><span class="hljs-comment">//情况 2 ：假设对象 young 和 t 分别在不同的 Region 中</span><br><span class="hljs-type">Node</span> <span class="hljs-variable">young</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<span class="hljs-comment">//步骤 1</span><br>t.next = young;<span class="hljs-comment">//步骤 2</span><br><span class="hljs-comment">//上述两种情况都需要在步骤 2 完成前记录下相关信息</span><br></code></pre></td></tr></table></figure>

<p>当触发 C2 编译时，首先根据字节码创建理想图</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/parse2.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parse::do_one_bytecode</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">bc</span>()) &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">case</span> Bytecodes::_putfield:<br>      <span class="hljs-built_in">do_putfield</span>();<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/opto/parse.hpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_putfield</span> <span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">do_field_access</span>(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>); &#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/opto/parse3.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parse::do_field_access</span><span class="hljs-params">(<span class="hljs-type">bool</span> is_get, <span class="hljs-type">bool</span> is_field)</span> </span>&#123;<br>  <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">if</span> (is_get) &#123;<br>      (<span class="hljs-type">void</span>) <span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// pop receiver before getting</span><br>      <span class="hljs-built_in">do_get_xxx</span>(obj, field, is_field);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">do_put_xxx</span>(obj, field, is_field);<br>      (<span class="hljs-type">void</span>) <span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// pop receiver after putting</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parse::do_put_xxx</span><span class="hljs-params">(Node* obj, ciField* field, <span class="hljs-type">bool</span> is_field)</span> </span>&#123;<br><br>  <span class="hljs-comment">// Store the value.</span><br>  Node* store;<br>  <span class="hljs-keyword">if</span> (bt == T_OBJECT) &#123;<br>    <span class="hljs-type">const</span> TypeOopPtr* field_type;<br>    <span class="hljs-keyword">if</span> (!field-&gt;<span class="hljs-built_in">type</span>()-&gt;<span class="hljs-built_in">is_loaded</span>()) &#123;<br>      field_type = TypeInstPtr::BOTTOM;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      field_type = TypeOopPtr::<span class="hljs-built_in">make_from_klass</span>(field-&gt;<span class="hljs-built_in">type</span>()-&gt;<span class="hljs-built_in">as_klass</span>());<br>    &#125;<br>    store = <span class="hljs-built_in">store_oop_to_object</span>(<span class="hljs-built_in">control</span>(), obj, adr, adr_type, val, field_type, bt, mo);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    store = <span class="hljs-built_in">store_to_memory</span>(<span class="hljs-built_in">control</span>(), adr, val, bt, adr_type, mo, is_vol);<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.hpp</span><br>  <span class="hljs-function">Node* <span class="hljs-title">store_oop_to_object</span><span class="hljs-params">(Node* ctl,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* obj,   <span class="hljs-comment">// containing obj</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* adr,   <span class="hljs-comment">// actual adress to store val at</span></span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> TypePtr* adr_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* val,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> TypeOopPtr* val_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                            BasicType bt,</span></span><br><span class="hljs-params"><span class="hljs-function">                            MemNode::MemOrd mo)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">store_oop</span>(ctl, obj, adr, adr_type, val, val_type, bt, <span class="hljs-literal">false</span>, mo);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>创建详细过程可以读者自行理解，此处只关注调用关系，最终调用到 store_oop </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.cpp</span><br><br><span class="hljs-function">Node* <span class="hljs-title">GraphKit::store_oop</span><span class="hljs-params">(<span class="hljs-comment">/* 参数 */</span>)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">pre_barrier</span>(<span class="hljs-literal">true</span> <span class="hljs-comment">/* do_load */</span>, <span class="hljs-built_in">control</span>(), obj, adr, adr_idx, val, val_type, <span class="hljs-literal">NULL</span> <span class="hljs-comment">/* pre_val */</span>, bt);<br><br>  Node* store = <span class="hljs-built_in">store_to_memory</span>(<span class="hljs-built_in">control</span>(), adr, val, bt, adr_idx, mo, mismatched);<br><br>  <span class="hljs-built_in">post_barrier</span>(<span class="hljs-built_in">control</span>(), store, obj, adr, adr_idx, val, bt, use_precise);<br>  <span class="hljs-keyword">return</span> store;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 store_to_memory 函数的前后分别加入了 pre_barrier 和 post_barrier 当函数需要 C2 编译运行，同时 GC 选用的是 G1GC 时，会在解析字节码时就为 write_barrier 生成相关的结点。</p>
<h2 id="pre-barrier-在C2编译中的实现"><a href="#pre-barrier-在C2编译中的实现" class="headerlink" title="pre_barrier 在C2编译中的实现"></a>pre_barrier 在C2编译中的实现</h2><p>接下来追溯 pre_barrier 到底生成了哪些节点， </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::pre_barrier</span><span class="hljs-params">(<span class="hljs-comment">/*..*/</span>)</span> </span>&#123;<br><br>  BarrierSet* bs = Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">barrier_set</span>();<br>  <span class="hljs-built_in">set_control</span>(ctl);<br>  <span class="hljs-comment">//与模板解释器相同，需要根据选项选择 barrier 此处只关心 G1GC 部分</span><br>  <span class="hljs-keyword">switch</span> (bs-&gt;<span class="hljs-built_in">kind</span>()) &#123;<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCT:<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCTLogging:<br>      <span class="hljs-built_in">g1_write_barrier_pre</span>(do_load, obj, adr, adr_idx, val, val_type, pre_val, bt);<br>      <span class="hljs-keyword">break</span>;<br>  <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// G1 pre/post barriers</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::g1_write_barrier_pre</span><span class="hljs-params">(<span class="hljs-type">bool</span> do_load,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* obj,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    uint alias_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* val,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-type">const</span> TypeOopPtr* val_type,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Node* pre_val,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    BasicType bt)</span> </span>&#123;<br><br>  <span class="hljs-comment">// Some sanity checks</span><br>  <span class="hljs-comment">// Note: val is unused in this routine.</span><br><br>  <span class="hljs-function">IdealKit <span class="hljs-title">ideal</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>)</span></span>;<br><br>  Node* tls = __ <span class="hljs-built_in">thread</span>(); <span class="hljs-comment">// ThreadLocalStorage</span><br><br>  Node* no_ctrl = <span class="hljs-literal">NULL</span>;<br>  Node* no_base = __ <span class="hljs-built_in">top</span>();<br>  Node* zero  = __ <span class="hljs-built_in">ConI</span>(<span class="hljs-number">0</span>);<br>  Node* zeroX = __ <span class="hljs-built_in">ConX</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-type">float</span> likely  = <span class="hljs-built_in">PROB_LIKELY</span>(<span class="hljs-number">0.999</span>);<br>  <span class="hljs-type">float</span> unlikely  = <span class="hljs-built_in">PROB_UNLIKELY</span>(<span class="hljs-number">0.999</span>);<br><br>  BasicType active_type = <span class="hljs-built_in">in_bytes</span>(PtrQueue::<span class="hljs-built_in">byte_width_of_active</span>()) == <span class="hljs-number">4</span> ? T_INT : T_BYTE;<br> <br>  <span class="hljs-comment">// Offsets into the thread 根据 thread 得到需要值的偏移地址</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> marking_offset = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">satb_mark_queue_offset</span>() +  <span class="hljs-comment">// 648</span><br>                                          PtrQueue::<span class="hljs-built_in">byte_offset_of_active</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> index_offset   = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">satb_mark_queue_offset</span>() +  <span class="hljs-comment">// 656</span><br>                                          PtrQueue::<span class="hljs-built_in">byte_offset_of_index</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffer_offset  = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">satb_mark_queue_offset</span>() +  <span class="hljs-comment">// 652</span><br>                                          PtrQueue::<span class="hljs-built_in">byte_offset_of_buf</span>());<br><br>  <span class="hljs-comment">// Now the actual pointers into the thread 加法节点获取计算得到的地址</span><br>  Node* marking_adr = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(marking_offset));<br>  Node* buffer_adr  = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(buffer_offset));<br>  Node* index_adr   = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(index_offset));<br><br>  <span class="hljs-comment">// Now some of the values</span><br>  Node* marking = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), marking_adr, TypeInt::INT, active_type, Compile::AliasIdxRaw);<br><br>  <span class="hljs-comment">// if (!marking) 判断是否为并发标记阶段</span><br>  <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(marking, BoolTest::ne, zero, unlikely)</span></span>; &#123;<br>    BasicType index_bt = TypeX_X-&gt;<span class="hljs-built_in">basic_type</span>();<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>) == <span class="hljs-built_in">type2aelembytes</span>(index_bt), <span class="hljs-string">&quot;Loading G1 PtrQueue::_index with wrong size.&quot;</span>);<br>    Node* index   = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);<br><br>    <span class="hljs-keyword">if</span> (do_load) &#123;<br>      <span class="hljs-comment">// load original value</span><br>      <span class="hljs-comment">// alias_idx correct??</span><br>      pre_val = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), adr, val_type, bt, alias_idx);<br>    &#125;<br><br>    <span class="hljs-comment">// if (pre_val != NULL) 判断域之前的值是否为空</span><br>    <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(pre_val, BoolTest::ne, null())</span></span>; &#123;<br>      Node* buffer  = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), buffer_adr, TypeRawPtr::NOTNULL, T_ADDRESS, Compile::AliasIdxRaw);<br><br>      <span class="hljs-comment">// is the queue for this thread full? 当前线程的 satb 队列是否已满，已满会调用运行时的 g1_wb_pre</span><br>      <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(index, BoolTest::ne, zeroX, likely)</span></span>; &#123;<br><br>        <span class="hljs-comment">// decrement the index</span><br>        Node* next_index = _gvn.<span class="hljs-built_in">transform</span>(<span class="hljs-built_in">new</span> (C) <span class="hljs-built_in">SubXNode</span>(index, __ <span class="hljs-built_in">ConX</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">intptr_t</span>))));<br><br>        <span class="hljs-comment">// Now get the buffer location we will log the previous value into and store it 入队</span><br>        Node *log_addr = __ <span class="hljs-built_in">AddP</span>(no_base, buffer, next_index);<br>        <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), log_addr, pre_val, T_OBJECT, Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br>        <span class="hljs-comment">// update the index</span><br>        <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), index_adr, next_index, index_bt, Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br><br>      &#125; <span class="hljs-function">__ <span class="hljs-title">else_</span><span class="hljs-params">()</span></span>; &#123;<br><br>        <span class="hljs-comment">// logging buffer is full, call the runtime 运行时 g1_wb_pre 函数与模板解释器调用的是同一个</span><br>        <span class="hljs-type">const</span> TypeFunc *tf = OptoRuntime::<span class="hljs-built_in">g1_wb_pre_Type</span>();<br>        <span class="hljs-function">__ <span class="hljs-title">make_leaf_call</span><span class="hljs-params">(tf, CAST_FROM_FN_PTR(address, SharedRuntime::g1_wb_pre), <span class="hljs-string">&quot;g1_wb_pre&quot;</span>, pre_val, tls)</span></span>;<br>      &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// (!index)</span><br>    &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// (pre_val != NULL)</span><br>  &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// (!marking)</span><br><br>  <span class="hljs-comment">// Final sync IdealKit and GraphKit.</span><br>  <span class="hljs-built_in">final_sync</span>(ideal);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>整体逻辑类似，判断 pre_val 是否空，线程队列是否满，根据判断结果调用运行时或者生成将 pre_val 入栈的节点<br>在生成理想图节点后，C2编译器会对理想图做优化，最后生成机器代码，详细过程如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PhaseTraceId</span> &#123;<br>_t_parser, <span class="hljs-comment">// 1. 字节码解析与理想图生成</span><br>_t_optimizer, <span class="hljs-comment">// 2. 机器无关优化</span><br>...<br>_t_matcher, <span class="hljs-comment">// 3. 指令选择</span><br>_t_scheduler, <span class="hljs-comment">// 4. 指令调度和全局代码提出</span><br>_t_registerAllocation, <span class="hljs-comment">// 5. 寄存器分配</span><br>...<br>_t_blockOrdering, <span class="hljs-comment">// 6. 移除空基本块</span><br>_t_peephole, <span class="hljs-comment">// 7. 窥孔优化</span><br>_t_postalloc_expand,<br>_t_output, <span class="hljs-comment">// 8. 生成机器代码</span><br>...<br>_t_registerMethod, <span class="hljs-comment">// 9. 用编译生成的方法代替Java方法</span><br>_t_tec,<br>max_phase_timers<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这部分不是本文关注的重点，为了方便研究 C2 编译结果可以通过 slowdebug 版本的 hotspot ，在运行程序时添加参数 -XX:+PrintOptoAssembly 查看 Opto （也可以直接查看汇编，但是 Opto 更直观），仍以上文例子为例可以在x86平台得到如下两段 Opto 节选，分别是 G1GC 与其他不会产生 pre_barrier 的 GC</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无 pre_barrier</span><br>movq    [R10 + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)], RBP	# ptr ! Field: Node.next <span class="hljs-comment">//将寄存器RBP中的新值写入内存</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">B5: #	B13 B6 &lt;- B4  Freq: <span class="hljs-number">0.999979</span><br>	# TLS is in R15<br>	movsbl  R10, [R15 + #<span class="hljs-number">1424</span> (<span class="hljs-number">32</span>-bit)]	# <span class="hljs-type">byte</span>                  <br>	testl   R10, R10                                        <br>	jne     B13  P=<span class="hljs-number">0.001000</span> C=-<span class="hljs-number">1.000000</span>   <span class="hljs-comment">//if (!marking) -&gt;B13</span><br><br>B13: #	B6 B14 &lt;- B5  Freq: <span class="hljs-number">0.000999966</span><br>	movq    RDI, [RBX + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)]	# ptr ! Field: Node.next  <span class="hljs-comment">//pre_val</span><br>	testq   RDI, RDI	# ptr         <br>	je     B6  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>   <span class="hljs-comment">//if (pre_val != NULL) -&gt;B14</span><br><br>B14: #	B19 B15 &lt;- B13  Freq: <span class="hljs-number">0.000499983</span><br>	# TLS is in R15<br>	movq    R10, [R15 + #<span class="hljs-number">1440</span> (<span class="hljs-number">32</span>-bit)]	# <span class="hljs-type">long</span><br>	testq   R10, R10<br>	je,s   B19  P=<span class="hljs-number">0.001000</span> C=-<span class="hljs-number">1.000000</span>  <span class="hljs-comment">// is the queue for this thread full? full -&gt; B19 else -&gt; B15</span><br><br>B19: #	B6 &lt;- B14  Freq: <span class="hljs-number">4.99977e-07</span><br>	# TLS is in R15<br>	movq    RSI, R15	# spill           <span class="hljs-comment">// logging buffer is full</span><br>	call_leaf,runtime  g1_wb_pre        <span class="hljs-comment">// 调用运行时函数 g1_wb_pre</span><br>  No JVM State Info<br>  # <br>	jmp     B6<br><br>B15: #	B6 &lt;- B14  Freq: <span class="hljs-number">0.000499483</span><br>	# TLS is in R15<br>	movq    R11, [R15 + #<span class="hljs-number">1432</span> (<span class="hljs-number">32</span>-bit)]	# ptr<br>	movq    [R11 + #-<span class="hljs-number">8</span> + R10], RDI	# ptr   <span class="hljs-comment">// pre_val 入队</span><br>	addq    R10, #-<span class="hljs-number">8</span>	# <span class="hljs-type">long</span>    <span class="hljs-comment">//将 _index 减去 oopSize</span><br>	# TLS is in R15<br>	movq    [R15 + #<span class="hljs-number">1440</span> (<span class="hljs-number">32</span>-bit)], R10	# <span class="hljs-type">long</span><br>	jmp     B6<br><br>B6: #	B12 B7 &lt;- B19 B15 B13 B5  Freq: <span class="hljs-number">0.999979</span><br>	movq    [RBX + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)], RBP	# ptr ! Field: Node.next  <span class="hljs-comment">//新值写入域</span><br><br></code></pre></td></tr></table></figure>

<p>整体过程与理想图阶段生成的节点，能一一对应。</p>
<h2 id="post-barrier-在C2编译中的实现"><a href="#post-barrier-在C2编译中的实现" class="headerlink" title="post_barrier 在C2编译中的实现"></a>post_barrier 在C2编译中的实现</h2><p>post_barrier 的逻辑大体与 pre_barrier 相同，如下会根据 barrier 类型 G1GC 匹配到 g1_write_barrier_post</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/opto/graphKit.cpp</span><br><span class="hljs-comment">//相同的逻辑，此处不作赘述</span><br>  <span class="hljs-keyword">switch</span> (bs-&gt;<span class="hljs-built_in">kind</span>()) &#123;<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCT:<br>    <span class="hljs-keyword">case</span> BarrierSet::G1SATBCTLogging:<br>      <span class="hljs-built_in">g1_write_barrier_post</span>(store, obj, adr, adr_idx, val, bt, use_precise);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::g1_write_barrier_post</span><span class="hljs-params">(Node* oop_store,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     Node* obj,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     Node* adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     uint alias_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     Node* val,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     BasicType bt,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">bool</span> use_precise)</span> </span>&#123;<br>  <span class="hljs-comment">// If we are writing a NULL then we need no post barrier</span><br><br>  <span class="hljs-keyword">if</span> (val != <span class="hljs-literal">NULL</span> &amp;&amp; val-&gt;<span class="hljs-built_in">is_Con</span>() &amp;&amp; val-&gt;<span class="hljs-built_in">bottom_type</span>() == TypePtr::NULL_PTR) &#123;<br>    <span class="hljs-comment">// Must be NULL</span><br>    <span class="hljs-type">const</span> Type* t = val-&gt;<span class="hljs-built_in">bottom_type</span>();<br>    <span class="hljs-built_in">assert</span>(t == Type::TOP || t == TypePtr::NULL_PTR, <span class="hljs-string">&quot;must be NULL&quot;</span>);<br>    <span class="hljs-comment">// No post barrier if writing NULLx</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!use_precise) &#123;<br>    <span class="hljs-comment">// All card marks for a (non-array) instance are in one place:</span><br>    adr = obj;<br>  &#125;<br>  <span class="hljs-comment">// (Else it&#x27;s an array (or unknown), and we want more precise card marks.)</span><br>  <span class="hljs-built_in">assert</span>(adr != <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>  <span class="hljs-function">IdealKit <span class="hljs-title">ideal</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>)</span></span>;<br><br>  Node* tls = __ <span class="hljs-built_in">thread</span>(); <span class="hljs-comment">// ThreadLocalStorage</span><br><br>  Node* no_base = __ <span class="hljs-built_in">top</span>();<br>  <span class="hljs-type">float</span> likely  = <span class="hljs-built_in">PROB_LIKELY</span>(<span class="hljs-number">0.999</span>);<br>  <span class="hljs-type">float</span> unlikely  = <span class="hljs-built_in">PROB_UNLIKELY</span>(<span class="hljs-number">0.999</span>);<br>  Node* young_card = __ <span class="hljs-built_in">ConI</span>((jint)G1SATBCardTableModRefBS::<span class="hljs-built_in">g1_young_card_val</span>());<br>  Node* dirty_card = __ <span class="hljs-built_in">ConI</span>((jint)CardTableModRefBS::<span class="hljs-built_in">dirty_card_val</span>());<br>  Node* zeroX = __ <span class="hljs-built_in">ConX</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Get the alias_index for raw card-mark memory</span><br>  <span class="hljs-type">const</span> TypePtr* card_type = TypeRawPtr::BOTTOM;<br><br>  <span class="hljs-type">const</span> TypeFunc *tf = OptoRuntime::<span class="hljs-built_in">g1_wb_post_Type</span>();<br><br>  <span class="hljs-comment">// Offsets into the thread 获取偏移</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> index_offset  = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">dirty_card_queue_offset</span>() +<br>                                     PtrQueue::<span class="hljs-built_in">byte_offset_of_index</span>());<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffer_offset = <span class="hljs-built_in">in_bytes</span>(JavaThread::<span class="hljs-built_in">dirty_card_queue_offset</span>() +<br>                                     PtrQueue::<span class="hljs-built_in">byte_offset_of_buf</span>());<br><br>  <span class="hljs-comment">// Pointers into the thread 与 thread 值相加计算具体地址</span><br><br>  Node* buffer_adr = __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(buffer_offset));<br>  Node* index_adr =  __ <span class="hljs-built_in">AddP</span>(no_base, tls, __ <span class="hljs-built_in">ConX</span>(index_offset));<br><br>  <span class="hljs-comment">// ... 部分优化 与 值获取</span><br><br>  <span class="hljs-comment">// If we know the value being stored does it cross regions? 判断是否产生跨区域</span><br><br>  <span class="hljs-keyword">if</span> (val != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// Does the store cause us to cross regions?</span><br><br>    <span class="hljs-comment">// Should be able to do an unsigned compare of region_size instead of</span><br>    <span class="hljs-comment">// and extra shift. Do we have an unsigned compare??</span><br>    <span class="hljs-comment">// Node* region_size = __ ConI(1 &lt;&lt; HeapRegion::LogOfHRGrainBytes); </span><br>    <br>    <span class="hljs-comment">// 判断方式为 check = obj ^ newobj</span><br>    Node* xor_res =  __ <span class="hljs-built_in">URShiftX</span> ( __ <span class="hljs-built_in">XorX</span>( cast,  __ <span class="hljs-built_in">CastPX</span>(__ <span class="hljs-built_in">ctrl</span>(), val)), __ <span class="hljs-built_in">ConI</span>(HeapRegion::LogOfHRGrainBytes));<br><br>    <span class="hljs-comment">// if (xor_res == 0) same region so skip </span><br>    <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(xor_res, BoolTest::ne, zeroX)</span></span>; &#123;<br><br>      <span class="hljs-comment">// No barrier if we are storing a NULL 如果是 NULL 也不需要 barrier</span><br>      <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(val, BoolTest::ne, null(), unlikely)</span></span>; &#123;<br><br>        <span class="hljs-comment">// Ok must mark the card if not already dirty</span><br><br>        <span class="hljs-comment">// load the original value of the card </span><br>        Node* card_val = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);<br><br>        <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(card_val, BoolTest::ne, young_card)</span></span>; &#123;   <span class="hljs-comment">// 判断是否是 young 区的跨界引用， young 区每次都会被收集，故不维护 Rset</span><br>          <span class="hljs-built_in">sync_kit</span>(ideal);<br>          <span class="hljs-comment">// Use Op_MemBarVolatile to achieve the effect of a StoreLoad barrier.</span><br>          <span class="hljs-built_in">insert_mem_bar</span>(Op_MemBarVolatile, oop_store);<br>          <span class="hljs-function">__ <span class="hljs-title">sync_kit</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br><br>          Node* card_val_reload = __ <span class="hljs-built_in">load</span>(__ <span class="hljs-built_in">ctrl</span>(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);<br>          <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(card_val_reload, BoolTest::ne, dirty_card)</span></span>; &#123;<span class="hljs-comment">//判断卡片是否已经脏</span><br>            <span class="hljs-comment">// 调用 g1_mark_card 函数 ，该函数的作用为更新卡表，并将卡片地址入队</span><br>            <span class="hljs-built_in">g1_mark_card</span>(ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);<br>          &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>        &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>      &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>    &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Object.clone() instrinsic uses this path.</span><br>    <span class="hljs-built_in">g1_mark_card</span>(ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);<br>  &#125;<br><br>  <span class="hljs-comment">// Final sync IdealKit and GraphKit.</span><br>  <span class="hljs-built_in">final_sync</span>(ideal);<br>&#125;<br><br><span class="hljs-comment">// Update the card table and add card address to the queue</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GraphKit::g1_mark_card</span><span class="hljs-params">(IdealKit&amp; ideal,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* card_adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* oop_store,</span></span><br><span class="hljs-params"><span class="hljs-function">                            uint oop_alias_idx,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* index,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* index_adr,</span></span><br><span class="hljs-params"><span class="hljs-function">                            Node* buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">const</span> TypeFunc* tf)</span> </span>&#123;<br><br>  Node* zero  = __ <span class="hljs-built_in">ConI</span>(<span class="hljs-number">0</span>);<br>  Node* zeroX = __ <span class="hljs-built_in">ConX</span>(<span class="hljs-number">0</span>);<br>  Node* no_base = __ <span class="hljs-built_in">top</span>();<br>  BasicType card_bt = T_BYTE;<br>  <span class="hljs-comment">// Smash zero into card. MUST BE ORDERED WRT TO STORE</span><br>  <span class="hljs-function">__ <span class="hljs-title">storeCM</span><span class="hljs-params">(__ ctrl(), card_adr, zero, oop_store, oop_alias_idx, card_bt, Compile::AliasIdxRaw)</span></span>;<br><br>  <span class="hljs-comment">//  Now do the queue work</span><br>  <span class="hljs-function">__ <span class="hljs-title">if_then</span><span class="hljs-params">(index, BoolTest::ne, zeroX)</span></span>; &#123;<span class="hljs-comment">//如果当前线程队列未满</span><br><br>    Node* next_index = _gvn.<span class="hljs-built_in">transform</span>(<span class="hljs-built_in">new</span> (C) <span class="hljs-built_in">SubXNode</span>(index, __ <span class="hljs-built_in">ConX</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">intptr_t</span>))));<br>    Node* log_addr = __ <span class="hljs-built_in">AddP</span>(no_base, buffer, next_index);<br><br>    <span class="hljs-comment">// Order, see storeCM.</span><br>    <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), log_addr, card_adr, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br>    <span class="hljs-function">__ <span class="hljs-title">store</span><span class="hljs-params">(__ ctrl(), index_adr, next_index, TypeX_X-&gt;basic_type(), Compile::AliasIdxRaw, MemNode::unordered)</span></span>;<br><br>  &#125; <span class="hljs-function">__ <span class="hljs-title">else_</span><span class="hljs-params">()</span></span>; &#123;<span class="hljs-comment">//线程队列已满会调用运行时</span><br>    <span class="hljs-function">__ <span class="hljs-title">make_leaf_call</span><span class="hljs-params">(tf, CAST_FROM_FN_PTR(address, SharedRuntime::g1_wb_post), <span class="hljs-string">&quot;g1_wb_post&quot;</span>, card_adr, __ thread())</span></span>;<br>  &#125; <span class="hljs-function">__ <span class="hljs-title">end_if</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>理想图部分代码与模板解释器体现的逻辑也是一致的，接下来看看最终生成的 Opto</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java">B6: #	B12 B7 &lt;- B19 B15 B13 B5  Freq: <span class="hljs-number">0.999979</span><br>	movq    [RBX + #<span class="hljs-number">24</span> (<span class="hljs-number">8</span>-bit)], RBP	# ptr ! Field: Node.next <span class="hljs-comment">//完成对象域新值的写入</span><br>	movq    R10, RBP	# ptr -&gt; <span class="hljs-type">long</span><br>	movq    R11, RBX	# ptr -&gt; <span class="hljs-type">long</span><br>	xorq    R10, R11	# <span class="hljs-type">long</span><br>	shrq    R10, #<span class="hljs-number">20</span><br>	testq   R10, R10<br>	je,s   B12  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>    <span class="hljs-comment">//if (xor_res == 0) same region so skip -&gt; B12 ret else -&gt; B7</span><br><br>B7: #	B12 B8 &lt;- B6  Freq: <span class="hljs-number">0.499989</span><br>shrq    R11, #<span class="hljs-number">9</span><br>	movq    RDI, <span class="hljs-number">0x00007ecf56bf1000</span>	# ptr<br>	addq    RDI, R11	# ptr<br>	movsbl  R10, [RDI]	# <span class="hljs-type">byte</span><br>	cmpl    R10, #<span class="hljs-number">32</span><br>	je,s   B12  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>  <span class="hljs-comment">// if_then(card_val, BoolTest::ne, young_card) 不用维护 young 区域的 Rset</span><br> <br>B8: #	B12 B9 &lt;- B7  Freq: <span class="hljs-number">0.249995</span><br>	# TLS is in R15<br>	movq    R10, [R15 + #<span class="hljs-number">1504</span> (<span class="hljs-number">32</span>-bit)]	# <span class="hljs-type">long</span><br>	# TLS is in R15<br>	movq    R11, [R15 + #<span class="hljs-number">1496</span> (<span class="hljs-number">32</span>-bit)]	# ptr<br>	lock addl [rsp + #<span class="hljs-number">0</span>], <span class="hljs-number">0</span>	! membar_volatile <span class="hljs-comment">// 内存序</span><br>	movsbl  R9, [RDI]	# <span class="hljs-type">byte</span><br>	testl   R9, R9<br>	je,s   B12  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span>   <span class="hljs-comment">// if_then(card_val_reload, BoolTest::ne, dirty_card) 判断卡片是否已经脏</span><br><br>B9: #	B11 B10 &lt;- B8  Freq: <span class="hljs-number">0.124997</span>   <br>	movb    [RDI], #<span class="hljs-number">0</span>	# CMS card-mark <span class="hljs-type">byte</span> <span class="hljs-number">0</span>  <span class="hljs-comment">// Smash zero into card. MUST BE ORDERED WRT TO STORE 卡片置为脏</span><br>	testq   R10, R10<br>	jne,s   B11  P=<span class="hljs-number">0.500000</span> C=-<span class="hljs-number">1.000000</span> <span class="hljs-comment">// if_then(index, BoolTest::ne, zeroX) 判断当前线程队列是否已满</span><br><br>B10: #	B12 &lt;- B9  Freq: <span class="hljs-number">0.0624987</span><br>	# TLS is in R15<br>	movq    RSI, R15	# spill<br>	call_leaf,runtime  g1_wb_post <span class="hljs-comment">// queue full runtime</span><br>  No JVM State Info<br>  # <br>	jmp,s   B12<br><br>B11: #	B12 &lt;- B9  Freq: <span class="hljs-number">0.0624987</span>  <span class="hljs-comment">//  Now do the queue work 入队</span><br>	movq    [R11 + #-<span class="hljs-number">8</span> + R10], RDI	# ptr<br>	addq    R10, #-<span class="hljs-number">8</span>	# <span class="hljs-type">long</span>  <span class="hljs-comment">//将 _index 减去 oopSize</span><br>	# TLS is in R15<br>	movq    [R15 + #<span class="hljs-number">1504</span> (<span class="hljs-number">32</span>-bit)], R10	# <span class="hljs-type">long</span><br><br>B12: #	N1 &lt;- B10 B11 B8 B7 B6  Freq: <span class="hljs-number">0.999979</span><br>	addq    rsp, <span class="hljs-number">32</span>	# Destroy frame<br>popq   rbp<br>testl  rax, [rip + #offset_to_poll_page]	# Safepoint: poll <span class="hljs-keyword">for</span> GC<br><br>	ret<br><br></code></pre></td></tr></table></figure>

<h1 id="write-barrier-在运行时的实现"><a href="#write-barrier-在运行时的实现" class="headerlink" title="write-barrier 在运行时的实现"></a>write-barrier 在运行时的实现</h1><p>上文频繁提及，当队列满了会调用运行时实现写屏障，接下来看一下运行时对写屏障的实现</p>
<h2 id="g1-wb-pre-与-g1-wb-post-在运行时的实现"><a href="#g1-wb-pre-与-g1-wb-post-在运行时的实现" class="headerlink" title="g1_wb_pre 与 g1_wb_post 在运行时的实现"></a>g1_wb_pre 与 g1_wb_post 在运行时的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// G1 write-barrier pre: executed before a pointer store.</span><br><span class="hljs-built_in">JRT_LEAF</span>(<span class="hljs-type">void</span>, SharedRuntime::<span class="hljs-built_in">g1_wb_pre</span>(oopDesc* orig, JavaThread *thread))<br>  <span class="hljs-keyword">if</span> (orig == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;should be optimized out&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">assert</span>(orig-&gt;<span class="hljs-built_in">is_oop</span>(<span class="hljs-literal">true</span> <span class="hljs-comment">/* ignore mark word */</span>), <span class="hljs-string">&quot;Error&quot;</span>);<br>  <span class="hljs-comment">// store the original value that was in the field reference</span><br>  thread-&gt;<span class="hljs-built_in">satb_mark_queue</span>().<span class="hljs-built_in">enqueue</span>(orig);<br>JRT_END<br><br><span class="hljs-comment">// G1 write-barrier post: executed after a pointer store.</span><br><span class="hljs-built_in">JRT_LEAF</span>(<span class="hljs-type">void</span>, SharedRuntime::<span class="hljs-built_in">g1_wb_post</span>(<span class="hljs-type">void</span>* card_addr, JavaThread* thread))<br>  thread-&gt;<span class="hljs-built_in">dirty_card_queue</span>().<span class="hljs-built_in">enqueue</span>(card_addr);<br>JRT_END<br></code></pre></td></tr></table></figure>
<p>运行时的代码更直观，即将域前值&#x2F;卡片地址入队，其中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// SATB marking queue support</span><br><span class="hljs-function">ObjPtrQueue&amp; <span class="hljs-title">satb_mark_queue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _satb_mark_queue; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> SATBMarkQueueSet&amp; <span class="hljs-title">satb_mark_queue_set</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> _satb_mark_queue_set;<br>&#125;<br><br><span class="hljs-comment">// Dirty card queue support</span><br><span class="hljs-function">DirtyCardQueue&amp; <span class="hljs-title">dirty_card_queue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _dirty_card_queue; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> DirtyCardQueueSet&amp; <span class="hljs-title">dirty_card_queue_set</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> _dirty_card_queue_set;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这些值在<a href="#g1_write_barrier_pre">上文</a>曾多次提及</p>
<p>根据上面对模板解释器和 C2 编译的分析，只有当当前线程队列满时才会调用到运行时，追溯 enqueue 的实现，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ObjPtrQueue _satb_mark_queue;          <span class="hljs-comment">// Thread-local log for SATB barrier.</span><br>DirtyCardQueue _dirty_card_queue;      <span class="hljs-comment">// Thread-local log for dirty cards.</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjPtrQueue</span>: <span class="hljs-keyword">public</span> PtrQueue&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirtyCardQueue</span>: <span class="hljs-keyword">public</span> PtrQueue&#123;&#125;<br><br></code></pre></td></tr></table></figure>
<p>enqueue 函数的实现在 ObjPtrQueue 与 DirtyCardQueue 类的共同父类 PtrQueue 中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//hotspot/src/share/vm/gc_implementation/g1/ptrQueue.hpp</span><br>  <span class="hljs-comment">// Enqueues the given &quot;obj&quot;.</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!_active) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">enqueue_known_active</span>(ptr);<br>  &#125;<br><br><span class="hljs-comment">//hotspot/src/share/vm/gc_implementation/g1/ptrQueue.cpp</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueue::enqueue_known_active</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> </span>&#123;<br><br>  <span class="hljs-keyword">while</span> (_index == <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//当前线程已满调用 handle_zero_index 函数</span><br>    <span class="hljs-built_in">handle_zero_index</span>();  <span class="hljs-comment">//handle_zero_index 函数会为线程私有队列置申请新空间，并重置 _index 为 size</span><br>  &#125;<br><br>  <span class="hljs-comment">// 将 _index 减去 oopSize，并将对象指针入队</span><br>  _index -= oopSize;<br>  _buf[<span class="hljs-built_in">byte_index_to_index</span>((<span class="hljs-type">int</span>)_index)] = ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueue::handle_zero_index</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(_index == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Precondition.&quot;</span>);<br><br>  <span class="hljs-comment">// This thread records the full buffer and allocates a new one (while</span><br>  <span class="hljs-comment">// holding the lock if there is one).</span><br>  <span class="hljs-keyword">if</span> (_buf != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">should_enqueue_buffer</span>()) &#123;<br>      <span class="hljs-built_in">assert</span>(_index &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;the buffer can only be re-used if it&#x27;s not full&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_lock) &#123;<br>      <span class="hljs-built_in">assert</span>(_lock-&gt;<span class="hljs-built_in">owned_by_self</span>(), <span class="hljs-string">&quot;Required.&quot;</span>);<br><br>      <span class="hljs-type">void</span>** buf = _buf;   <span class="hljs-comment">// local pointer to completed buffer</span><br>      _buf = <span class="hljs-literal">NULL</span>;         <span class="hljs-comment">// clear shared _buf field</span><br><br>      <span class="hljs-built_in">locking_enqueue_completed_buffer</span>(buf);  <span class="hljs-comment">// enqueue completed buffer 将线程私有的队列加入链表</span><br><br>      <span class="hljs-keyword">if</span> (_buf != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//...</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// Reallocate the buffer 重新为当前线程的队列申请新空间，再将 _index = _sz</span><br>  _buf = <span class="hljs-built_in">qset</span>()-&gt;<span class="hljs-built_in">allocate_buffer</span>();<br>  _sz = <span class="hljs-built_in">qset</span>()-&gt;<span class="hljs-built_in">buffer_size</span>();<br>  _index = _sz;<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-number">0</span> &lt;= _index &amp;&amp; _index &lt;= _sz, <span class="hljs-string">&quot;Invariant.&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueue::locking_enqueue_completed_buffer</span><span class="hljs-params">(<span class="hljs-type">void</span>** buf)</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(_lock-&gt;<span class="hljs-built_in">owned_by_self</span>(), <span class="hljs-string">&quot;Required.&quot;</span>);<br><br>  <span class="hljs-comment">// We have to unlock _lock (which may be Shared_DirtyCardQ_lock) before</span><br>  <span class="hljs-comment">// we acquire DirtyCardQ_CBL_mon inside enqeue_complete_buffer as they</span><br>  <span class="hljs-comment">// have the same rank and we may get the &quot;possible deadlock&quot; message</span><br>  _lock-&gt;<span class="hljs-built_in">unlock</span>();<br><br>  <span class="hljs-built_in">qset</span>()-&gt;<span class="hljs-built_in">enqueue_complete_buffer</span>(buf); <span class="hljs-comment">//将线程私有的队列加入链表</span><br>  <span class="hljs-comment">// We must relock only because the caller will unlock, for the normal</span><br>  <span class="hljs-comment">// case.</span><br>  _lock-&gt;<span class="hljs-built_in">lock_without_safepoint_check</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PtrQueueSet::enqueue_complete_buffer</span><span class="hljs-params">(<span class="hljs-type">void</span>** buf, <span class="hljs-type">size_t</span> index)</span> </span>&#123;<br>  <span class="hljs-function">MutexLockerEx <span class="hljs-title">x</span><span class="hljs-params">(_cbl_mon, Mutex::_no_safepoint_check_flag)</span></span>;<br>  BufferNode* cbn = BufferNode::<span class="hljs-built_in">new_from_buffer</span>(buf);<br>  cbn-&gt;<span class="hljs-built_in">set_index</span>(index);<br>  <span class="hljs-keyword">if</span> (_completed_buffers_tail == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">//链表是否为空</span><br>    <span class="hljs-built_in">assert</span>(_completed_buffers_head == <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Well-formedness&quot;</span>);<br>    _completed_buffers_head = cbn;  <span class="hljs-comment">// 链表头为 buf </span><br>    _completed_buffers_tail = cbn;  <span class="hljs-comment">// 链表尾为 buf</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    _completed_buffers_tail-&gt;<span class="hljs-built_in">set_next</span>(cbn); <span class="hljs-comment">//非空时候 buf 加入链表末尾</span><br>    _completed_buffers_tail = cbn;<br>  &#125;<br>  _n_completed_buffers++; <span class="hljs-comment">//链表长度 +1</span><br>  <span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p id="references"></p>    

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>jdk8源代码</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/">#Java</a>
      
        <a href="/tags/G1GC-write-barrier/">#G1GC-write barrier</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Hotspot源码分析(G1)——write_barrier</div>
      <div>https://treercai.github.io/2023/01/15/Hotspot源码分析-G1-——write-barrier/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Treer Cai</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>January 15, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/25/Specjbb%E6%B5%8B%E8%AF%95%E9%9B%86%E5%88%86%E6%9E%90/" title="Specjbb测试集分析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Specjbb测试集分析</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/20/G1GC%E7%AE%97%E6%B3%95%E7%AF%87/" title="G1GC算法篇">
                        <span class="hidden-mobile">G1GC算法篇</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://treercai.github.io/" target="_blank" rel="nofollow noopener"><span>TreerCai&lsquo;s Blog</span></a> <i class="iconfont icon-love"></i> <div> There is no end to learning. </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
